<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wangsiyuan</title>
  
  <subtitle>小马过河</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="wangsiyuan233.github.io/"/>
  <updated>2018-03-27T07:24:39.585Z</updated>
  <id>wangsiyuan233.github.io/</id>
  
  <author>
    <name>wangsiyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS小结</title>
    <link href="wangsiyuan233.github.io/2018/04/13/9CSS%E5%B0%8F%E7%BB%93/"/>
    <id>wangsiyuan233.github.io/2018/04/13/9CSS小结/</id>
    <published>2018-04-13T10:12:14.299Z</published>
    <updated>2018-03-27T07:24:39.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS黑魔法"><a href="#CSS黑魔法" class="headerlink" title="CSS黑魔法"></a>CSS黑魔法</h2><p><strong>各属性之间相互影响</strong></p><ul><li>margin 和 border：</li></ul><ol><li>上下两个div之间的margin会选择大的呈现</li><li>用一个0.1px的border隔开，上下还是原来的margin数；</li><li>用display：table，上下还是原来的margin数；</li><li>用display：flex，上下还是原来的margin数；</li><li>用overflow：hidden，上下还是原来的margin数；<a id="more"></a></li></ol><ul><li><p>li的小圆点 和 display:<br>当 display:inline 或者 display:block的时候，li的小圆点会消失；</p></li><li><p>position 和 display：<br>当position为 absolute时，设置好的display:inline会变成display:block;</p></li></ul><p><strong>各元素之间相互影响</strong></p><ul><li><p>position 和 transform：<br>position 为 fixed 时，transform scale（0.9），共同缩小页面，元素并没有停留在原来的位置，相对页面固定，而是一起缩小了！</p></li><li><p>float 和 inline:<br>浮动并不仅仅是“在上面”，更深刻的含义是 —— “图文混排” “文字环绕”；</p></li></ul><hr><h2 id="CSS套路"><a href="#CSS套路" class="headerlink" title="CSS套路"></a>CSS套路</h2><ul><li><strong>布局</strong></li></ul><ol><li>web端：IE8用float；chrome用flex；</li><li>手机端：flex；</li></ol><ul><li><strong>水平居中</strong></li></ul><ol><li>inline元素：.parent{text-align：center;} .child{inline / inline-block}</li><li>block元素：child宽度不确定时用margin-left，margin-right；child宽度确定时用margin：auto</li></ol><ul><li><strong>垂直居中</strong>(要点是不要写死height)</li></ul><ol><li>parent高度确定：不管child高度确不确定，都是.parent{padding-top，padding-button;} </li><li>parent高度不确定且child高度不确定，IE8用table；chrome 和 mobile 用flex；（parent能不写死就不要手欠！）</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS黑魔法&quot;&gt;&lt;a href=&quot;#CSS黑魔法&quot; class=&quot;headerlink&quot; title=&quot;CSS黑魔法&quot;&gt;&lt;/a&gt;CSS黑魔法&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;各属性之间相互影响&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;margin 和 border：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;上下两个div之间的margin会选择大的呈现&lt;/li&gt;
&lt;li&gt;用一个0.1px的border隔开，上下还是原来的margin数；&lt;/li&gt;
&lt;li&gt;用display：table，上下还是原来的margin数；&lt;/li&gt;
&lt;li&gt;用display：flex，上下还是原来的margin数；&lt;/li&gt;
&lt;li&gt;用overflow：hidden，上下还是原来的margin数；
    
    </summary>
    
    
      <category term="CSS" scheme="wangsiyuan233.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS(三)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/8CSS-%E4%B8%89/"/>
    <id>wangsiyuan233.github.io/2018/04/13/8CSS-三/</id>
    <published>2018-04-13T10:12:14.283Z</published>
    <updated>2018-03-27T07:25:24.234Z</updated>
    
    <content type="html"><![CDATA[<p><strong>遮罩</strong><br><img src="https://i.imgur.com/BLg9f51.png" alt=""><br><img src="https://i.imgur.com/StiPZuO.png" alt=""></p><ol><li>高能：遮罩的插入图片是在CSS中完成的</li><li>background-image/background-position/background-size 保证背景图均匀平铺<a id="more"></a></li></ol><hr><p><strong>进度条</strong><br><img src="https://i.imgur.com/VvyvN34.png" alt=""><br><img src="https://i.imgur.com/qQ3bNlU.png" alt=""></p><ol><li>progress的height为100%时把progressbar撑起来，width为80%表示进度。</li><li>CSS里统一设置的进度可以靠在HTML里的sytle标签来调节</li></ol><hr><p><strong>任意朝向三角形</strong><br><img src="https://i.imgur.com/mvYDsxp.png" alt=""></p><p>先构造矩形，再transition<br><a href="http://https://css-tricks.com/examples/ShapesOfCSS" target="_blank" rel="external">CSS Tricks</a></p><hr><p><strong><code>&lt;li&gt;</code>元素横向排列有间距</strong></p><ol><li><code>&lt;nav&gt;&lt;ol&gt;&lt;li&gt;A&lt;/li&gt;&lt;li&gt;B&lt;/li&gt;&lt;li&gt;C&lt;/li&gt;&lt;/ol&gt;&lt;/nav&gt;</code></li><li>li元素左浮动，ol元素清除浮动；</li><li>去除li元素的默认样式（list-style:none）,给li元素添加marginig撑开；</li><li>实现li元素有高度排列(就要去爸爸那儿找)：<code>.ol{display: inline-block;vertical-align: top;}</code></li><li>实现ol元素居中（也要去ol的爸爸找）：<code>.nav{text-align: center;}</code></li></ol><hr><p><strong>多个<code>&lt;li&gt;</code>元素处理</strong><br>统一用margin撑开后，第一个li的左边和最后一个li的右边都有我们不需要的margin,这个时候就需要我们用耍赖皮大法了！！<br><code>.portfolia nav ol li:nth-child(3) {margin-right: 0;}</code><br>牛不牛逼！震不震撼！li:nth-child() 括号里面可以填 even(偶数)、odd（奇数）、数字等</p><hr><p><strong>Tips</strong></p><ul><li>圆角：border-shadow:3px;</li><li>温柔变：transition: box-shadow 0.4s;</li><li>box shadow generator</li><li>box-sizing: border-box;//区别于 content-box</li><li>cursor:pointer 手型</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;遮罩&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/BLg9f51.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/StiPZuO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;高能：遮罩的插入图片是在CSS中完成的&lt;/li&gt;
&lt;li&gt;background-image/background-position/background-size 保证背景图均匀平铺
    
    </summary>
    
    
      <category term="CSS" scheme="wangsiyuan233.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS(一)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/6CSS-%E4%B8%80/"/>
    <id>wangsiyuan233.github.io/2018/04/13/6CSS-一/</id>
    <published>2018-04-13T10:12:14.283Z</published>
    <updated>2018-03-27T07:24:41.995Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>http://htmlpreview.github.io/?</code> 拼接 <code>https://github.com/wangsiyuan233/MyResume/blob/master/cv.html</code>可以直接预览我的简历进度。重点是前面的：<code>http://htmlpreview.github.io/?</code><a id="more"></a></li><li>前端知识滚雪球，每18个月要学的东西就会翻倍（此处省略两行泪）</li><li>CSS的框架：SASS、LESS 和 PostCSS</li><li>所有的标签都默认的样式（<code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code> 没有）</li><li>CSS准备工作：body、a、float、clear等等。</li><li>字母的拼接，用两个<code>&lt;span&gt;</code>写在同一行，再用margin-left确定间距，否则中间的间距是默认的一个空格的距离。</li><li>浏览器兼容：IE8是底线，淘宝已经放弃低版本浏览器了</li><li>横条并列导航栏：<strong>子元素float,父元素clearfix。</strong></li><li><code>&lt;a&gt;</code> 和 <code>&lt;li&gt;</code>默认的样式不一样，li没有把a包裹起来，即它们的宽度和高度不一样，解决方法：a{display:block};</li><li>hover一个下划线： <code>a:hover{border-bottom: 3px solid #E8676B;}</code></li><li>但是此时鼠标悬挂时，附近的li就会抖动，因为新生成的下划线挤占了原本的位置，解决方法：<code>a{border-bottom: 3px solid transparent;}</code>（抢先生成一个透明的下划线）</li><li>hover和字体直接的距离靠padding实现</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;code&gt;http://htmlpreview.github.io/?&lt;/code&gt; 拼接 &lt;code&gt;https://github.com/wangsiyuan233/MyResume/blob/master/cv.html&lt;/code&gt;可以直接预览我的简历进度。重点是前面的：&lt;code&gt;http://htmlpreview.github.io/?&lt;/code&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="wangsiyuan233.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS(二)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/7CSS-%E4%BA%8C/"/>
    <id>wangsiyuan233.github.io/2018/04/13/7CSS-二/</id>
    <published>2018-04-13T10:12:14.283Z</published>
    <updated>2018-03-27T07:25:07.759Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这次主要更新userCard部分</strong></p><ol><li>CSS的两大bug：width 和 height;尽量不要写死。规避手段：max-width</li><li>.xxx {text-align: center;} ：让子代的内联元素居中排列，<strong>【内联元素居中要把t-a加在父级元素上】</strong></li><li>width 的默认值是 auto</li><li>display: inline: 设置 宽高 / margin-top/ margin-buttom 都是无效的<a id="more"></a></li><li>文档流是文档内元素流动的方向，内联元素是从左往右，块级元素是从上到下</li><li>line-height可以确定内联元素的高度，line-height = span =font-size</li><li>一个元素的高度是由内容的总和决定的（不是相等哦），浮动出来的元素不算在总高度里</li><li>英文默认是不会自动换行的，所有用英文填充测试的时候，用lorem吧！ 或者设置 word-break：break-all</li><li>非线性流动的时候可以考虑多一层div</li><li>给背景图遮罩：<code>&lt;div class=&quot;banner&quot;&gt;&lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></li><li>给背景图遮罩：<code>.banner{height: 515px;background-image: url(./picture/rs-cover.jpg);background-position: center center;background-size: cover;}</code> 和 <code>.banner .mask{height: 515px;background-color: rgba(0,0,0,0.8)}</code></li><li>回复出厂设置：*{margin:0; padding:0;}</li><li>看不清div：border：1px solid red;</li><li><strong>绝对定位：动的absolute,不动的relative</strong></li><li>奇形怪状：<code>https://css-tricks.com/examples/ShapesOfCSS/#yin-yang</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;这次主要更新userCard部分&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CSS的两大bug：width 和 height;尽量不要写死。规避手段：max-width&lt;/li&gt;
&lt;li&gt;.xxx {text-align: center;} ：让子代的内联元素居中排列，&lt;strong&gt;【内联元素居中要把t-a加在父级元素上】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;width 的默认值是 auto&lt;/li&gt;
&lt;li&gt;display: inline: 设置 宽高 / margin-top/ margin-buttom 都是无效的
    
    </summary>
    
    
      <category term="CSS" scheme="wangsiyuan233.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML(二)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/4HTML-%E4%BA%8C/"/>
    <id>wangsiyuan233.github.io/2018/04/13/4HTML-二/</id>
    <published>2018-04-13T10:12:14.268Z</published>
    <updated>2018-03-27T07:12:05.890Z</updated>
    
    <content type="html"><![CDATA[<ol><li>当出现“键-值”这样的格式（如姓名：wangsiyuan;年龄：18）可以考虑用<code>dl-dt-dd</code></li><li>HTML的语义化即，不要变成div狂魔，可以选择：<code>mian</code>,<code>section</code>,<code>nav</code>,<code>footer</code>等。</li><li>勤记笔记，勤写博客</li><li><code>alt=alternative</code> 可选文字，图片不能识别的时候可以显示文字</li><li><code>nonscript</code>，禁用JS的时候会显示<code>nonscript</code>里面的文字</li><li><code>&lt;hr&gt;</code>是隔断；<code>&lt;br&gt;</code>是换行</li><li>横向布局、纵向布局、grid布局：使用div的时候，要把一列的div用大的div括起来，和下面的div一起形成纵向布局</li><li><code>a[href=&quot;#&quot;]*7&gt;img[src=&quot;#&quot;][alt=&quot;#&quot;]</code>代表啥能一眼看出来不嘻嘻</li><li>同样是【按下去】这个动作，按钮标签是[确定]，a标签是[跳转]<a id="more"></a></li></ol><hr><p>需要增加的HEXO插件</p><ul><li>自定义BLOG结构</li><li>标签云用来显示自己那个标签积累得多</li><li>有一个插件专门用来插入代码，这样就不用截大小不一的图啦</li><li>快速插入图片可以用图床，如七牛云</li><li>字数统计、二维码、评论（duoshuo,来必力，畅言）</li><li>中文搜索 （swiftype）(site:wangsiyuan233.cn 咦？)</li><li>统计来源，关键字，热门话题 （CNZZ、百度统计）</li><li>hexo的中文手册</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;当出现“键-值”这样的格式（如姓名：wangsiyuan;年龄：18）可以考虑用&lt;code&gt;dl-dt-dd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HTML的语义化即，不要变成div狂魔，可以选择：&lt;code&gt;mian&lt;/code&gt;,&lt;code&gt;section&lt;/code&gt;,&lt;code&gt;nav&lt;/code&gt;,&lt;code&gt;footer&lt;/code&gt;等。&lt;/li&gt;
&lt;li&gt;勤记笔记，勤写博客&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alt=alternative&lt;/code&gt; 可选文字，图片不能识别的时候可以显示文字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nonscript&lt;/code&gt;，禁用JS的时候会显示&lt;code&gt;nonscript&lt;/code&gt;里面的文字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt;是隔断；&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;是换行&lt;/li&gt;
&lt;li&gt;横向布局、纵向布局、grid布局：使用div的时候，要把一列的div用大的div括起来，和下面的div一起形成纵向布局&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a[href=&amp;quot;#&amp;quot;]*7&amp;gt;img[src=&amp;quot;#&amp;quot;][alt=&amp;quot;#&amp;quot;]&lt;/code&gt;代表啥能一眼看出来不嘻嘻&lt;/li&gt;
&lt;li&gt;同样是【按下去】这个动作，按钮标签是[确定]，a标签是[跳转]
    
    </summary>
    
    
      <category term="HTML" scheme="wangsiyuan233.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>HTML(三)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/5HTML-%E4%B8%89/"/>
    <id>wangsiyuan233.github.io/2018/04/13/5HTML-三/</id>
    <published>2018-04-13T10:12:14.268Z</published>
    <updated>2018-03-27T07:12:27.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lt-iframe-gt-标签"><a href="#lt-iframe-gt-标签" class="headerlink" title="&lt;iframe&gt; 标签"></a><code>&lt;iframe&gt;</code> 标签</h2><p>用于嵌套页面，是一个可替换标签，默认值是50px X 100px（可以用CSS更改）（CSS的宽度和高度不是一个思路设置的，两个都写100%可能并不都是100%)</p><blockquote><p><code>&lt;iframe src=&quot;#&quot; name=&quot;xxx&quot;&gt;&lt;/iframe&gt;</code><br><code>&lt;a href=&quot;#&quot; target=&quot;xxx&quot;&gt;QQ&lt;/a&gt;</code><br><code>&lt;a href=&quot;#&quot; target=&quot;xxx&quot;&gt;百度&lt;/a&gt;</code></p></blockquote><a id="more"></a><ul><li>iframe的name属性（重点）：令第二个第三个的target等于xxx，就会在iframe里面打开QQ或百度。</li><li>iframe的src属性：写相对路径，跳转至制定页面</li></ul><h2 id="lt-a-gt-标签"><a href="#lt-a-gt-标签" class="headerlink" title="&lt;a&gt; 标签"></a><code>&lt;a&gt;</code> 标签</h2><ul><li><p>target有四个默认属性：<code>_blank</code>是大窗口新标签、<code>_top</code>是顶级、<code>_self</code>是在自己（iframe的小窗）、<code>_parent</code>是在自己（iframe的全窗）。</p><blockquote><p><code>&lt;a href=&quot;https://qq.com&quot; target=&quot;_blank&quot;&gt;blankQQ&lt;/a&gt;</code><br><code>&lt;a href=&quot;https://qq.com&quot; target=&quot;_top&quot;&gt;topQQ&lt;/a&gt;</code><br><code>&lt;a href=&quot;https://qq.com&quot; target=&quot;_self&quot;&gt;selfQQ&lt;/a&gt;</code><br><code>&lt;a href=&quot;https://qq.com&quot; target=&quot;_parent&quot;&gt;parentQQ&lt;/a&gt;</code></p></blockquote></li><li><p>download属性：<br><code>&lt;a href=&quot;https://qq.com&quot; download&gt;下载&lt;/a&gt;</code><br>此时不管是安装包还是网页，都会被下载。</p></li></ul><p>另一个办法是修改http响应层面：令content-type为application/octet-stream时，就会下载。（a标签跳转页面的时候是GET请求）</p><ul><li>href属性:</li></ul><ol><li>href=”qq.com” 时,会分析为一个文件然后报错，应该为<code>https://qq.com</code>.</li><li>href=”” 时，当前页面刷新</li><li>href=”#” 时，页面锚点变成#(只有锚点是不发请求的，锚点是页面内的跳转)</li><li>href=”/xx” 时，浏览器发起GET/HTTP/1.1请求,变成xx.html</li><li>href=”?name.wangsiyuan” 时，浏览器发起GET/HTTP/1.1请求，变成index.html?name.wangsiyuan</li><li>href=”javascript: alert(1);”,JS伪协议，点击链接的时候执行一段代码；在地址栏输入javascript: alert(1)可以执行这段代码；伪协议可以实现[点击之后没有任何动作的超链接标签]，满足特殊要求（可以简写为”javascript:;”）</li><li>href=”//qq.com”无协议链接时，浏览器会根据当前协议，补全无协议的协议；如果用file://浏览页面，就会访问到file://qq.com（这是一个不存在的路径）；尽量不这样使用，避免出错.</li></ol><h2 id="lt-form-gt-标签"><a href="#lt-form-gt-标签" class="headerlink" title="&lt;form&gt; 标签"></a><code>&lt;form&gt;</code> 标签</h2><ul><li>form标签跳转页面发起GET（会把参数直接放到查询框里面所以一般不用）（获取）和POST(主要)（上传）请求</li><li>form表单里一定要有提交按钮搭配使用</li><li>action属性指定请求路径</li><li>method属性指定请求动词（GET或POST）</li><li>请求的第四部分的实现可以靠form标签实现</li><li>target属性和a标签一模一样</li><li>form只有button时，type为button时，不能提交；button的type为空时，button自动升级为submit，就可以提交了；</li><li>form里面的input的type为button时，不能提交；input的type为submit时，可以提交</li><li>submit是唯一一个能确定form表单能不能提交的按钮</li></ul><h2 id="lt-input-gt-和-lt-button-gt-标签"><a href="#lt-input-gt-和-lt-button-gt-标签" class="headerlink" title="&lt;input&gt;和 &lt;button&gt;标签"></a><code>&lt;input&gt;</code>和 <code>&lt;button&gt;</code>标签</h2><ul><li><code>&lt;input type=&quot;submit&quot;&gt;</code>和<code>&lt;button type=&quot;&quot; name=&quot;button&quot; value=&quot;按钮上的字&quot;&gt;&lt;/button&gt;</code> 时， form标签可以被用户提交</li><li>如果input不加name,那么在表单提交时，input的值就不会出现在请求里</li><li>input没有子元素，button有子元素</li><li>input的type属性：</li></ul><ol><li>checkbox:小勾勾，一般会在<code>&lt;input type=&quot;checkbox&quot;&gt;</code>右边加个文字；怎样实现点击文字就能直接勾选框框呢？初级兄弟版（for和id必须成对出现）：<code>&lt;input type=&quot;checkbox&quot; id=&quot;xxx&quot;&gt;&lt;label for=&quot;xxx&quot;&gt;点我&lt;/label&gt;</code>；高级父子版（不需要for和id,name是必须的）：<code>&lt;label&gt;点我&lt;input type=&quot;text&quot; name=&quot;xxx&quot;&gt;&lt;/label&gt;</code>；name相同的时候仍然可以是多选框</li><li>radio：小圆点，<code>&lt;label for=&quot;&quot;&gt;&lt;input name=&quot;pickme&quot; type=&quot;radio&quot; value=&quot;我是对的&quot;&gt;对的&lt;/label&gt;</code> 和 <code>&lt;label for=&quot;&quot;&gt;&lt;input name=&quot;pickme&quot; type=&quot;radio&quot; value=&quot;我是错的&quot;&gt;错的&lt;/label&gt;</code>相同一个name时就成为了单选框</li><li>select: multiple时按着ctrl可以多选，-是空，3号不可选，4号是默认选项<blockquote><p><code>&lt;select name=&quot;group&quot; multiple&gt; &lt;option value=&quot;&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;一&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;二&lt;/option&gt; &lt;option value=&quot;3&quot; disable&gt;三&lt;/option&gt; &lt;option value=&quot;4&quot; selected&gt;四&lt;/option&gt;&lt;/select&gt;</code></p></blockquote></li></ol><h2 id="lt-table-gt-标签"><a href="#lt-table-gt-标签" class="headerlink" title="&lt;table&gt; 标签"></a><code>&lt;table&gt;</code> 标签</h2><ul><li>用户选择多行文本就用textarea,默认的是可以改变大小的，我们需要固定防止bug，可以用CSS或者rows/cols来控制行列。<code>&lt;textarea name=&quot;name&quot; rows=&quot;8&quot; cols=&quot;80&quot;&gt;&lt;/textarea&gt;</code>一定要有name哦！</li><li>table里面的结构：（thead/tbody/tfoot三者的顺序变化会被浏览器自动纠正）</li></ul><p><img src="https://i.imgur.com/3B5SHXq.png" alt=""></p><ul><li>colgroup里的结构：</li></ul><p><img src="https://i.imgur.com/SGaUJ8c.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;lt-iframe-gt-标签&quot;&gt;&lt;a href=&quot;#lt-iframe-gt-标签&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;iframe&amp;gt; 标签&quot;&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 标签&lt;/h2&gt;&lt;p&gt;用于嵌套页面，是一个可替换标签，默认值是50px X 100px（可以用CSS更改）（CSS的宽度和高度不是一个思路设置的，两个都写100%可能并不都是100%)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;iframe src=&amp;quot;#&amp;quot; name=&amp;quot;xxx&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;#&amp;quot; target=&amp;quot;xxx&amp;quot;&amp;gt;QQ&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;#&amp;quot; target=&amp;quot;xxx&amp;quot;&amp;gt;百度&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="wangsiyuan233.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>HTML(一)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/3HTML-%E4%B8%80/"/>
    <id>wangsiyuan233.github.io/2018/04/13/3HTML-一/</id>
    <published>2018-04-13T10:12:14.236Z</published>
    <updated>2018-04-07T01:52:01.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、W3C-简介"><a href="#一、W3C-简介" class="headerlink" title="一、W3C 简介"></a>一、W3C 简介</h2><p>万维网联盟（World Wide Web Consortium，W3C），又称W3C理事会，是万维网的主要国际标准组织。</p><p>W3C由蒂姆·伯纳斯-李于1994年10月离开欧洲核子研究中心（CERN）后成立，在欧盟执委会和国防高等研究计划署（DARPA）的支持下成立于麻省理工学院MIT计算机科学与人工智能实验室（MIT／LCS）[2]，DARPA曾率先推出了互联网及其前身ARPANET。</p><p>该组织试图通过W3C制定的新标准来促进业界成员间的兼容性和协议。不兼容的HTML版本由不同的供应商提供，导致网页显示方式不一致。联盟试图让所有的供应商实施一套由联盟选择的核心原则和组件。</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h2 id="二、MDN简介"><a href="#二、MDN简介" class="headerlink" title="二、MDN简介"></a>二、MDN简介</h2><p>MDN Web Docs（旧称Mozilla Developer Network、Mozilla Developer Center，简称MDN）是一个汇集众多Mozilla基金会产品和网络技术开发文档的免费网站。</p><hr><h2 id="三、H5的所有标签列表"><a href="#三、H5的所有标签列表" class="headerlink" title="三、H5的所有标签列表"></a>三、H5的所有标签列表</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5/HTML5_element_list" target="_blank" rel="external">MDN上的H5标签列表</a></p><hr><h2 id="四、空元素"><a href="#四、空元素" class="headerlink" title="四、空元素"></a>四、空元素</h2><p>一个不可能存在子节点的element</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/空元素" target="_blank" rel="external">MDN上的空元素</a></p><hr><h2 id="五、可替换元素"><a href="#五、可替换元素" class="headerlink" title="五、可替换元素"></a>五、可替换元素</h2><p>替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。<br>例如浏览器会根据<code>&lt;img&gt;</code>标签的<code>src</code>属性的值来读取图片信息并显示出来，而如果查看(X)HTML代码，则看不到图片的实际内容；又例如根据<code>&lt;input&gt;</code>标签的type属性来决定是显示输入框，还是单选按钮等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、W3C-简介&quot;&gt;&lt;a href=&quot;#一、W3C-简介&quot; class=&quot;headerlink&quot; title=&quot;一、W3C 简介&quot;&gt;&lt;/a&gt;一、W3C 简介&lt;/h2&gt;&lt;p&gt;万维网联盟（World Wide Web Consortium，W3C），又称W3C理事会，是万维网的主要国际标准组织。&lt;/p&gt;
&lt;p&gt;W3C由蒂姆·伯纳斯-李于1994年10月离开欧洲核子研究中心（CERN）后成立，在欧盟执委会和国防高等研究计划署（DARPA）的支持下成立于麻省理工学院MIT计算机科学与人工智能实验室（MIT／LCS）[2]，DARPA曾率先推出了互联网及其前身ARPANET。&lt;/p&gt;
&lt;p&gt;该组织试图通过W3C制定的新标准来促进业界成员间的兼容性和协议。不兼容的HTML版本由不同的供应商提供，导致网页显示方式不一致。联盟试图让所有的供应商实施一套由联盟选择的核心原则和组件。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="wangsiyuan233.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Algorithms&gt;-1.1基础编程模型</title>
    <link href="wangsiyuan233.github.io/2018/04/13/37Algorithms1-1/"/>
    <id>wangsiyuan233.github.io/2018/04/13/37Algorithms1-1/</id>
    <published>2018-04-13T10:12:14.205Z</published>
    <updated>2018-04-13T10:40:58.981Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="external">《算法 （第四版）》</a>梳理框架</p></blockquote><p>不建议阅读，反正你也读不下去<br><a id="more"></a></p><blockquote><p>1.1编程基础模型</p></blockquote><p>本书是基于Java编程语言来实现的算法，我们这么做的原因是：</p><ul><li>我们的程序时精确的、优雅的、且完整的描述了算法；</li><li>你运行程序时可以学习到准确的算法（知识）；</li><li>你可以让你的算法马上投入到应用中。<br>这些优点对于用英语来描述算法的工作来说，非常重要。<br>我们现在有一种趋势：那就是不得不使用特殊的编程语言，使得将算法从执行细节中剥离出来变得困难。我们利用现代语言和对算法的丰富的解释使得执行的难度降低。<br>我们只用了Java的一小部分子集，同时我们停止使用我们自定义的子集，你将几乎看不到Java的结构。我们提供的代码是完整的，我们希望你可以下载并运行它，用我们的或者你自己的测试数据都可以。<br>我们涉及到的编程的构建、软件库和操作系统常常是在我们的编程模型上执行的，在这一小节和1.2小节，我们将完整的介绍这个系统模型，我们配套齐全就是为了让你明白这个书里的任一代码。我们的模型提供了一种慢步调去介绍这些材料。<br>在参考书目中，我们完整的通过阐明程序模型的基本特征，来详尽的描绘了Java程序。当讨论语言特征时，我们通过这些代码进行举例。当涉及到P46那样的细节时，我们假设你是有现代变成的经验的，所以你是可以认出这些代码的许多特性的，页码注释将会帮助你解决一些问题。自从我们的代码有点程式化，我们致力于使用符合Java语句和结构的代码，这同样适用于经验丰富的Java码农阅读这些代码。（这不是废话吗）<br>【【【【图1.1.1】】】】<br><strong>1.1.1Java的基础结构</strong><br>Java的类既是静态的方法库，也是数据类型定义，为了创造这两者，我们用了一下5个部分，它们是以Java和其他编程语言为基础的：</li><li><em>原始数据类型</em> 精确的定义了整数、浮点数和布尔值这些计算机编程概念。它们的定义包括取值范围和能够对相应的值进行的操作，它们能被组合为类似数学公式的表达式。</li><li><em>语句</em> 通过创建变量和控制执行流来赋值，或者引发副作用来进行计算。我们会使用6种语句：声明、赋值、条件、循环、调用和返回。</li><li><em>数组</em> 同种类型的数值。</li><li><em>静态方法</em> 概括代码，使程序成为独立的模块</li><li><em>字符串</em> 是一系列characters，Java中的一些操作是基于它们的。</li><li><em>标准输入/输出</em> 是程序和外界的桥梁。</li><li><em>数据抽象</em> 让我们定义了非原始数据类型，支持面向对象编程。<br>在这一小节，我们依次介绍前五个，数据抽象是下一节的内容。<br>跑一个Java程序意味着和操作系统或编程环境的交互，为了清晰和简介，我们把这样的活动叫做 虚拟终端，虚拟终端就是我们键入命令行编程的地方，快试试那些好的程序吧！<br>例如，BinarySearch有两种静态方法<code>rank()</code>和<code>main()</code>,<code>rank()</code>有四种语句，两个声明，一个循环和一个返回；<code>main()</code>有三个语句，一个声明，一个调用和一个循环。<br>为了调用Java程序，我们首先要编译Java命令行，接着运行这些Java命令行。例如运行BinarySearch，我们首先要输入命令行 Javac BinarySearch.java，接着我们输入 java BinarySearch把控制权移交给这段字节码程序。为了理解这段程序，我们接下来考虑的是详细介绍Java的原始数据类型、数组、静态方法、字符串和标准IO。</li></ul><p><strong>1.1.2原始数据类型与表达式</strong><br>数据类型就是一组数据+对其的操作的集合。我们首先考虑下面4种基础的Java语言：</p><ul><li><em>整型</em> 及其运算符</li><li><em>浮点型</em> 及其运算符</li><li><em>布尔值</em> 的{true 和 false}及其逻辑运算</li><li><em>字符型</em> 它的值是你能输入的英文字母数字字符和符合<br>接下来我们看看怎么指定这些类型的值或者怎样对这些类型进行操作。<br>表达式：优先级很重要，运算里面乘除大于加减，逻辑里面 ! &gt; &amp;&amp; &gt; ||,圆括号可以改变优先级；<br>类型转换：int3.7就是3；double3是3.0；<br>比较：在条件和循环语句中非常重要；<br>其他原始类型：64字节long、16字节short、16字节char、8字节byte、32字节单精float；</li></ul><p><strong>1.1.3语句</strong><br>Java 的程序是由 声明、赋值来控制操作的执行流<br>声明：给变量命名标识符；<br>赋值：给变量一种数据类型，当然Java也有隐式赋值法<br>条件：根据条件不同，执行不同的语句<br>循环：在块里可以反复执行下去，除非你有一个“暂停键”；<br>返回：是一种改变执行方向的静态方法<br>一个程序是由一系列的语句组成的，当然程序也有嵌套结构，一个条件语句中也可以包含条件语句<br>1.1.3.1<br>声明语句：变量名+类型，声明要在变量使用之前出现，变量的作用域就是定义它的地方<br>1.1.3.2<br>赋值语句：变量+数据类型，等号左边单一变量，右边相应的表达式<br>1.1.3.3<br>条件语句：用不同的操作处理不同的输入，如果是true语句就会执行<br>1.1.3.4<br>循环语句：与if语句不同的是，while语句会不断的check布尔值是否为true，然后不停的执行<br>1.1.3.5<br>break 和 continue: while循环时使用；<br>break：是跳出当前的循环块或者程序块。<br>continues：停止运行剩余的循环主体，回到循环的开始处继续运行。</p><p><strong>1.1.4 简便记法 程序有很多写法</strong><br>1.1.4.1<br>声明并初始化<br>1.1.4.2<br>隐式赋值：i++<br>1.1.4.3<br>单语句代码段<br>1.1.4.4<br>for语句</p><p><strong>1.1.5 数组</strong><br>数组储存着一系列相同type的值，我们同样希望能取到这些值<br>1.1.5.1<br>创造并初始化一个数组<br>三个步骤：声明name和type;创建arry;初始化<br>name + datatype + length<br>1.1.5.2<br>简化写法<br>如果是从0开始，for loop 可以省略<br>1.1.5.3<br>使用数组<br>数组在创建时的大小时确定的<br>1.1.5.4<br>起外号<br>数组名表示的是整个数组，如果我们要把数组a赋予数组b，此时，a和b都会指向同一个数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正确赋值数组</span></div><div class="line"><span class="keyword">double</span>[]b = <span class="keyword">new</span> <span class="keyword">double</span>[N]</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, i &lt; N, i++)</div><div class="line">b[i] = a[i]</div></pre></td></tr></table></figure></p><p>1.1.5.5<br>二维数组<br>二维数组就是一维数组的数组。<br>我们规定：M为行，N为列<br>数组型初始化为0，布尔型初始化为false<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正确赋值数组</span></div><div class="line"><span class="keyword">double</span>[]a = <span class="keyword">new</span> <span class="keyword">double</span>[M][N];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, i &lt; N, i++)</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, j &lt; N, j++)</div><div class="line">a[i][j] = <span class="number">0.0</span>;</div></pre></td></tr></table></figure></p><p><strong>1.1.6 静态方法</strong><br>在别的语言中，总是把静态方法叫做函数，它们都是按照语句的顺序执行的<br>1.1.6.1<br>一个方法中需要参数，返回的数值也有参数决定<br>Java中每一个静态方法都是由 signature 和 body 组成的<br>1.1.6.2<br>调用静态方法<br>调用静态方法的方法，是写出方法名，并在后面的括号中列出参数值，用逗号分隔。<br>当调用是表达式的一部分时，方法的返回值将会，替代表达式中的方法调用。<br>1.1.6.3<br>方法的性质<br>-参数按值来传递 ：参数的值是由调用方提供的；改变参数的值对函数没有啥影响；值传递意味着数组参数是原数组的别名<br>-方法名可以被重载：一个函数需要参数，另一个函数可以提供参数<br>-方法只能有一个返回值，但可以包含多个语句<br>-方法可能产生副作用：void方法没有返回值，void函数有 side effct</p><p>1.1.6.4 递归<br>一个方法可以调用它自己，就是递归。<br>-递归有一个基本的方法就是第一行就是返回语句<br>-递归总是试图address更小的问题<br>-递归要解决的父类问题和它的子类之间不能有交集<br>遵循了以上三条法则，代码就会变得简洁高效</p><p>1.1.6.5 基础编程模型<br>一个静态方法库是由 public clss + name + 括号 组成的。<br>Java通过创造静态方法库去解决一些特殊的项目需求<br>Java + class name + 字符串 就能调用 mian()<br>字符串组成的数组作为参数执行到最后一句时，程序结束</p><p>1.1.6.6 模块化编程<br>最重要的是，静态方法库能使编程模块化<br>一个库中的静态方法可以调用另一个库中的静态方法<br>这样做的好处有：<br>-代码体积合理<br>-方便再次使用<br>-升级执行了也方便被取代<br>-缩小调试范围</p><p>1.1.6.7 单元测试<br>适当的单元测试对程序时重要的<br>简单来说，每个模块的main()方法都要保证代码运行正常<br>随着模块的成熟，我们精化main（）方法成为 开发用例 以告诉我们更多细节<br>或成为测试用例 以便更广阔的测试<br>用例太复杂时，我们就需要一个独立的模块</p><p>1.1.6.8 外部库<br>以下四种静态方法，来自不同的库，一些是由数据类型决定的。<br>-标准系统库 java.lang：Math常用于数学计算<br>-导入的系统库 java.util.Array: java中有很多类似的库<br>-其他库比如 rank()<br>-标准库 Std<br>如果要在一个方法中声明一个库，我们需要在方法前知道库的名字</p><p><strong>1.1.7 API</strong><br>模块化编程的一个重要组成部分就是记录方法的用法并提供文档给其他人参考<br>1.1.7.1 举例<br>这些方法将它们的参数 运用数学方法 转换为一个特殊的类型<br>这种拓展的性质恰巧是现代编程的特点之一<br>API的每一行都描述了一种方法，并且提供了使用该方法所需要使用的所有信息</p><p>1.1.7.2 Java库<br>网上有许多Java版本的库，我们节选了一小部分，足够说明问题了</p><p>1.1.7.3 标准库<br>我们开发了一些库用来实现一些实用的功能<br>这些库大多用与处理输入和输出<br>有些方法非常简单，为啥我们还要把它们写进一个库呢？<br>-让我们把重心放在测试和算法上，而不是随机数的计算上<br>-方法库需要大量的测试，其中就包含了极端和罕见的情况，如果我们自己手写就很麻烦<br>这些都是模块化编程的基石，当然有些夸大其词了<br>哈哈其实这些方法执行起来并不困难，它们中有些还代表了有趣的算法~</p><p>1.1.7.4 自己的库<br>有没有想过自己写一个库呢？以后想要调用的时候就随时调用哦<br>-编写用例，将计算分解为可控的部分<br>-明确方法库和与其对应的API<br>-实现API和一个能够对方法进行独立测试的mian()函数<br>。。。。结果很诱人。。。。这三条我看都看不懂<br>自己的库不仅方便调用，而且能让你更好的着手复杂的工作</p><p><strong>1.1.8 字符串</strong><br>字符串竟然不是Java的原始数据类型！<br>1.1.8.1 字符串拼接<br>字符串的拼接结果是：两个字符串变成一个 ———— “hi,” + “Bob” —&gt; “hi,Bob”<br>1.1.8.2 类型转换<br>字符串的两个主要用途：<br>1、用户输入的值转换为相应的数据类型<br>2、将数据类型转换为屏幕能显示的值<br>？？？？？？？？？？？？  这是啥 ？？？？？？<br>1.1.8.3 自动转换<br>我们几乎不使用 toString()方法，是因为Java提供了拼接的方法<br>使用 + 就可以把其他数据类型转换为 String 类型<br>或者 +’’ 拼接一个空字符串，也可以转换<br>1.1.8.4 命令行参数<br>Java中字符串的一个用处是接受命令行传递信息<br>当你输入 java + 库名 + 字符串<br>java会调用 main()方法，将【由字符串变成的数组】<br>作为参数，传递给main()函数</p><p><strong>1.1.9 输入和输出</strong><br>Java的输入、输出和绘图库是为了与外界交流<br>1、Java的输入值来源于命令行参数 或 标准输入流，输出值 在 标准输出流中<br>2、我们必然要思考Java和操作系统之间的连接<br>3、我们把应用程序提供的输入和显示的窗口叫 终端</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/10432347/&quot;&gt;《算法 （第四版）》&lt;/a&gt;梳理框架&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不建议阅读，反正你也读不下去&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="wangsiyuan233.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript--异步系列(2)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/36%E5%BC%82%E6%AD%A5%E7%B3%BB%E5%88%97-2/"/>
    <id>wangsiyuan233.github.io/2018/04/13/36异步系列-2/</id>
    <published>2018-04-13T10:12:14.205Z</published>
    <updated>2018-04-01T09:25:36.928Z</updated>
    
    <content type="html"><![CDATA[<p>这一小节主讲ajax，可以看我之前的<a href="http://wangsiyuan233.cn/2018/02/28/AJAX%EF%BC%88一%EF%BC%89/" target="_blank" rel="external">封装一个ajax</a><br><a id="more"></a><br>实在是不想写Promise。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一小节主讲ajax，可以看我之前的&lt;a href=&quot;http://wangsiyuan233.cn/2018/02/28/AJAX%EF%BC%88一%EF%BC%89/&quot;&gt;封装一个ajax&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="异步" scheme="wangsiyuan233.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript--闭包系列(4)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/31%E9%97%AD%E5%8C%85%E7%B3%BB%E5%88%97-4/"/>
    <id>wangsiyuan233.github.io/2018/04/13/31闭包系列-4/</id>
    <published>2018-04-13T10:12:14.158Z</published>
    <updated>2018-03-28T01:04:06.069Z</updated>
    
    <content type="html"><![CDATA[<p>终于讲到了正题，也是我们的最后一部分了！<br>大家打起精神耶耶耶！~<br>（图书馆关门之前我一定要整理完）</p><p>如果你看到这里还对闭包的知识有任何的疑问<br>请跟我默念这两种应用场景：<strong>函数作为返回值，函数作为参数传递</strong><br><a id="more"></a><br>1、<strong>【函数作为返回值】</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> ( x &gt; max) &#123;<span class="built_in">console</span>.log(x);&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f1 = fn;</div><div class="line">f1(<span class="number">15</span>); <span class="comment">// 15</span></div></pre></td></tr></table></figure></p><p>2、<strong>【函数作为参数传递】</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</div><div class="line">fn = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> ( x &gt; max) &#123;<span class="built_in">console</span>.log(x);&#125;</div><div class="line">&#125;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">f1</span>)</span>&#123;<span class="keyword">var</span> max = <span class="number">100</span>; f1(<span class="number">15</span>)&#125; )(fn); <span class="comment">// 15</span></div></pre></td></tr></table></figure></p><hr><p>在<a href="http://wangsiyuan233.cn/2018/03/26/闭包系列-1/" target="_blank" rel="external">闭包系列1</a>中我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。<br>但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是<strong>【闭包】</strong><br>（还是被赶出来了…）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> ( x &gt; max) &#123;<span class="built_in">console</span>.log(x);&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f2 = fn();</div><div class="line">max = <span class="number">100</span>;</div><div class="line">f2(<span class="number">15</span>);</div></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/ApNdBSw.png" alt=""><br>第一步：全局上下文环境时，max为undefined;<br>第二步：执行到第9行 <code>var f2 = fn()</code>，产生fn()执行上下文环境；<br>第三步：按理说第9行执行完了，fn()的执行上下文环境应该被销毁，【但是】，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max;<br>因此，这个max不能被销毁，销毁了之后f1函数中的max就找不到值了;<br>因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中;<br>因此，执行到第10行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第10行，全局上下文环境中的max被赋值为100。<br>第四步：第11行，执行f2(15)，即执行f1(15)，创建f1(15)上下文环境;<br>执行f1(15)时，max是自由变量，需要向创建f1函数的作用域中查找，找到了max的值为10;<br>这里的重点就在于，创建f1函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此f1(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。<br>使用闭包会消耗更多的内存哦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于讲到了正题，也是我们的最后一部分了！&lt;br&gt;大家打起精神耶耶耶！~&lt;br&gt;（图书馆关门之前我一定要整理完）&lt;/p&gt;
&lt;p&gt;如果你看到这里还对闭包的知识有任何的疑问&lt;br&gt;请跟我默念这两种应用场景：&lt;strong&gt;函数作为返回值，函数作为参数传递&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="闭包" scheme="wangsiyuan233.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>周结-计算机基础</title>
    <link href="wangsiyuan233.github.io/2018/04/13/2%E5%91%A8%E7%BB%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>wangsiyuan233.github.io/2018/04/13/2周结-计算机基础/</id>
    <published>2018-04-13T10:12:14.143Z</published>
    <updated>2018-03-27T07:15:36.634Z</updated>
    
    <content type="html"><![CDATA[<p>这周有了一些感悟，在技术部分之前想记录下来：</p><p>1.<strong>知识的诅咒：一个掌握了某项知识A的人，是无法想象不懂A的人是怎样想的。</strong>刚好完成了7个课时，神奇之处在于进度条到了此时此刻，我还没有真正入门HTML，也就是说，方方连尖角号是什么都没开始教。那么我学了些什么呢？疯狂装各种软件 –&gt;搭建博客 –&gt;HTTP协议 –&gt;命令行基础 –&gt;写脚本 –&gt;写服务器。好在我自学了一点点，要不然半条命都要进去吧。<br><a id="more"></a></p><p>2.<strong>入门的正确姿势。</strong>自己走了很多的弯路，不仅仅是编程，还有健身/日语，浪费的时间不一而足，自学的人总会扯各种不着边际的理由，其实是穷，我用自己摔的坑告诉大家：看视频学钢琴是不可能的。0基础是一定要找师傅带的，最后：找个好师傅和花钱买课一样的重要。</p><hr><p>废话不多说，下面开始技术梳理</p><p><strong>一切都是以server.js为目的展开的。</strong><br>（我打乱了方方的顺序）</p><ol><li>各种软件的安装，关注酷客+阮一峰，git+colourpix+atom+hexo+科学上网etc。(谷歌大法是真好</li><li>拦路虎：git+github+hexo,可以参考我上一篇博客<a href="http://wangsiyuan233.cn/GitHub-for-babies/" target="_blank" rel="external">《github for babies》</a>。</li><li>进制的转换 + 存储方式 = 小脚本（自动生成目录并填充内容）</li><li>HTTP基础 + 请求响应 = 极简服务器（发出请求返回内容）</li></ol><p>我对于写一个自己的服务器server.js没有那么强的愿景，发出了又能给此时此刻的我带来什么呢？方方演示的时候，左边是发出的命令行，右边是返回的命令行，呼哧呼哧的狂写，示意我们头部和尾部不用理会，只用知道中间的response.end就行了。作业是copy他的代码就行了</p><p>这七个课时过得很魔幻，自己和科班出身的想法差太远。</p><hr><p>因为学到的知识稀疏不已，写起总结就会捉襟见肘。<br>要不我把课后标答都传上来充充门面哈哈哈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周有了一些感悟，在技术部分之前想记录下来：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;知识的诅咒：一个掌握了某项知识A的人，是无法想象不懂A的人是怎样想的。&lt;/strong&gt;刚好完成了7个课时，神奇之处在于进度条到了此时此刻，我还没有真正入门HTML，也就是说，方方连尖角号是什么都没开始教。那么我学了些什么呢？疯狂装各种软件 –&amp;gt;搭建博客 –&amp;gt;HTTP协议 –&amp;gt;命令行基础 –&amp;gt;写脚本 –&amp;gt;写服务器。好在我自学了一点点，要不然半条命都要进去吧。&lt;br&gt;
    
    </summary>
    
    
      <category term="基础知识" scheme="wangsiyuan233.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>聊聊系列(1)--new函数</title>
    <link href="wangsiyuan233.github.io/2018/04/13/26%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-1/"/>
    <id>wangsiyuan233.github.io/2018/04/13/26聊聊系列-1/</id>
    <published>2018-04-13T10:12:14.111Z</published>
    <updated>2018-03-27T07:30:17.664Z</updated>
    
    <content type="html"><![CDATA[<p>原型链+继承告一段落，我们接下来开始闭包的部分。<br>当然不会直接开始闭包呀<br>今天想跟大家聊聊 new函数</p><p><a href="http://wangsiyuan233.cn/JS函数.html" target="_blank" rel="external">声明函数的五种方式</a><br>废话不多说 <strong>当我们在new一个函数的时候我们在干嘛？</strong></p><p>以【为程序员哥哥们批量制造女友】为例<br><a id="more"></a><br>1.1、创造理想型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> 女孩儿 = &#123;</div><div class="line">  <span class="attr">ID</span>: <span class="number">001</span>, <span class="comment">// 用于区分不同女孩儿</span></div><div class="line">  类型:<span class="string">"甜美可人"</span>,</div><div class="line">  撒娇:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*撒娇的代码*/</span>&#125;,</div><div class="line">  攻击:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*受死吧直男*/</span>   &#125;,</div><div class="line">  抛弃:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/**/</span>&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">梦工厂.制造(女孩儿)</div></pre></td></tr></table></figure></p><p>1.2、这样的女孩给我1000个<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> 女孩们 = [];</div><div class="line"><span class="keyword">var</span> 女孩儿</div><div class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, i&lt;<span class="number">1000</span>, i++)&#123;</div><div class="line"><span class="keyword">var</span> 女孩儿 = &#123;</div><div class="line">  <span class="attr">ID</span>: <span class="number">001</span>, <span class="comment">// 用于区分不同女孩儿</span></div><div class="line">  类型:<span class="string">"甜美可人"</span>,</div><div class="line">  撒娇:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*撒娇的代码*/</span>&#125;,</div><div class="line">  攻击:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*受死吧直男*/</span>   &#125;,</div><div class="line">  抛弃:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*展开新生活*/</span>&#125;</div><div class="line"> &#125;</div><div class="line"> 女孩们.push(女孩儿)</div><div class="line">&#125;</div><div class="line">梦工厂.制造(女孩儿)</div></pre></td></tr></table></figure></p><p>咦，为什么不能这样呢？<br>因为内存浪费了呀！<br>每个女孩的撒娇、攻击和抛弃都是一样的啊（划掉）<br>那我们可以把这些共同的属性写在同一个函数里，调用1000次就行了呀<br>ID和女孩儿的类型这些不同的地方再单独写出来循环<br>根据上一节<a href="http://wangsiyuan233.cn/原型闭包系列-4.html" target="_blank" rel="external">原型链</a>的知识<br>我们可以把 撒娇+攻击+抛弃 放入[女孩原型]中，然后让[女孩儿]通过 <code>__proto__</code>指向[女孩原型]<br>1.3、省空间<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> 女孩儿 = &#123;</div><div class="line">  <span class="attr">ID</span>: <span class="number">001</span>, <span class="comment">// 用于区分不同女孩儿</span></div><div class="line">  类型:<span class="string">"甜美可人"</span>,</div><div class="line">  撒娇:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*撒娇的代码*/</span>&#125;,</div><div class="line">  攻击:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*受死吧直男*/</span>   &#125;,</div><div class="line">  抛弃:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*展开新生活*/</span>&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> 女孩们 = [];</div><div class="line"><span class="keyword">var</span> 女孩儿</div><div class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, i&lt;<span class="number">1000</span>, i++)&#123;</div><div class="line">女孩儿 = &#123;</div><div class="line">ID：i;</div><div class="line">类型:<span class="string">"甜美可人"</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/*实际工作中不要这样写，因为 __proto__ 不是标准属性*/</span></div><div class="line">女孩儿.__proto__ = 女孩原型</div><div class="line">女孩们.push(女孩儿)</div><div class="line">&#125;</div><div class="line">梦工厂.制造(女孩儿)</div></pre></td></tr></table></figure></p><p>1.4、优化<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> 女孩儿（<span class="title">ID</span>）</span>&#123;</div><div class="line"><span class="keyword">var</span> 临时对象 = &#123;&#125;</div><div class="line">临时对象.__proto__ = 女孩儿.原型</div><div class="line">临时对象.ID = ID</div><div class="line">临时对象.类型 = <span class="string">"甜美可人"</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> 临时对象</div><div class="line">&#125;</div><div class="line">女孩儿.原型 = &#123;</div><div class="line">撒娇:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*撒娇的代码*/</span>&#125;,</div><div class="line">攻击:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*受死吧直男*/</span>   &#125;,</div><div class="line">抛弃:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*展开新生活*/</span>&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//保存为 我的女孩儿.js</span></div><div class="line"></div><div class="line"><span class="comment">//引用的时候</span></div><div class="line"><span class="keyword">var</span> 女孩们 = [];</div><div class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, i&lt;<span class="number">1000</span>, i++)&#123;</div><div class="line">女孩们.push(女孩儿(i))</div><div class="line">&#125;</div><div class="line">梦工厂.制造(女孩儿)</div></pre></td></tr></table></figure></p><p>2.1、JS之父给了我们new这个’密码’<br>只要你在女孩儿前面使用 new 关键字，那么可以少做四件事情：</p><p>不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；<br>不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；<br>不用 return 临时对象，因为 new 会帮你做；<br>不要给原型想名字了，因为 new 指定名字为 prototype。<br><img src="https://i.imgur.com/1BjUy3y.png" alt=""><br>2.2、用 new 重写一遍<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> 女孩儿（<span class="title">ID</span>）</span>&#123;</div><div class="line"><span class="keyword">this</span>.ID = ID</div><div class="line"><span class="keyword">this</span>.类型 = <span class="string">'甜蜜可人'</span></div><div class="line">&#125;</div><div class="line">女孩儿.prototype = &#123;</div><div class="line">撒娇:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*撒娇的代码*/</span>&#125;,</div><div class="line">攻击:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*受死吧直男*/</span>   &#125;,</div><div class="line">抛弃:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*展开新生活*/</span>&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//保存为 我的女孩儿.js</span></div><div class="line"></div><div class="line"><span class="comment">//引用的时候</span></div><div class="line"><span class="keyword">var</span> 女孩们 = [];</div><div class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, i&lt;<span class="number">1000</span>, i++)&#123;</div><div class="line">女孩们.push( <span class="keyword">new</span> 女孩儿(i)) <span class="comment">//新增了一个new</span></div><div class="line">&#125;</div><div class="line">梦工厂.制造(女孩儿)</div></pre></td></tr></table></figure></p><p>这就是所谓的 <strong>语法糖</strong><br>2.3、值得注意的是：new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「女孩儿.prototype」加了一个 constructor 属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">女孩儿.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: 女孩儿</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当然，constructor 是可以删除或修改的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">女孩儿.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: 女孩儿</div><div class="line">    撒娇:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*撒娇的代码*/</span>&#125;,</div><div class="line">攻击:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*受死吧直男*/</span>   &#125;,</div><div class="line">抛弃:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*展开新生活*/</span>&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原型链+继承告一段落，我们接下来开始闭包的部分。&lt;br&gt;当然不会直接开始闭包呀&lt;br&gt;今天想跟大家聊聊 new函数&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wangsiyuan233.cn/JS函数.html&quot;&gt;声明函数的五种方式&lt;/a&gt;&lt;br&gt;废话不多说 &lt;strong&gt;当我们在new一个函数的时候我们在干嘛？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以【为程序员哥哥们批量制造女友】为例&lt;br&gt;
    
    </summary>
    
    
      <category term="聊聊系列" scheme="wangsiyuan233.github.io/tags/%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>聊聊系列(2)--this</title>
    <link href="wangsiyuan233.github.io/2018/04/13/27%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-2/"/>
    <id>wangsiyuan233.github.io/2018/04/13/27聊聊系列-2/</id>
    <published>2018-04-13T10:12:14.111Z</published>
    <updated>2018-04-03T01:26:42.870Z</updated>
    
    <content type="html"><![CDATA[<p>先从 this 说起吧！<br>（这一天终于来了）</p><p>工作中我们总会面临：这个this指的是代码里的那一块呢?<br><a id="more"></a><br>结论：<strong>「this 就是 call 的第一个参数」</strong><br>1、ES5调用函数的三种方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一种</span></div><div class="line">func(p1, p2) 等价于</div><div class="line">func.call(<span class="literal">undefined</span>, p1, p2) <span class="comment">//this为window</span></div><div class="line"><span class="comment">//fn() 是 strict mode，this 就是 undefined (记牢！)</span></div><div class="line"></div><div class="line"><span class="comment">//第二种</span></div><div class="line">obj.child.method(p1, p2) 等价于</div><div class="line">obj.child.method.call(obj, p1, p2) <span class="comment">//this为obj</span></div><div class="line"></div><div class="line"><span class="comment">//第三种</span></div><div class="line">func.call(context, p1, p2)  <span class="comment">//this就为context</span></div></pre></td></tr></table></figure></p><p>2、ES6的箭头函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//箭头函数没有自己的this，它的this都指向外层</span></div><div class="line"><span class="comment">//箭头函数里面 this 跟外面的 this 的值一模一样</span></div><div class="line"></div><div class="line"><span class="comment">//箭头函数里面没有this，this外面的环境是window,全局又没有定义name属性，则为undefined</span></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"test"</span>,</div><div class="line">  <span class="attr">shout</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) <span class="comment">//undefined</span></div><div class="line">&#125;</div><div class="line">person.shout();</div><div class="line"></div><div class="line"><span class="comment">//箭头函数里面没有this，this外面的属性是person，person.name为test</span></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"test"</span>,</div><div class="line">  shout()&#123;</div><div class="line">    <span class="keyword">const</span> shout = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//test</span></div><div class="line">    <span class="keyword">return</span> shout;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">person.shout()();</div></pre></td></tr></table></figure></p><p>3、构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//普通函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = <span class="string">'wangsiyuan'</span>;</div><div class="line"><span class="keyword">this</span>.position = <span class="string">'全栈工程师'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//undefined会转换成window，最终是window</span></div><div class="line">&#125;</div><div class="line">Foo();  <span class="comment">//相当于Foo.call(undefined)</span></div><div class="line"></div><div class="line"><span class="comment">//new函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = <span class="string">'wangsiyuan'</span>;</div><div class="line"><span class="keyword">this</span>.position = <span class="string">'全栈工程师'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//Foo&#123;name:'wangsiyuan',position:'全栈工程师'&#125;</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</div><div class="line"><span class="built_in">console</span>.log(f1.name) <span class="comment">// wangsiyuan</span></div><div class="line"><span class="built_in">console</span>.log(f1.position) <span class="comment">// 全栈工程师</span></div></pre></td></tr></table></figure></p><p>4、构造函数的prototype中this代表什么<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = <span class="string">'wangsiyuan'</span>;</div><div class="line"><span class="keyword">this</span>.position = <span class="string">'全栈工程师'</span>;</div><div class="line">&#125;</div><div class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//Foo&#123;name:'wangsiyuan',position:'全栈工程师'&#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</div><div class="line">f1.getName(); <span class="comment">//wangsiyuan</span></div><div class="line"><span class="comment">//在Fn.prototype.getName函数中，this指向的是f1对象。因此可以通过this.name获取f1.name的值</span></div></pre></td></tr></table></figure></p><p>5、函数作为对象的一个属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = obj.foo</div><div class="line">obj.foo() <span class="comment">// 转换为 obj.foo.call(obj)，this 就是 obj</span></div><div class="line">bar()  <span class="comment">// 转换为 bar.call(undefined),this 就是 undefined</span></div></pre></td></tr></table></figure></p><p>6、数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;</div><div class="line"><span class="keyword">var</span> arr = [fn, fn2]</div><div class="line">arr[<span class="number">0</span>]() <span class="comment">// 这里面的 this 又是什么呢？</span></div><div class="line"></div><div class="line"><span class="comment">//转换思路</span></div><div class="line"><span class="comment">//arr[0]() </span></div><div class="line"><span class="comment">//假想为    arr.0()</span></div><div class="line"><span class="comment">//然后转换为 arr.0.call(arr)</span></div><div class="line"><span class="comment">//那么里面的 this 就是 arr 了嘻嘻</span></div></pre></td></tr></table></figure></p><p>7、Event Handler 中的 this<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">btn.addEventListener(<span class="string">'click'</span> ,<span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 请问这里的 this 是什么</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//查文档后发现</span></div><div class="line"><span class="comment">// 当事件被触发时</span></div><div class="line">handler.call(event.currentTarget, event) </div><div class="line"><span class="comment">// 那么 this 是什么不言而喻</span></div></pre></td></tr></table></figure></p><p>8、jQuery Event Handler 中的 this<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ul.on(<span class="string">'click'</span>, <span class="string">'li'</span> , <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)  <span class="comment">// 请问这里的 this 是什么</span></div><div class="line">&#125;) </div><div class="line"><span class="comment">//查文档后发现</span></div><div class="line"><span class="comment">//对于代理事件而言，this 则代表了与 selector 相匹配的元素。</span></div><div class="line"><span class="comment">//(注意，如果事件是从后代元素冒泡上来的话，那么 this 就有可能不等于 event.target。)若要使用 jQuery 的相关方法，可以根据当前元素创建一个 jQuery 对象，即使用 $(this)。</span></div></pre></td></tr></table></figure></p><p>9、如何强制指定 this 的值<br>自己写apply/bind/call就行了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用call或apply</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlerWrapper</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 请问这里的 this 是什么</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  handler.call(&#123;<span class="attr">name</span>:<span class="string">'wangsiyuan'</span>&#125;, event)</div><div class="line">&#125;</div><div class="line">btn.addEventListener(<span class="string">'click'</span>, handlerWrapper)</div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用bind也差不了多少</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 请问这里的 this 是什么</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> handlerWrapper = handler.bind(&#123;<span class="attr">name</span>:<span class="string">'wangsiyuan'</span>&#125;)</div><div class="line">btn.addEventListener(<span class="string">'click'</span>, handlerWrapper)</div><div class="line"></div><div class="line"><span class="comment">//变身面试套路题</span></div><div class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 请问这里的 this 是什么</span></div><div class="line">&#125;.bind(&#123;<span class="attr">name</span>:<span class="string">'wangsiyuan'</span>&#125;))</div></pre></td></tr></table></figure><p>10、立即执行函数<br>每个函数只有一个this<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line"><span class="attr">foo</span>: <span class="string">"bar"</span>;</div><div class="line">func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">//这里的this并不是下面立即执行函数的this，它是中函数的this</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"outer func: this.foo ="</span> + <span class="keyword">this</span>.foo) <span class="comment">// bar</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"outer func: self.foo ="</span> + self.foo) <span class="comment">// bar</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"inner func: this.foo ="</span> + <span class="keyword">this</span>.foo) <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"inner func: self.foo ="</span> + self.foo) <span class="comment">// bar</span></div><div class="line">&#125;());</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">myObject.func();</div></pre></td></tr></table></figure></p><p>结论：<strong>「this 就是 call 的第一个参数」</strong><br>记住了吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先从 this 说起吧！&lt;br&gt;（这一天终于来了）&lt;/p&gt;
&lt;p&gt;工作中我们总会面临：这个this指的是代码里的那一块呢?&lt;br&gt;
    
    </summary>
    
    
      <category term="聊聊系列" scheme="wangsiyuan233.github.io/tags/%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript--原型系列(4)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/25%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-4/"/>
    <id>wangsiyuan233.github.io/2018/04/13/25原型系列-4/</id>
    <published>2018-04-13T10:12:14.096Z</published>
    <updated>2018-03-27T07:33:57.959Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈被骗啦(…)还没轮到原型链<br>这一小节我们将引出一个中介概念 <code>instanceof</code><br><a id="more"></a></p><p>对于值类型，我们可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function，我们不知道它到底是一个object对象，还是数组，还是new Number等等。这个时候就需要用到instanceof。</p><p>instanceof有一个判断准则是：沿着对象的<code>__proto__</code> 和 函数的<code>prototype</code>的两端同时寻找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。<br><img src="https://i.imgur.com/r7M68Fc.png" alt=""><br>由上面这张图可以得出以下不着调的结论：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span> Foo()&#123;&#125;</div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</div><div class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Foo); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p><p>所以这些乱七八糟的关系图是为什么呢？？？<br>原来，instanceof表示的就是一种继承关系，或者原型链的结构。</p><hr><p>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<code>__proto__</code>这条链向上找，这就是原型链。</p><p>那么我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？大家可能都知道答案了——hasOwnProperty，特别是在for…in…循环中，一定要注意。</p><p>由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法（hasOwnProperty）。这就是所谓的“继承”。</p><hr><p>沿着<code>__proto__</code>向上找就是<strong>原型链</strong>；<br>最后把Object.prototype里的hasOwnProperty（或者Function.prototype里的call）拿来直接用，就是<strong>继承</strong>。</p><p>这意味着，创建的对象可以增加属性，继承的方法不合适也可以修改。</p><p>可以看看我以前总结的 <a href="wangsiyuan233.cn/2018/03/08/原型链实例/">原型链实例</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈哈被骗啦(…)还没轮到原型链&lt;br&gt;这一小节我们将引出一个中介概念 &lt;code&gt;instanceof&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="原型链" scheme="wangsiyuan233.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript--原型系列(2)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/23%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-2/"/>
    <id>wangsiyuan233.github.io/2018/04/13/23原型系列-2/</id>
    <published>2018-04-13T10:12:14.080Z</published>
    <updated>2018-03-27T08:21:03.543Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://wangsiyuan233.cn/2018/03/25/原型系列-1/" target="_blank" rel="external">接上节</a><br>数组、函数和对象这三者的关系非常有趣<br>数组可以看做是对象的一个子集；<br>但是函数和对象却类似于鸡和蛋的关系。<br>一起来看看吧~<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//粗一看对象好像不需要函数来创建呀</span></div><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="string">'x'</span>, <span class="literal">true</span>];</div><div class="line"></div><div class="line"><span class="comment">//其实这才是上面两个的对象的真面目</span></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">obj.a = <span class="number">10</span>;</div><div class="line">obj.b = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">arr[<span class="number">0</span>] = <span class="number">5</span>;</div><div class="line">arr[<span class="number">1</span>] = <span class="string">'x'</span>;</div><div class="line">arr[<span class="number">2</span>] = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">//Object和Array也都是function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="built_in">Object</span>));  <span class="comment">// function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="built_in">Array</span>));  <span class="comment">// function</span></div></pre></td></tr></table></figure></p><h2 id="结论：对象都是通过函数创建的"><a href="#结论：对象都是通过函数创建的" class="headerlink" title="结论：对象都是通过函数创建的"></a>结论：<strong>对象都是通过函数创建的</strong></h2><p>在上一节我们说了：一切（引用类型）都是对象；<br>现在的结论是：对象都是通过函数创建的；<br>有没有被绕晕呢？</p><hr><p>以前我们说过，函数创建了对象，（函数是属性的集合），我们可以给函数定制属于自己的属性，那么函数有哪些属性呢？说到这儿，不得不提我们大名鼎鼎的 prototype 啦！<br>每个函数都有一个属性叫做prototype；<br>prototype的属性值是一个对象（属性的集合）；<br>prototype默认的仅有的属性叫constructor，指向这个函数本身。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义Fn的属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123; &#125;</div><div class="line">Fn.prototype.name = <span class="string">'wangsiyuan'</span>;</div><div class="line">Fn.prototype.getPosition = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> 全栈工程师;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123; &#125;</div><div class="line">Fn.prototype.name = <span class="string">'wangsiyuan'</span>;</div><div class="line">Fn.prototype.getPosition = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> 全栈工程师;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn();</div><div class="line"><span class="built_in">console</span>.log(fn.name);</div><div class="line"><span class="built_in">console</span>.log(fn.getPosition());</div></pre></td></tr></table></figure><p>fn对象是通过Fn函数new出来的;<br>即 ———&gt;&gt;&gt; 对象都是通过函数创建出来的;<br>即 ———&gt;&gt;&gt; fn对象可以调用Fn.prototype中的属性；<br>因为 ———&gt;&gt;&gt; 每个对象都有一个“隐式原型”<code>__proto__</code>，它指向创建该对象的函数的prototype；<br>即 ———&gt;&gt;&gt; <code>fn.__proto__ === Fn.prototype.</code><br>其实prototype的推导过程并没有那么可怕嘛！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://wangsiyuan233.cn/2018/03/25/原型系列-1/&quot;&gt;接上节&lt;/a&gt;&lt;br&gt;数组、函数和对象这三者的关系非常有趣&lt;br&gt;数组可以看做是对象的一个子集；&lt;br&gt;但是函数和对象却类似于鸡和蛋的关系。&lt;br&gt;一起来看看吧~&lt;br&gt;
    
    </summary>
    
    
      <category term="原型链" scheme="wangsiyuan233.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript--原型系列(3)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/24%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-3/"/>
    <id>wangsiyuan233.github.io/2018/04/13/24原型系列-3/</id>
    <published>2018-04-13T10:12:14.080Z</published>
    <updated>2018-03-27T07:33:49.641Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/7BYXesw.png" alt=""><br>由上面这张图可以一层层得出以下的结论1：<br><a id="more"></a><br>1.<code>f1.__proto__ === Foo.prototype</code><br>2.<code>Foo.prototype.__proto__ === Object.prototype</code><br>3.<code>Object.prototype.__proto__ === null</code>（牢记）<br>有了以上的知识储备，我有一个大胆的想法：函数也是对象，那函数有<code>__proto__</code>吗？它的值有等于什么呢？<br>答案是肯定的，函数这个对象(…)是被FFFFFFunction函数创建的。<br>即 ———&gt;&gt;&gt; <code>Object.__proto__ === Function.prototype</code><br><img src="https://i.imgur.com/vAwUmea.png" alt=""><br>由上面这张图可以一层层得出以下的结论2：<br>1.自定义函数<code>Foo.__proto__ === Function.prototype</code><br>2.<code>Object.__proto__ === Function.prototype</code><br>3.<code>Function.__proto__ === Function.prototype</code>(…)<br>竟然形成了一个环！！<br><img src="https://i.imgur.com/E0G47Yo.png" alt=""><br>由上面这张图可以得出以下的结论3：<br><code>Function.prototype.__proto__ === Object.prototype</code><br>（这个式子在结论1里出现过了哦，一样的形式呢）</p><hr><p>是不是有点乱呢？<br>梳理一遍吧~<br>-&gt;&gt;首先我们利用值类型和引用类型，得出了一个结论：一切引用类型都是对象；<br>-&gt;&gt;第二步知道了对象都是由创建他的函数构建的；<br>此时我们有点发晕了，函数和对象傻傻捋不清楚；<br>-&gt;&gt;第三步引入了prototype这个属性，我们知道了一个[对象]的隐性属性指向(创建这个对象的)函数的显性属性；<br>接着我们发现：一个[函数]的隐性属性指向(创建这个函数的)FFFFFFunction函数的显性属性（<code>Foo.__proto__ === Function.prototype</code>）<br>-&gt;&gt;最后，由于Function.prototype指向的对象也是一个普通的被Object创建的对象，我们得到<code>Function.prototype.__proto__ === Object.prototype</code></p><hr><p>对的哦，最后形成了一个环！嘿嘿嘿，老司机肯定知道我接下来要介绍的重要概念————原型链 啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/7BYXesw.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;由上面这张图可以一层层得出以下的结论1：&lt;br&gt;
    
    </summary>
    
    
      <category term="原型链" scheme="wangsiyuan233.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript--原型系列(1)</title>
    <link href="wangsiyuan233.github.io/2018/04/13/22%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-1/"/>
    <id>wangsiyuan233.github.io/2018/04/13/22原型系列-1/</id>
    <published>2018-04-13T10:12:14.065Z</published>
    <updated>2018-03-27T07:33:24.606Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面：对学习前端70天的一个总结，说是“深入”其实有点不好意思，有什么问题一起探讨呀</p></blockquote><p>JavaScript中有一句“一切皆是对象”，这句话当然是不严谨的啦，让我们一起来看看怎么回事吧！<br><a id="more"></a><br><strong>一、判断对象</strong><br>从最开始学习JS，我们就学会了判断值类型和引用类型：<br>值类型：number、string、null、undefined、boolean<br>引用类型：函数、数组、对象这些都是对象<br>（值得注意的是，当我们用typeof判断null时，浏览器会返回object，这是因为在js中，底层是用二进制编码的，如果前三位是000的话,用typeof就会返回object,而null的编码是全部都是0，当然会被返回object ,这是js的一个bug而已。）</p><blockquote><p>1.1值类型：变量的交换等于在一个新的地方按照连锁店的规范标准（统一店面理解为相同的变量内容）新开一个分店，这样新开的店与其它旧店互不相关、各自运营。<br>1.2引用类型：变量的交换等同于把现有一间店的钥匙（变量引用地址）复制一把给了另外一个老板，此时两个老板同时管理一间店，两个老板的行为都有可能对一间店的运营造成影响。<br>2.1值类型的值是一经确定就不可变的；基本类型的比较是值的比较；基本类型的变量存放在栈。<br>2.2引用类型的值是可变的；引用类型的比较是引用的比较；引用类型的值是同时保存在栈和堆中的对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//值类型的比较</span></div><div class="line"><span class="keyword">var</span> person1 = <span class="string">'&#123;&#125;'</span>;</div><div class="line"><span class="keyword">var</span> person2 = <span class="string">'&#123;&#125;'</span>;</div><div class="line"><span class="built_in">console</span>.log(person1 == person2); <span class="comment">// true</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//引用类型的比较</span></div><div class="line"><span class="keyword">var</span> person1 = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> person2 = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(person1 == person2); <span class="comment">// false</span></div></pre></td></tr></table></figure><p><strong>二、定义对象</strong><br>粗粗的将这些变量划分为非对象和对象，我们不难发现，（和JAVA与C#对比），JS中的“对象”非常的随意：<br>函数是对象，数组是对象，对象也是对象；<br>对象里只有属性，没有方法（方法也是一种属性，以键值对的形式出现）；<br>对象可以扩展任意属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//举例说明 对象中自定义属性</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line"><span class="attr">a</span> : <span class="number">10</span>,</div><div class="line"><span class="attr">b</span> : <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;alert (x+<span class="keyword">this</span>.a);&#125;,</div><div class="line"><span class="attr">c</span> : &#123;<span class="attr">name</span>: <span class="string">'wangsiyuan'</span>，position: <span class="string">'全栈工程师'</span>&#125;</div><div class="line">&#125;；</div><div class="line"><span class="comment">//a、b、c都是obj的属性，同时c还是一个对象，它有着name和position两个属性</span></div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//举例说明 函数中自定义属性</span></div><div class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="number">100</span>);</div><div class="line">&#125;;</div><div class="line">fn.a = <span class="number">10</span>;</div><div class="line">fn.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="number">123</span>);</div><div class="line">&#125;;</div><div class="line">fn.c = &#123;</div><div class="line"><span class="attr">name</span>: <span class="string">'wangsiyuan'</span>，</div><div class="line">position: <span class="string">'全栈工程师'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//$变量也是一个函数（JQ）</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> $) <span class="comment">//function</span></div></pre></td></tr></table></figure><p>至此，我们可以回答开头的问题了：<br><strong>一切（引用类型）都是对象，对象是属性的集合。</strong></p><hr><p>我们在第一小节里确定了[对象]的范围，请问：函数、数组和对象，这三者的关系是怎样的呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写在前面：对学习前端70天的一个总结，说是“深入”其实有点不好意思，有什么问题一起探讨呀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JavaScript中有一句“一切皆是对象”，这句话当然是不严谨的啦，让我们一起来看看怎么回事吧！&lt;br&gt;
    
    </summary>
    
    
      <category term="原型链" scheme="wangsiyuan233.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>HTML知识梳理</title>
    <link href="wangsiyuan233.github.io/2018/04/13/21HTML%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <id>wangsiyuan233.github.io/2018/04/13/21HTML知识梳理/</id>
    <published>2018-04-13T10:12:14.049Z</published>
    <updated>2018-03-27T07:14:49.146Z</updated>
    
    <content type="html"><![CDATA[<p>一、☆☆☆如何理解 HTML 语义化。<br>语义化，指对文本内容的结构化（内容语义化），选择合乎语义的标签（代码语义化），便于开发者阅读，维护和写出更优雅的代码的同时，让浏览器的爬虫和辅助技术更好的解析。<br><a id="more"></a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//错误示范</div><div class="line">1、blockquote：一些人通过使用<span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>标签使文本达到缩进的目的，因为引用默认会进行文本缩进。如果你仅仅是想使文本达到缩进目的，而文本自身并非引用，那么就用CSS margin来代替；</div><div class="line">2、p：一些开发者用<span class="tag">&lt;<span class="name">p</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>来为标签自检增加额外的空白段落，这里应该使用CSS margin/padding来实现；</div><div class="line">3、ul：一些开发者往<span class="tag">&lt;<span class="name">ul</span>&gt;</span>中添加文本来达到文本缩进的目的，这种做法即不符合语义化要求，同样也是非法的HTML实践。<span class="tag">&lt;<span class="name">ul</span>&gt;</span>标签中只能有<span class="tag">&lt;<span class="name">li</span>&gt;</span>标签；</div><div class="line">4、<span class="tag">&lt;<span class="name">h1</span>&gt;</span>~<span class="tag">&lt;<span class="name">h6</span>&gt;</span>：该标签可以使文本字体变大，变粗，但如果文本并非是标题，应该使用CSS font-weight font-size。</div><div class="line"></div><div class="line">//注意下面这些标签，不要变成<span class="tag">&lt;<span class="name">div</span>&gt;</span>狂魔了哦</div><div class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>、<span class="tag">&lt;<span class="name">nav</span>&gt;</span>、<span class="tag">&lt;<span class="name">main</span>&gt;</span>、<span class="tag">&lt;<span class="name">aside</span>&gt;</span>、<span class="tag">&lt;<span class="name">article</span>&gt;</span>、<span class="tag">&lt;<span class="name">section</span>&gt;</span></div></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//最开始是 PHP 后端写 HTML，不会 CSS，于是就用 table 来布局。table 使用展示表格的。严重违反了 HTML 语义化。</div><div class="line"> 后来有了专门的写 CSS 的前端，他们会使用 DIV + CSS 布局，主要是用 float 和绝对定位布局。稍微符合了 HTML 语义化。</div><div class="line"> 再后来，前端专业化，知道 HTML 的各个标签的用法，于是会使用恰当的标签来展示内容，而不是傻傻的全用 div，会尽量使用 h1、ul、p、main、header 等标签</div><div class="line"> 语义化的好处是已读、有利于SEO等。</div></pre></td></tr></table></figure><p>二、meta viewport 是什么，有什么用？<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></div><div class="line">//控制页面在移动端不要缩小显示。</div><div class="line">//一开始，所有页面都是给PC准备的，乔布斯推出 iPhone 3GS，页面是不适应手机屏幕的，所以乔布斯的工程师想了一个办法，默认把手机模拟成 980px，页面缩小。</div><div class="line">后来，智能手机普及，这个功能在部分网站不需要了，所以我们就用 meta:vp 让手机不要缩小我的网页。</div></pre></td></tr></table></figure></p><p>三、canvas 元素是什么<br><code>&lt;canvas&gt;</code> 是 HTML5 新增的元素，可用于通过使用JavaScript中的脚本来绘制图形。例如，它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或渲染。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</div><div class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line"></div><div class="line">ctx.fillStyle = <span class="string">'green'</span>;</div><div class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line"><span class="comment">//顶点在（10,10）边长为100的绿色正方形</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、☆☆☆如何理解 HTML 语义化。&lt;br&gt;语义化，指对文本内容的结构化（内容语义化），选择合乎语义的标签（代码语义化），便于开发者阅读，维护和写出更优雅的代码的同时，让浏览器的爬虫和辅助技术更好的解析。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="wangsiyuan233.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>初识Node.js</title>
    <link href="wangsiyuan233.github.io/2018/04/13/20%E5%88%9D%E8%AF%86Node-js/"/>
    <id>wangsiyuan233.github.io/2018/04/13/20初识Node-js/</id>
    <published>2018-04-13T10:12:14.033Z</published>
    <updated>2018-03-27T07:17:55.696Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Node.js 久仰久仰<br>自己动手搭建一个服务器 server.js</p></blockquote><h2 id="一、server-js-1-0"><a href="#一、server-js-1-0" class="headerlink" title="一、server.js 1.0"></a>一、server.js 1.0</h2><p>根据我的指示在逐步输入：<br>1、桌面打开gitbash，输入 <code>mkdir server</code>,创建一个名为 server 的文件夹<br>2、gitbash输入: <code>cd server</code> ，进入文件夹<br>3、gitbash输入：<code>touch server.js</code> ，新建一个 <code>server.js</code><br>4.1 去我的github找到<a href="https://github.com/wangsiyuan233/jirengu--fangfang/blob/master/server.js" target="_blank" rel="external">源码</a>链接，在gitbash输入：<code>curl http://... &gt;server.js</code> （注意源码是否一致）<br>4.2 直接复制下面的代码到 <code>server.js</code><br>5、gitbash输入：<code>node server.js 8080</code> , 返回语句为：恭喜你小源！监听8080成功 请用在空中转体720度然后用电饭煲打开 <code>http://localhost:8080</code><br>6、【保持第一个gitbash不关闭的情况下在第二个gitbash并输入】：<br>6.1 <code>curl &quot;http://localhost:8080&quot;</code>时返回：  //打字太麻烦了自己打开试试就知道了<br>6.2 <code>curl &quot;http://localhost:8080/xxx&quot;</code>时返回：  //打字太麻烦了自己打开试试就知道了<br>6.3 <code>curl &quot;http://localhost:8080?name=yuan&quot;</code>时返回：   //打字太麻烦了自己打开试试就知道了<br>7、总结：当我们发送一个请求的时候，服务器是会返回给我们想要的东西<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</div><div class="line"><span class="keyword">var</span> port = process.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="keyword">if</span>(!port)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'请指定端口号好不啦？--&gt; \nnode server.js 8888 '</span>)</div><div class="line">  process.exit(<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> parsedUrl = url.parse(request.url, <span class="literal">true</span>)</div><div class="line">  <span class="keyword">var</span> path = request.url</div><div class="line">  <span class="keyword">var</span> query = <span class="string">''</span></div><div class="line">  <span class="keyword">if</span>(path.indexOf(<span class="string">'?'</span>) &gt;= <span class="number">0</span>)&#123; query = path.substring(path.indexOf(<span class="string">'?'</span>)) &#125;</div><div class="line">  <span class="keyword">var</span> pathNoQuery = parsedUrl.pathname</div><div class="line">  <span class="keyword">var</span> queryObject = parsedUrl.query</div><div class="line">  <span class="keyword">var</span> method = request.method</div><div class="line"></div><div class="line">  <span class="comment">/******** 从这里开始看，上面不要看 ************/</span></div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'小源说：得到 HTTP 路径\n'</span> + path) </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'小源说：查询字符串为\n'</span> + query)</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'小源说：不含查询字符串的路径为\n'</span> + pathNoQuery)</div><div class="line">  <span class="comment">//均出现在bash上</span></div><div class="line"></div><div class="line">  <span class="comment">/******** 代码结束，下面不要看 ************/</span></div><div class="line">&#125;) <span class="comment">// var server = 的反括号  不要删！！</span></div><div class="line"></div><div class="line">server.listen(port)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'恭喜你小源！监听 '</span> + port + <span class="string">' 成功\n请用在空中转体720度然后用电饭煲打开 http://localhost:'</span> + port)</div></pre></td></tr></table></figure></p><h2 id="二、server-js-1-1"><a href="#二、server-js-1-1" class="headerlink" title="二、server.js 1.1"></a>二、server.js 1.1</h2><p>1、发送不同的请求，通过代码来筛选符合条件的内容，否则就404你。<br>2、response.setHeader(‘Content-Type’,’text/html;charset=utf-8’) 需要理解+熟记<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</div><div class="line"><span class="keyword">var</span> port = process.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="keyword">if</span>(!port)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'请指定端口号好不啦？--&gt; \nnode server.js 8888 '</span>)</div><div class="line">  process.exit(<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> parsedUrl = url.parse(request.url, <span class="literal">true</span>)</div><div class="line">  <span class="keyword">var</span> path = request.url</div><div class="line">  <span class="keyword">var</span> query = <span class="string">''</span></div><div class="line">  <span class="keyword">if</span>(path.indexOf(<span class="string">'?'</span>) &gt;= <span class="number">0</span>)&#123; query = path.substring(path.indexOf(<span class="string">'?'</span>)) &#125;</div><div class="line">  <span class="keyword">var</span> pathNoQuery = parsedUrl.pathname</div><div class="line">  <span class="keyword">var</span> queryObject = parsedUrl.query</div><div class="line">  <span class="keyword">var</span> method = request.method</div><div class="line"></div><div class="line">  <span class="comment">/******** 从这里开始看，上面不要看 ************/</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>(path == <span class="string">'/'</span>)&#123;  <span class="comment">//只是路径，和文件的格式对应的没有关系</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'小源说：得到 HTTP 路径\n'</span> + path) <span class="comment">//出现在bash上</span></div><div class="line">    response.end()</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (path == <span class="string">'/index'</span>)&#123;</div><div class="line">    response.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html;charset=utf-8'</span>)</div><div class="line">    response.write(<span class="string">'我pang回来了小源！'</span>) <span class="comment">//出现在浏览器上</span></div><div class="line">    response.end()</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    response.statusCode == <span class="number">404</span></div><div class="line">    response.end()</div><div class="line">&#125;</div><div class="line"></div><div class="line">  <span class="comment">/******** 代码结束，下面不要看 ************/</span></div><div class="line">&#125;) <span class="comment">// var server = 的反括号  不要删！！</span></div><div class="line"></div><div class="line">server.listen(port)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'恭喜你小源！监听 '</span> + port + <span class="string">' 成功\n请用在空中转体720度然后用电饭煲打开 http://localhost:'</span> + port)</div></pre></td></tr></table></figure></p><h2 id="三、server-js-1-2"><a href="#三、server-js-1-2" class="headerlink" title="三、server.js 1.2"></a>三、server.js 1.2</h2><p>write里的内容由setHeader里的Content-Type决定，和路径是什么无关<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</div><div class="line"><span class="keyword">var</span> port = process.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="keyword">if</span>(!port)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'请指定端口号好不啦？--&gt; \nnode server.js 8888 '</span>)</div><div class="line">  process.exit(<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> parsedUrl = url.parse(request.url, <span class="literal">true</span>)</div><div class="line">  <span class="keyword">var</span> path = request.url</div><div class="line">  <span class="keyword">var</span> query = <span class="string">''</span></div><div class="line">  <span class="keyword">if</span>(path.indexOf(<span class="string">'?'</span>) &gt;= <span class="number">0</span>)&#123; query = path.substring(path.indexOf(<span class="string">'?'</span>)) &#125;</div><div class="line">  <span class="keyword">var</span> pathNoQuery = parsedUrl.pathname</div><div class="line">  <span class="keyword">var</span> queryObject = parsedUrl.query</div><div class="line">  <span class="keyword">var</span> method = request.method</div><div class="line"></div><div class="line">  <span class="comment">/******** 从这里开始看，上面不要看 ************/</span></div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'HTTP 路径为\n'</span> + path)</div><div class="line">  <span class="keyword">if</span>(path == <span class="string">'/style.js'</span>)&#123; <span class="comment">//只是路径，和文件的格式对应的没有关系</span></div><div class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/css; charset=utf-8'</span>)</div><div class="line">    response.write(<span class="string">'body&#123;background-color: #ddd;&#125;h1&#123;color: red;&#125;'</span>)</div><div class="line">    response.end()</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(path == <span class="string">'/script.html'</span>)&#123;</div><div class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/javascript; charset=utf-8'</span>)</div><div class="line">    response.write(<span class="string">'alert("这是JS执行的")'</span>)</div><div class="line">    response.end()</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(path == <span class="string">'/index.css'</span>)&#123;</div><div class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html; charset=utf-8'</span>)</div><div class="line">    response.write(<span class="string">'&lt;!DOCTYPE&gt;\n&lt;html&gt;'</span>  + </div><div class="line">      <span class="string">'&lt;head&gt;&lt;link rel="stylesheet" href="/style.js"&gt;'</span> +</div><div class="line">      <span class="string">'&lt;/head&gt;&lt;body&gt;'</span>  +</div><div class="line">      <span class="string">'&lt;h1&gt;你好&lt;/h1&gt;'</span> +</div><div class="line">      <span class="string">'&lt;script src="/script.html"&gt;&lt;/script&gt;'</span> +</div><div class="line">      <span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>)</div><div class="line">    response.end()</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    response.statusCode = <span class="number">404</span></div><div class="line">    response.end()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/******** 代码结束，下面不要看 ************/</span></div><div class="line">&#125;) <span class="comment">// var server = 的反括号  不要删！！</span></div><div class="line"></div><div class="line">server.listen(port)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'恭喜你小源！监听 '</span> + port + <span class="string">' 成功\n请用在空中转体720度然后用电饭煲打开 http://localhost:'</span> + port)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Node.js 久仰久仰&lt;br&gt;自己动手搭建一个服务器 server.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、server-js-1-0&quot;&gt;&lt;a href=&quot;#一、server-js-1-0&quot; class=&quot;headerlink&quot; title=&quot;一、server.js 1.0&quot;&gt;&lt;/a&gt;一、server.js 1.0&lt;/h2&gt;&lt;p&gt;根据我的指示在逐步输入：&lt;br&gt;1、桌面打开gitbash，输入 &lt;code&gt;mkdir server&lt;/code&gt;,创建一个名为 server 的文件夹&lt;br&gt;2、gitbash输入: &lt;code&gt;cd server&lt;/code&gt; ，进入文件夹&lt;br&gt;3、gitbash输入：&lt;code&gt;touch server.js&lt;/code&gt; ，新建一个 &lt;code&gt;server.js&lt;/code&gt;&lt;br&gt;4.1 去我的github找到&lt;a href=&quot;https://github.com/wangsiyuan233/jirengu--fangfang/blob/master/server.js&quot;&gt;源码&lt;/a&gt;链接，在gitbash输入：&lt;code&gt;curl http://... &amp;gt;server.js&lt;/code&gt; （注意源码是否一致）&lt;br&gt;4.2 直接复制下面的代码到 &lt;code&gt;server.js&lt;/code&gt;&lt;br&gt;5、gitbash输入：&lt;code&gt;node server.js 8080&lt;/code&gt; , 返回语句为：恭喜你小源！监听8080成功 请用在空中转体720度然后用电饭煲打开 &lt;code&gt;http://localhost:8080&lt;/code&gt;&lt;br&gt;6、【保持第一个gitbash不关闭的情况下在第二个gitbash并输入】：&lt;br&gt;6.1 &lt;code&gt;curl &amp;quot;http://localhost:8080&amp;quot;&lt;/code&gt;时返回：  //打字太麻烦了自己打开试试就知道了&lt;br&gt;6.2 &lt;code&gt;curl &amp;quot;http://localhost:8080/xxx&amp;quot;&lt;/code&gt;时返回：  //打字太麻烦了自己打开试试就知道了&lt;br&gt;6.3 &lt;code&gt;curl &amp;quot;http://localhost:8080?name=yuan&amp;quot;&lt;/code&gt;时返回：   //打字太麻烦了自己打开试试就知道了&lt;br&gt;7、总结：当我们发送一个请求的时候，服务器是会返回给我们想要的东西&lt;br&gt;
    
    </summary>
    
    
      <category term="基础知识" scheme="wangsiyuan233.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>GitHub for babies</title>
    <link href="wangsiyuan233.github.io/2018/04/13/1GitHub-for-babies/"/>
    <id>wangsiyuan233.github.io/2018/04/13/1GitHub-for-babies/</id>
    <published>2018-04-13T10:12:14.033Z</published>
    <updated>2018-03-27T07:22:08.907Z</updated>
    
    <content type="html"><![CDATA[<p>《GitHub for babies》   又名：如何让我的天才男友入门GitHub</p><p>搭建博客走了很多弯路，记录一下我摔的坑。<strong>（基础名词自己谷歌一下）</strong></p><hr><h3 id="第一步：注册github"><a href="#第一步：注册github" class="headerlink" title="第一步：注册github"></a>第一步：注册github</h3><p>这个是最简单的了，邮箱＋密码就能实现。<br>别的网站总能告诉你</p><blockquote><p>想学github,就要先知道git是什么~<br><a id="more"></a><br>其实这是熟悉git和github的人经历千山万水之后自己给自己加的戏，(没错我就是那个慌慌张张跑去买了《GIT》的人)，此时此刻的你只想着快点在GitHub上留下自己的印记，没想到又要学一个新东西，对于git，只用知道它是一个版本控制系统就足够了。而GitHub则是和你的小伙伴们分享git的一个project啦。</p></blockquote><p>对于新手，更棘手的应该是英文标识了，方方老师说过，面对一个新的软件，不要害怕，这点点，那点点，对于功能就能够了解得七七八八了，实在不行也可以去网站搜入门教程，但是值得注意的是，不要在畏惧的时候企图一口吃成大胖子，先看些《通俗易懂的Github》（名字是我瞎编的哈哈），而不是《GitHub大全》，推荐慕课的这个<a href="https://www.imooc.com/learn/208" target="_blank" rel="external">视频</a>，让你对github有了初印象。</p><p>下面要介绍的是 GitHub Pages这个功能，<br><strong>【以下均以我的情况为例】</strong></p><ol><li>我的github用户名是wangsiyuan233;</li><li>我的github昵称也是wangsiyuan233；</li><li>所以！我创建的repositories名称是wangsiyuan233.github.io</li></ol><p>这三个名称当然是可以随便改的，BUT，开启GitHub Pages受阻，你就要听我的。</p><ol><li>setting你的wangsiyuan233.github.io这个仓库；（注意不是setting你的profile/stars/gists）</li><li>直接往下滚到GitHub Pages，在source选项下拉到master branch,save一下。这个时候就能看到提示语：Your site is published at <a href="http://wangsiyuan233.gitHub.io/">http://wangsiyuan233.gitHub.io/</a>  ，  记住，这个就是你的二级域名链接，以后就可以通过这个链接直达你的【这个】repository~ GitHub Pages初级功能展示完毕。</li><li>觉得二级域名太长了是吗？又看到了下面的【Custom domain】对吗？是的，save你的主域名wangsiyuan233.cn，你可以用wangsiyuan233.cn来直达这个仓库了吗？</li></ol><p><strong>【BUT..事情没有那么简单..请看第二步↓】</strong></p><hr><h3 id="第二步：DNSPOD-解析域名"><a href="#第二步：DNSPOD-解析域名" class="headerlink" title="第二步：DNSPOD 解析域名"></a>第二步：DNSPOD 解析域名</h3><p>你在GitHub上直接save你的 custom domain之后，就能看到提示语：Your site is published at <a href="http://wangsiyuan233.cn" target="_blank" rel="external">http://wangsiyuan233.cn</a>  ，   你满心欢喜的点进去，等了半天没有刷新最后404了，你跑去谷歌，大家说：</p><blockquote><p>去dnspod解析一下域名就好了哦~</p></blockquote><p>你屁颠屁颠的照着知乎众神的方法运筹帷幄了一下午，DSNPod却提醒你：亲爱的就差最后一步啦，你的NS修改一下就好啦！<br>你的github还是打不开，你急的满头大汗，要去哪里改NS啊！！</p><p>因为他们忘记告诉你最最基本的一条：<strong>【wangsiyuan233.cn】这个域名是注册的（买的）</strong>，在这之前根本不存在的东西（wangsiyuan233.cn）,你让DNSPod咋帮你解析呢？ </p><p>在腾讯云注册好自己的域名，一切就顺畅到不像话，之前看得罗里吧嗦的帖子（哈哈是我）也值了，用wangsiyuan233.cn就能直达wangsiyuan233.github.io/这个repository啦！</p><p><strong>【等等！我为什么要花钱直达一个仓库？！..请看第三步↓】</strong></p><hr><h3 id="第三步：HEXO"><a href="#第三步：HEXO" class="headerlink" title="第三步：HEXO"></a>第三步：HEXO</h3><p>答案就是你要利用GitHub Pages功能，搭建一个wangsiyuan233.cn就能直达的<strong>博客</strong>呀！</p><p>安装之前我就被打了无数次预防针，也有了充足的思想准备，失败嘛，成功之母，大不了可以用简书嘻嘻。</p><p>。。。。。</p><p>最后经历两天的搏斗，我还是没能在windows上搭建一个HEXO，（所有我能试的方法我都试了，这两天吃饭都想着我的HEXO..毕竟域名都买好了啊！）于是我打开了淘宝，下单了一个程序员小哥帮我弄好的哈哈哈我好得意啊</p><p>。。。。。</p><p>然而，还是疏忽了，小哥给我装的是GOODHEXO，俗称便携版，好处就是哪天重装不用重新配置nodejs/git之类的了，不好的地方暂时还没发现，HEXO官网能用的东西GOODHEXO都能用。想下单的朋友可以先做下功课。</p><p>求助友邻也是一种办法不是吗，大大方方的承认现在的自己还不够优秀，还不能完成某项任务，还需要他人的帮助，并不可耻呀。</p><hr><h3 id="第四部：markdown"><a href="#第四部：markdown" class="headerlink" title="第四部：markdown"></a>第四部：markdown</h3><p>就是一码字软件，吸睛之处在它的preview（实时预览），在发布之前就能看到你的网页布局，不用多次靠提交来修正自己的布局了。网上有很多教程，其实每个按键点点就知道个大概了呢~人家主打就是“轻量级”呀~</p><p>我安装的时候，提示我说不能preview,一头雾水的我查了很久才知道需要awesomium，动动手搜关键字吧~</p><hr><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>不正之处到<a href="https://github.com/wangsiyuan233" target="_blank" rel="external">我的github</a>来告诉我吧~感谢捧场了呢~鞠躬~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《GitHub for babies》   又名：如何让我的天才男友入门GitHub&lt;/p&gt;
&lt;p&gt;搭建博客走了很多弯路，记录一下我摔的坑。&lt;strong&gt;（基础名词自己谷歌一下）&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;第一步：注册github&quot;&gt;&lt;a href=&quot;#第一步：注册github&quot; class=&quot;headerlink&quot; title=&quot;第一步：注册github&quot;&gt;&lt;/a&gt;第一步：注册github&lt;/h3&gt;&lt;p&gt;这个是最简单的了，邮箱＋密码就能实现。&lt;br&gt;别的网站总能告诉你&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;想学github,就要先知道git是什么~&lt;br&gt;
    
    </summary>
    
    
      <category term="基础知识" scheme="wangsiyuan233.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
