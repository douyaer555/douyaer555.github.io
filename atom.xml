<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wangsiyuan</title>
  
  <subtitle>小马过河</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="wangsiyuan233.github.io/"/>
  <updated>2018-10-22T12:39:04.290Z</updated>
  <id>wangsiyuan233.github.io/</id>
  
  <author>
    <name>wangsiyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>创建对象</title>
    <link href="wangsiyuan233.github.io/2018/10/22/10%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <id>wangsiyuan233.github.io/2018/10/22/10创建对象/</id>
    <published>2018-10-22T08:59:26.000Z</published>
    <updated>2018-10-22T12:39:04.290Z</updated>
    
    <content type="html"><![CDATA[<p>一共用 7 种创建对象的方式：<br>工厂模式、构造函数模式、原型模式、组合模式、动态原型模式、寄生构造函数模式、稳妥构造函数模式<br>反正说了这么多你也记不住</p><p>当然直接 划重点！</p><p>JS中，使用最广泛，认同度最高的就是：【组合使用构造函数模式和原型模式】<br>JS中，最完美的是：【动态原型模式】（解决了上面一种方法看起来很奇怪的弊端）<br>有重大缺陷的是：【构造函数模式】、【原型模式】<br>其中明确提出“不推荐”的是：【工厂模式】、【寄生构造函数模式】</p><p>其实我特别想一开始就说说【组合使用构造函数模式和原型模式】的神奇之处的，你说谁不喜欢这种上手就能用的东西呢，谁要关心剩下的 6 个是什么鬼啦！但是。。这是个组合模式呀！ 废话已多说，我们就从 【构造函数模式】 和 【原型模式】 开始吧！<br><a id="more"></a></p><blockquote><p>一、构造函数模式</p></blockquote><p>首先是该模式的标准样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一块</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Sue"</span>,<span class="number">22</span>,<span class="string">'Master'</span>)</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Siwei"</span>,<span class="number">22</span>,<span class="string">'Phd'</span>)</div><div class="line"></div><div class="line"><span class="comment">//第二块</span></div><div class="line">alert(person1.constructor == Person); <span class="comment">// true</span></div><div class="line">alert(person2.constructor == Person); <span class="comment">// true</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 第三块</span></div><div class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div></pre></td></tr></table></figure></p><p><em>【第一块】信息</em><br>new 替我们做好的四个步骤：创建新对象、this 指向新对象、为新对象添加属性、返回新对象；</p><p><em>【第二块】信息</em><br>实例的 constructor 属性都指向 Person;</p><p><em>【第三块】信息</em><br>Person 是 person1/person2 的父类；<br>Object 是 person1/person2 的顶端；</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name,age,job)</span></span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.sayName = sayName；</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span><span class="params">()</span></span>&#123;alert(<span class="keyword">this</span>.name);&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Sue"</span>,<span class="number">22</span>,<span class="string">'Master'</span>)</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Siwei"</span>,<span class="number">22</span>,<span class="string">'Phd'</span>)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一共用 7 种创建对象的方式：&lt;br&gt;工厂模式、构造函数模式、原型模式、组合模式、动态原型模式、寄生构造函数模式、稳妥构造函数模式&lt;br&gt;反正说了这么多你也记不住&lt;/p&gt;
&lt;p&gt;当然直接 划重点！&lt;/p&gt;
&lt;p&gt;JS中，使用最广泛，认同度最高的就是：【组合使用构造函数模式和原型模式】&lt;br&gt;JS中，最完美的是：【动态原型模式】（解决了上面一种方法看起来很奇怪的弊端）&lt;br&gt;有重大缺陷的是：【构造函数模式】、【原型模式】&lt;br&gt;其中明确提出“不推荐”的是：【工厂模式】、【寄生构造函数模式】&lt;/p&gt;
&lt;p&gt;其实我特别想一开始就说说【组合使用构造函数模式和原型模式】的神奇之处的，你说谁不喜欢这种上手就能用的东西呢，谁要关心剩下的 6 个是什么鬼啦！但是。。这是个组合模式呀！ 废话已多说，我们就从 【构造函数模式】 和 【原型模式】 开始吧！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手撕代码</title>
    <link href="wangsiyuan233.github.io/2018/10/18/81%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"/>
    <id>wangsiyuan233.github.io/2018/10/18/81手撕代码/</id>
    <published>2018-10-18T05:57:39.000Z</published>
    <updated>2018-10-18T12:08:37.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>深拷贝</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> newobj=obj.instanceof <span class="built_in">Array</span>?[]:&#123;&#125;;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj!==<span class="string">"object"</span>)&#123;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</div><div class="line">            newobj[i]=obj[i].typeof obj[i]==<span class="string">"object"</span>?deepClone(obj[i]):obj[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> newobj;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//方法二</span></div><div class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">username</span>: <span class="string">'Wayne'</span>&#125;]</div><div class="line"><span class="keyword">let</span> arr2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr1)) <span class="comment">// 深度拷贝：js对象-&gt;JSON字符串-&gt;新js对象</span></div><div class="line">arr2[<span class="number">0</span>] = <span class="number">5</span></div><div class="line">arr2[<span class="number">2</span>].username = <span class="string">'Jack'</span></div><div class="line"><span class="built_in">console</span>.log(arr1) <span class="comment">// [1, 2, &#123;username: 'Wayne'&#125;]</span></div><div class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [5, 2, &#123;username: 'Jack'&#125;]</span></div></pre></td></tr></table></figure><a id="more"></a><blockquote><p>Ajax</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</div><div class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'/xxxx'</span>)</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(xhr.responseText)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">xhr.send(<span class="string">'a=1&amp;b=2'</span>)</div></pre></td></tr></table></figure><blockquote><p>Promise</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//then</span></div><div class="line">  $.ajax(...).then(成功函数, 失败函数)</div><div class="line"><span class="comment">//链式 then</span></div><div class="line">  $.ajax(...).then(成功函数, 失败函数).then(成功函数<span class="number">2</span>, 失败函数<span class="number">2</span>)</div><div class="line"><span class="comment">//如何自己生成 Promise 对象</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">              resolve() 或者 reject()</div><div class="line">          &#125;,<span class="number">3000</span>)</div><div class="line">      &#125;)</div><div class="line">  &#125;</div><div class="line">  xxx().then(...)</div></pre></td></tr></table></figure><blockquote><p>实现push</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.splice.apply(<span class="keyword">this</span>, [<span class="keyword">this</span>.length, <span class="number">0</span>].concat(<span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>)));</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>实现pop</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.splice(<span class="keyword">this</span>.length - <span class="number">1</span>, <span class="number">1</span>)[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>实现 call</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @description 使用ES6函数的rest参数和数组的扩展运算符实现call方法</div><div class="line"> * @param &#123;Object&#125; context call方法一个指定的this值</div><div class="line"> * @param &#123;Object, String, Number, Boolean&#125; context call方法一个指定的this值</div><div class="line"> * @returns &#123;Object, String, Number, Boolean&#125; 返回调用函数的值</div><div class="line"> */</div><div class="line">Function.prototype.call = <span class="function"><span class="keyword">function</span><span class="params">(context, <span class="rest_arg">...args</span>)</span> </span>&#123;</div><div class="line">  <span class="comment">// 使用ES6函数的rest参数(形式为...变量名),args是数组</span></div><div class="line">  <span class="comment">// context为null的时候，context为window</span></div><div class="line">  <span class="keyword">var</span> context = context || window</div><div class="line">  <span class="comment">// 获取调用call的函数</span></div><div class="line">  context.fn = <span class="keyword">this</span></div><div class="line">  <span class="comment">// 使用ES6扩展运算符（...）执行函数，返回结果</span></div><div class="line">  <span class="keyword">var</span> result = context.fn(...args)</div><div class="line">  <span class="comment">// 删除fn属性</span></div><div class="line">  <span class="keyword">delete</span> context.fn</div><div class="line">  <span class="comment">// 返回结果</span></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>实现apply</p></blockquote><p>apply和call方法实现类似，apply和call方法的区别仅在于接收参数的方式不同。对于apply()方法而言，第一个参数是作用域没有变化，变化的只是其余的参数apply使用数组或者arguments对象，call直接传递给函数。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Function.prototype.<span class="built_in">apply</span> = function(<span class="built_in">context</span>, arr) &#123;</div><div class="line">  <span class="built_in">var</span> <span class="built_in">context</span> = <span class="built_in">context</span> || window</div><div class="line">  <span class="built_in">context</span>.fn = this</div><div class="line">  <span class="built_in">var</span> result = <span class="built_in">context</span>.fn(...arr)</div><div class="line">  <span class="built_in">delete</span> <span class="built_in">context</span>.fn</div><div class="line">  <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>实现bind</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> Function.prototype.bind !== <span class="string">'function'</span>) &#123;</div><div class="line">    Function.prototype.bind = <span class="function"><span class="keyword">function</span><span class="params">(context, <span class="rest_arg">...rest</span>)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'invalid invoked!'</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> self(...rest, ...args)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> self.apply(context, rest.concat(args))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>创建对象的方式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法一：构造函数模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, job</span>) </span>&#123; </div><div class="line"> <span class="keyword">this</span>.name = name;</div><div class="line"> <span class="keyword">this</span>.job = job;</div><div class="line"> <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line"> &#125; </div><div class="line">&#125; </div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Mike'</span>, <span class="string">'student'</span>) </div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'X'</span>, <span class="string">'engineer'</span>) </div><div class="line"></div><div class="line"><span class="comment">//方法二：原型模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;    </div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">"Mike"</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">29</span>,</div><div class="line">    <span class="attr">job</span> : <span class="string">"engineer"</span>,    </div><div class="line">    <span class="attr">syaName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert( <span class="keyword">this</span>.name );</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>对象继承的方式</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure><blockquote><p>数组去重</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法一：利用ES6 Set去重（ES6中最常用）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</div><div class="line"><span class="built_in">console</span>.log(unique(arr))</div><div class="line">  <span class="comment">//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;&#125;, &#123;&#125;]</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//方法二：利用for嵌套for，然后splice去重（ES5中最常用）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;            </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++)&#123;</div><div class="line">                <span class="keyword">if</span>(arr[i]==arr[j])&#123;         <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></div><div class="line">                    arr.splice(j,<span class="number">1</span>);</div><div class="line">                    j--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</div><div class="line">    <span class="built_in">console</span>.log(unique(arr))</div><div class="line">    <span class="comment">//[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//方法三：利用hasOwnProperty 判断是否存在对象属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</div><div class="line">        <span class="built_in">console</span>.log(unique(arr))</div><div class="line"><span class="comment">//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;…&#125;]   //所有的都去重了</span></div></pre></td></tr></table></figure><blockquote><p>快排</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">quickSort</span> = function(arr) &#123;</div><div class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</div><div class="line">　　<span class="keyword">var</span> pivotIndex = <span class="type">Math</span>.floor(arr.length / <span class="number">2</span>);</div><div class="line">　  <span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</div><div class="line">　　<span class="keyword">var</span> <span class="keyword">left</span> = [];</div><div class="line">　　<span class="keyword">var</span> <span class="keyword">right</span> = [];</div><div class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</div><div class="line">　　　　　　<span class="keyword">left</span>.push(arr[i]);</div><div class="line">　　　　&#125; <span class="keyword">else</span> &#123;</div><div class="line">　　　　　　<span class="keyword">right</span>.push(arr[i]);</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">return</span> <span class="built_in">quickSort</span>(<span class="keyword">left</span>).concat([pivot], <span class="built_in">quickSort</span>(<span class="keyword">right</span>));</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>二分查找</p></blockquote><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function binary-search(arr,<span class="built_in">key</span>)&#123;</div><div class="line">       <span class="built_in">var</span> low=<span class="number">0</span>,</div><div class="line">           high=arr.<span class="built_in">length</span>-<span class="number">1</span>,</div><div class="line">           mid=Math.<span class="built_in">floor</span>((low+high)/<span class="number">2</span>);</div><div class="line">       <span class="keyword">while</span>(low&lt;=high)&#123;</div><div class="line">           mid=Math.<span class="built_in">floor</span>((low+high)/<span class="number">2</span>);</div><div class="line">           <span class="keyword">if</span>(<span class="built_in">key</span>==arr[mid])&#123;</div><div class="line">               <span class="built_in">return</span> mid;</div><div class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">key</span>&lt;arr[mid])&#123;</div><div class="line">               high=mid-<span class="number">1</span>;</div><div class="line">          &#125;<span class="keyword">else</span>&#123;</div><div class="line">              low=mid+<span class="number">1</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> -<span class="number">1</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><blockquote><p>VUE双向数据绑定</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;input id=txt /&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"show-txt"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj=&#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'txt'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line">    set:<span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"#txt"</span>).value=newValue;</div><div class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"#show-txt"</span>).innerHTML=newValue;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"keyup"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    obj.txt=e.target.value;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><p>防抖</p></blockquote><p>debounce 策略的电梯。如果电梯里有人进来，等待50毫秒。如果又人进来，50毫秒等待重新计时，直到50毫秒超时，开始运送。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let debounce = (fn, time = <span class="number">50</span>) =&gt; &#123; <span class="comment">// 防抖动 控制空闲时间 用户输入频繁</span></div><div class="line">         let timer;</div><div class="line">         <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</div><div class="line">             let that = <span class="keyword">this</span>;</div><div class="line">             clearTimeout(timer);</div><div class="line">             timer = setTimeout(fn.bind(that, ...args), time);</div><div class="line">         &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p><blockquote><p>节流</p></blockquote><p>throttle 策略的电梯。保证如果电梯第一个人进来后，50毫秒后准时运送一次，不等待。如果没有人，则待机。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@desc</span> 函数防抖</div><div class="line"> * <span class="doctag">@param</span> func 函数</div><div class="line"> * <span class="doctag">@param</span> wait 延迟执行毫秒数</div><div class="line"> * <span class="doctag">@param</span> immediate true 表立即执行，false 表非立即执行</div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span><span class="params">(func,wait,immediate)</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> timeout;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> context = this;</div><div class="line">        <span class="keyword">var</span> args = arguments;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</div><div class="line">        <span class="keyword">if</span> (immediate) &#123;</div><div class="line">            <span class="keyword">var</span> callNow = !timeout;</div><div class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">                timeout = <span class="keyword">null</span>;</div><div class="line">            &#125;, wait)</div><div class="line">            <span class="keyword">if</span> (callNow) func.apply(context, args)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">                func.apply(context, args)</div><div class="line">            &#125;, wait);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;深拷贝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 方法一&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;deepClone&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; newobj=obj.instanceof &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;?[]:&amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; obj!==&lt;span class=&quot;string&quot;&gt;&quot;object&quot;&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; obj)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            newobj[i]=obj[i].typeof obj[i]==&lt;span class=&quot;string&quot;&gt;&quot;object&quot;&lt;/span&gt;?deepClone(obj[i]):obj[i];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; newobj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//方法二&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr1 = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &amp;#123;&lt;span class=&quot;attr&quot;&gt;username&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Wayne&#39;&lt;/span&gt;&amp;#125;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr2 = &lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.parse(&lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.stringify(arr1)) &lt;span class=&quot;comment&quot;&gt;// 深度拷贝：js对象-&amp;gt;JSON字符串-&amp;gt;新js对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;arr2[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;arr2[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;].username = &lt;span class=&quot;string&quot;&gt;&#39;Jack&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr1) &lt;span class=&quot;comment&quot;&gt;// [1, 2, &amp;#123;username: &#39;Wayne&#39;&amp;#125;]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr2) &lt;span class=&quot;comment&quot;&gt;// [5, 2, &amp;#123;username: &#39;Jack&#39;&amp;#125;]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>盒模型</title>
    <link href="wangsiyuan233.github.io/2018/10/17/82%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <id>wangsiyuan233.github.io/2018/10/17/82盒模型/</id>
    <published>2018-10-17T05:57:39.000Z</published>
    <updated>2018-10-22T14:56:13.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一、两种盒模型</p></blockquote><p>1、标准模型：宽高就是 <code>content</code> 的宽高<br>2、IE模型： 宽高是 <code>content + border + padding</code> (木有margin)</p><blockquote><p>二、怎么设置盒模型呢</p></blockquote><p>1、<code>box-sizing: content-box;</code>(默认、标准）<br>2、<code>box-sizing: border-box;</code>(IE)<br><a id="more"></a></p><blockquote><p>三、怎样用JS获取盒模型对应的宽高</p></blockquote><p>1、<code>Element.currentStyle.width/height;</code> 只支持IE<br>2、<code>Window.getComputedStyle().width/height;</code>都可以用<br>3、<code>Element.getBoundingClientRect().width/height;</code> 根据视窗的左上角拿到位置坐标</p><blockquote><p>四、边距重叠</p></blockquote><p>当两个垂直外边距相遇时，他们将形成一个外边距；<br>合并后的外边距高度 = 两个发生合并的外边距中的较大值；</p><p>只有<strong>普通</strong>文档流中<strong>块级</strong>元素的<strong>垂直</strong>外边距才能合并</p><blockquote><p>BFC（块级格式化上下文）</p></blockquote><p>1、独立的渲染区域，规定了其内部盒子如何布局，盒子内的区域与外界不相干</p><p>2、触发条件：（满足一个就行了）<br>2.1 <code>float ≠ none;</code><br>2.2 <code>overflow ≠ visible;</code><br>2.3 <code>display: inline-block / table-cell / table-caption;</code><br>2.4 <code>position: absolute / fixed;</code></p><p>3、布局规则<br>垂直方向上，一个接一个的放置，上下距离由 <code>margin</code> 决定，BFC 内外互不干扰，浮动元素参与总的高度计算</p><p>4、 BFC 的作用<br>自适应俩栏布局，阻止元素被浮动元素覆盖，可以包含浮动元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一、两种盒模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、标准模型：宽高就是 &lt;code&gt;content&lt;/code&gt; 的宽高&lt;br&gt;2、IE模型： 宽高是 &lt;code&gt;content + border + padding&lt;/code&gt; (木有margin)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二、怎么设置盒模型呢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、&lt;code&gt;box-sizing: content-box;&lt;/code&gt;(默认、标准）&lt;br&gt;2、&lt;code&gt;box-sizing: border-box;&lt;/code&gt;(IE)&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指offer(6)--递归和回溯法(JavaScript版)/共 题</title>
    <link href="wangsiyuan233.github.io/2018/10/08/75%E5%89%91%E6%8C%87-%E9%80%92%E5%BD%92%E5%92%8C%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>wangsiyuan233.github.io/2018/10/08/75剑指-递归和回溯法/</id>
    <published>2018-10-08T12:14:15.000Z</published>
    <updated>2018-10-08T12:14:34.319Z</updated>
    
    <content type="html"><![CDATA[<p>【<a href="https://github.com/wangsiyuan233/NowCoder" target="_blank" rel="external">源码地址</a>】 || 【<a href="https://www.nowcoder.com/ta/coding-interviews?page=1" target="_blank" rel="external">代码调试</a>】</p><hr><blockquote><p>七、斐波那契数列 p74</p></blockquote><p><strong>描述</strong>：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Fibonacci(<span class="keyword">n</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">n</span>==0)&#123;<span class="keyword">return</span> 0;&#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">n</span>==1)&#123;<span class="keyword">return</span> 1;&#125;</div><div class="line">    <span class="keyword">var</span> <span class="keyword">one</span> = 0,<span class="keyword">two</span>=1; <span class="comment">// 这个部分的值是由上面的 return 决定的</span></div><div class="line">    <span class="keyword">var</span> fbnum=1; <span class="comment">// 是0 1 undefined 都可以</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i =2;i&lt;=<span class="keyword">n</span>;i++)&#123;</div><div class="line">        fbnum = <span class="keyword">one</span>+<span class="keyword">two</span>;</div><div class="line">        <span class="keyword">one</span> = <span class="keyword">two</span>; <span class="comment">// 小的数在下一次迭代变成大的数</span></div><div class="line">        <span class="keyword">two</span> = fbnum;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fbnum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：套路请熟记<br><a id="more"></a></p><blockquote><p>八、跳台阶 p77</p></blockquote><p><strong>描述</strong>：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jumpFloor</span>(<span class="params"><span class="built_in">number</span></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">number</span> === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">number</span> === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">let</span> next = <span class="number">0</span> ;<span class="comment">// 当前台阶的跳法总数</span></div><div class="line">  <span class="keyword">let</span> one_step = <span class="number">2</span>; <span class="comment">// 当前台阶【后退一阶】的台阶的跳法总数(初始值当前台阶是第3阶)</span></div><div class="line">  <span class="keyword">let</span> two_step = <span class="number">1</span>; <span class="comment">// 当前台阶【后退二阶】的台阶的跳法总数(初始值当前台阶是第3阶)</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; <span class="built_in">number</span>; i++)&#123; <span class="comment">//(let i = 3; i &lt;= number; i++)</span></div><div class="line">    next = two_step + one_step;<span class="comment">// 小的数在下一次迭代变成大的数</span></div><div class="line">    two_step = one_step;<span class="comment">// 后退一阶在下一次迭代变为后退两阶</span></div><div class="line">    one_step = next; <span class="comment">// 当前台阶在下一次迭代变为后退一阶</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>或者是：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jumpFloor</span>(<span class="params"><span class="built_in">number</span></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">number</span> === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">number</span> === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">let</span> next = <span class="number">0</span> ;<span class="comment">// 当前台阶的跳法总数</span></div><div class="line">  <span class="keyword">let</span> one_step = <span class="number">1</span>; <span class="comment">// 这个部分的值是由上面的 return 决定的</span></div><div class="line">  <span class="keyword">let</span> two_step = <span class="number">2</span>;  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= <span class="built_in">number</span>; i++)&#123;</div><div class="line">    next = two_step + one_step;</div><div class="line">    one_step = two_step;<span class="comment">// 小的数在下一次迭代变成大的数</span></div><div class="line">    two_step = next; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、其实也是一个斐波那契问题<br>2、第一阶和第二阶考虑过了，初始当前台阶为第三阶，向后迭代<br>3、当前台阶的跳法总数=当前台阶【后退一阶】的台阶的跳法总数+当前台阶【后退二阶】的台阶的跳法总数</p><blockquote><p>九、变态跳台阶 p78</p></blockquote><p><strong>描述</strong>：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span></span> jumpFloorII(<span class="keyword">number</span>)&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">number</span> &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span> </div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>*jumpFloorII(<span class="keyword">number</span> - <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级<br>2、跳1级，剩下n-1级，则剩下跳法是f(n-1)<br>3、跳2级，剩下n-2级，则剩下跳法是f(n-2)<br>4、所以f(n)=f(n-1)+f(n-2)+…+f(1)<br>5、因为f(n-1)=f(n-2)+f(n-3)+…+f(1)<br>6、所以f(n)+f(n-1) = f(n-1)+2<em>(f(n-2)+f(n-3)+…+f(1))<br>7、所以f(n)=2</em>f(n-1)</p><blockquote><p>十、矩形覆盖 p79</p></blockquote><p><strong>描述</strong>：我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function rectCover(number)&#123;</div><div class="line">  <span class="keyword">if</span>(number &lt;= 2)&#123;</div><div class="line">    <span class="keyword">return</span> number;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> <span class="keyword">one</span> = 1;</div><div class="line">  <span class="keyword">var</span> <span class="keyword">two</span> = 2;</div><div class="line">  <span class="keyword">var</span> result = 1;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = 3; i &lt;= number; i++)&#123;</div><div class="line">    result = <span class="keyword">one</span> + <span class="keyword">two</span>;</div><div class="line">    <span class="keyword">one</span> = <span class="keyword">two</span>;</div><div class="line">    <span class="keyword">two</span> = result;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：其实也是一个斐波那契问题</p><blockquote><p>十九、顺时针打印矩阵 p161</p></blockquote><p><strong>描述</strong>：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">function printMatrix(<span class="keyword">matrix</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">matrix</span> == <span class="built_in">null</span> || <span class="keyword">matrix</span>.length == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    var <span class="built_in">cols</span> = <span class="keyword">matrix</span>[<span class="number">0</span>].length; <span class="comment">// 纵</span></div><div class="line">    var <span class="built_in">rows</span> = <span class="keyword">matrix</span>.length; <span class="comment">// 横</span></div><div class="line">    var start = <span class="number">0</span>;</div><div class="line">    var result = [];</div><div class="line"></div><div class="line">    <span class="comment">//根据作者的推理，让循环继续的条件是：</span></div><div class="line">    <span class="comment">// rows &gt; startY * 2 且 cols &gt; startX x 2</span></div><div class="line">    <span class="keyword">while</span>(<span class="built_in">rows</span> &gt; start * <span class="number">2</span> &amp;&amp; <span class="built_in">cols</span> &gt; start * <span class="number">2</span>)&#123;</div><div class="line">        var endX = <span class="built_in">cols</span> - <span class="number">1</span> - start,</div><div class="line">            endY = <span class="built_in">rows</span> - <span class="number">1</span> - start;</div><div class="line"></div><div class="line">        <span class="comment">//从左到右打印</span></div><div class="line">        <span class="keyword">for</span>(var i = start; i &lt;= endX; i++)&#123;</div><div class="line">            result.<span class="keyword">push</span>(<span class="keyword">matrix</span>[start][i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//从上到下打印</span></div><div class="line">        <span class="keyword">if</span>(start &lt; endY)&#123;</div><div class="line">            <span class="keyword">for</span>(var i = start + <span class="number">1</span>; i &lt;= endY; i++)&#123;</div><div class="line">                result.<span class="keyword">push</span>(<span class="keyword">matrix</span>[i][endX]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//从右到左打印</span></div><div class="line">        <span class="keyword">if</span>(start &lt; endX &amp;&amp; start &lt; endY)&#123;</div><div class="line">            <span class="keyword">for</span>(var i = endX - <span class="number">1</span>; i &gt;= start ; i--)&#123;</div><div class="line">                result.<span class="keyword">push</span>(<span class="keyword">matrix</span>[endY][i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//从下到上打印</span></div><div class="line">        <span class="keyword">if</span>(start &lt; endX &amp;&amp; start &lt; endY - <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">for</span>(var i = endY - <span class="number">1</span>; i &gt;= start + <span class="number">1</span>; i--)&#123;</div><div class="line">               result.<span class="keyword">push</span>(<span class="keyword">matrix</span>[i][start]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        start++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p><hr><blockquote><p>六十五、矩阵中的路径 p89</p></blockquote><p><strong>描述</strong>：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">function hasPath(<span class="built_in">matrix</span>, rows, cols, path)&#123;</div><div class="line">    <span class="keyword">if</span> (path.<span class="built_in">length</span> === <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (rows * cols &lt; path.<span class="built_in">length</span>) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">let</span> <span class="built_in">status</span> = [];</div><div class="line">    // 初始化<span class="built_in">status</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">        <span class="built_in">status</span>.<span class="built_in">push</span>([]);</div><div class="line">        <span class="keyword">for</span>(<span class="built_in">let</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">            <span class="built_in">status</span>[i][j] = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //找到第一个符合的path的</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">let</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">matrix</span>[i*cols+j] === path[<span class="number">0</span>]) &#123;</div><div class="line">                <span class="keyword">if</span> (path.<span class="built_in">length</span> === <span class="number">1</span>) &#123;</div><div class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">status</span>[i][j] = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">if</span> (find(<span class="built_in">matrix</span>, rows, cols, i, j, path.slice(<span class="number">1</span>), <span class="built_in">status</span>)) &#123;</div><div class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">status</span>[i][j] = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">function find(<span class="built_in">matrix</span>,rows,cols,<span class="built_in">row</span>,<span class="built_in">col</span>,path,<span class="built_in">status</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">row</span> &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">matrix</span>[(<span class="built_in">row</span>-<span class="number">1</span>)*cols + <span class="built_in">col</span>] === path[<span class="number">0</span>] &amp;&amp; <span class="built_in">status</span>[<span class="built_in">row</span>-<span class="number">1</span>][<span class="built_in">col</span>] === <span class="literal">false</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(path.<span class="built_in">length</span> === <span class="number">1</span>)&#123;</div><div class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">status</span>[<span class="built_in">row</span>-<span class="number">1</span>][<span class="built_in">col</span>] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(find(<span class="built_in">matrix</span>,rows,cols,<span class="built_in">row</span>-<span class="number">1</span>,<span class="built_in">col</span>,path.slice(<span class="number">1</span>),<span class="built_in">status</span>))&#123;</div><div class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">status</span>[<span class="built_in">row</span>-<span class="number">1</span>][<span class="built_in">col</span>] = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">row</span> &lt; rows-<span class="number">1</span> &amp;&amp; <span class="built_in">matrix</span>[(<span class="built_in">row</span>+<span class="number">1</span>)*cols + <span class="built_in">col</span>] === path[<span class="number">0</span>] &amp;&amp; <span class="built_in">status</span>[<span class="built_in">row</span>+<span class="number">1</span>][<span class="built_in">col</span>] === <span class="literal">false</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(path.<span class="built_in">length</span> === <span class="number">1</span>)&#123;</div><div class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">status</span>[<span class="built_in">row</span>+<span class="number">1</span>][<span class="built_in">col</span>] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(find(<span class="built_in">matrix</span>,rows,cols,<span class="built_in">row</span>+<span class="number">1</span>,<span class="built_in">col</span>,path.slice(<span class="number">1</span>),<span class="built_in">status</span>))&#123;</div><div class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">status</span>[<span class="built_in">row</span>+<span class="number">1</span>][<span class="built_in">col</span>] = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">col</span> &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">matrix</span>[<span class="built_in">row</span>*cols + <span class="built_in">col</span> -<span class="number">1</span>] === path[<span class="number">0</span>] &amp;&amp; <span class="built_in">status</span>[<span class="built_in">row</span>][<span class="built_in">col</span>-<span class="number">1</span>] === <span class="literal">false</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(path.<span class="built_in">length</span> === <span class="number">1</span>)&#123;</div><div class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">status</span>[<span class="built_in">row</span>][<span class="built_in">col</span>-<span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(find(<span class="built_in">matrix</span>,rows,cols,<span class="built_in">row</span>,<span class="built_in">col</span>-<span class="number">1</span>,path.slice(<span class="number">1</span>),<span class="built_in">status</span>))&#123;</div><div class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">status</span>[<span class="built_in">row</span>][<span class="built_in">col</span>-<span class="number">1</span>] = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">col</span> &lt; cols-<span class="number">1</span> &amp;&amp; <span class="built_in">matrix</span>[<span class="built_in">row</span>*cols + <span class="built_in">col</span> +<span class="number">1</span>] === path[<span class="number">0</span>] &amp;&amp; <span class="built_in">status</span>[<span class="built_in">row</span>][<span class="built_in">col</span>+<span class="number">1</span>] === <span class="literal">false</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(path.<span class="built_in">length</span> === <span class="number">1</span>)&#123;</div><div class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">status</span>[<span class="built_in">row</span>][<span class="built_in">col</span>+<span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(find(<span class="built_in">matrix</span>,rows,cols,<span class="built_in">row</span>,<span class="built_in">col</span>+<span class="number">1</span>,path.slice(<span class="number">1</span>),<span class="built_in">status</span>))&#123;</div><div class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">status</span>[<span class="built_in">row</span>][<span class="built_in">col</span>+<span class="number">1</span>] = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、这是一个可以用回朔法解决的典型题。首先，在矩阵中任选一个格子作为路径的起点。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。<br>2、重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。<br>3、由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。<br>4、由于路径不能重复进入矩阵的格子，还需要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否已经进入每个格子。 当矩阵中坐标为（row,col）的格子和路径字符串中相应的字符一样时，从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下一个字符<br>5、如果4个相邻的格子都没有匹配字符串中下一个的字符，表明当前路径字符串中字符在矩阵中的定位不正确，我们需要回到前一个，然后重新定位。<br>6、一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到合适的位置</p><blockquote><p>六十六、机器人的运动范围 p92</p></blockquote><p><strong>描述</strong>：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function movingCount(threshold, rows, cols) &#123;</div><div class="line">      <span class="built_in">var</span> visited = [];</div><div class="line">      <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">        visited.<span class="built_in">push</span>([]);</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">var</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">          visited[i][j] = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> moveCount(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">function moveCount(threshold, rows, cols, <span class="built_in">row</span>, <span class="built_in">col</span>, visited) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="built_in">row</span> &lt; <span class="number">0</span> || <span class="built_in">row</span> == rows || <span class="built_in">col</span> &lt; <span class="number">0</span> || <span class="built_in">col</span> == cols || visited[<span class="built_in">row</span>][<span class="built_in">col</span>]) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">var</span> <span class="built_in">sum</span> = <span class="number">0</span>;</div><div class="line">      <span class="built_in">var</span> temp = <span class="built_in">row</span> + <span class="string">""</span> + <span class="built_in">col</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; temp.<span class="built_in">length</span>; i++) &#123;</div><div class="line">        <span class="built_in">sum</span> += temp.charAt(i) / <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (<span class="built_in">sum</span> &gt; threshold) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="number">0</span></div><div class="line">      &#125;</div><div class="line">      visited[<span class="built_in">row</span>][<span class="built_in">col</span>] = <span class="literal">true</span>;</div><div class="line">      <span class="built_in">return</span> <span class="number">1</span> + moveCount(threshold, rows, cols, <span class="built_in">row</span>, <span class="built_in">col</span> - <span class="number">1</span>, visited) +</div><div class="line">        moveCount(threshold, rows, cols, <span class="built_in">row</span>, <span class="built_in">col</span> + <span class="number">1</span>, visited) +</div><div class="line">        moveCount(threshold, rows, cols, <span class="built_in">row</span> - <span class="number">1</span>, <span class="built_in">col</span>, visited) +</div><div class="line">        moveCount(threshold, rows, cols, <span class="built_in">row</span> + <span class="number">1</span>, <span class="built_in">col</span>, visited);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1.从(0,0)开始走，每成功走一步标记当前位置为true,然后从当前位置往四个方向探索，返回1 + 4 个方向的探索值之和。<br>2.探索时，判断当前节点是否可达的标准为：<br>1）当前节点在矩阵内；<br>2）当前节点未被访问过；<br>3）当前节点满足limit限制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【&lt;a href=&quot;https://github.com/wangsiyuan233/NowCoder&quot;&gt;源码地址&lt;/a&gt;】 || 【&lt;a href=&quot;https://www.nowcoder.com/ta/coding-interviews?page=1&quot;&gt;代码调试&lt;/a&gt;】&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;七、斐波那契数列 p74&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。&lt;br&gt;&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function Fibonacci(&lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;==0)&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; 0;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;==1)&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; 1;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;one&lt;/span&gt; = 0,&lt;span class=&quot;keyword&quot;&gt;two&lt;/span&gt;=1; &lt;span class=&quot;comment&quot;&gt;// 这个部分的值是由上面的 return 决定的&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; fbnum=1; &lt;span class=&quot;comment&quot;&gt;// 是0 1 undefined 都可以&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i =2;i&amp;lt;=&lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;;i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        fbnum = &lt;span class=&quot;keyword&quot;&gt;one&lt;/span&gt;+&lt;span class=&quot;keyword&quot;&gt;two&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;one&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;two&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 小的数在下一次迭代变成大的数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;two&lt;/span&gt; = fbnum;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fbnum;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：套路请熟记&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="wangsiyuan233.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer(5)--字符串、栈和队列(JavaScript版)/共 题</title>
    <link href="wangsiyuan233.github.io/2018/10/07/80%E5%89%91%E6%8C%87-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>wangsiyuan233.github.io/2018/10/07/80剑指-字符串、栈和队列/</id>
    <published>2018-10-07T01:43:26.000Z</published>
    <updated>2018-10-07T03:13:10.292Z</updated>
    
    <content type="html"><![CDATA[<p>【<a href="https://github.com/wangsiyuan233/NowCoder" target="_blank" rel="external">源码地址</a>】 || 【<a href="https://www.nowcoder.com/ta/coding-interviews?page=1" target="_blank" rel="external">代码调试</a>】</p><hr><blockquote><p>二、 替换空格 p51</p></blockquote><p><strong>描述</strong>：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="title">changeSpace</span>(str)&#123; </div><div class="line"><span class="keyword">return</span> <span class="type">str.replace(/\s/g,'%20/)</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：BUG题/<code>replace()</code><br><a id="more"></a></p><blockquote><p>二十七、字符串的排列 p197</p></blockquote><p><strong>描述</strong>：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br><img src="https://i.imgur.com/8UphvjW.png" alt=""><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Permutation</span><span class="params">(str)</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> strArr = str.split(<span class="string">""</span>).sort();  <span class="comment">//字母先进行分开 + 排序</span></div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; strArr.length; i++)&#123;</div><div class="line">        <span class="comment">//当相邻元素相同时，则跳过此次循环</span></div><div class="line">        <span class="keyword">if</span>((i &gt; <span class="number">0</span>) &amp;&amp; (strArr[i] == strArr[i - <span class="number">1</span>])) <span class="keyword">continue</span>;</div><div class="line">        <span class="comment">//截取前面部分</span></div><div class="line">        <span class="keyword">var</span> front  = strArr.slice(<span class="number">0</span>, i);</div><div class="line">        <span class="comment">//截取后面部分</span></div><div class="line">        <span class="keyword">var</span> end = strArr.slice(i + <span class="number">1</span>);</div><div class="line">        excuteFind(result, strArr[i], front.concat(end));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">excuteFind</span><span class="params">(result, mid, strArr)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(strArr.length == <span class="number">0</span>)&#123;</div><div class="line">      result.push(mid);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; strArr.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>((i &gt; <span class="number">0</span>) &amp;&amp; (strArr[i] == strArr[i - <span class="number">1</span>])) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">var</span> front = strArr.slice(<span class="number">0</span>, i);</div><div class="line">        <span class="keyword">var</span> end = strArr.slice(i + <span class="number">1</span>);</div><div class="line">        excuteFind(result, mid + strArr[i], front.concat(end));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？</p><blockquote><p>二十九、最小的K个数 p209</p></blockquote><p><strong>描述</strong>：// 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(input, k)</span></span>&#123;</div><div class="line">  <span class="comment">// 把输入的数组从小到大排列</span></div><div class="line">    <span class="keyword">var</span> result = input.sort(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> a-b;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> result.length&gt;=k?result.slice(<span class="number">0</span>,k):[];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>思路</strong>：拒绝使用红黑树科科</p><blockquote><p>四十九、把字符串转换成整数 p318</p></blockquote><p><strong>描述</strong>：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">将一个字符串转换成一个整数(实现Integer.valueOf(<span class="type">string</span>)的功能，但是<span class="type">string</span>不符合数字要求时返回<span class="number">0</span>)，要求不能使用字符串转换整数的库函数。 数值为<span class="number">0</span>或者字符串不是一个合法的数值则返回<span class="number">0</span>。</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：BUG题</p><blockquote><p>五十三、表示数值的字符串 p127</p></blockquote><p><strong>描述</strong>：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 方法一：</div><div class="line">function isNumeric(s)&#123;</div><div class="line">  return !isNaN(Number(s));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 方法二：</div><div class="line">function isNumeric(s)&#123;</div><div class="line">  return s.match(/[<span class="string">\+\-</span>]?[<span class="string">0-9</span>]<span class="emphasis">*(\.[0-9]*</span>)?([<span class="string">eE</span>][<span class="symbol">\+\-</span>]?\d+)?/g)[0] === s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？</p><blockquote><p> 五十四 字符流中第一个不重复的字符  ???</p></blockquote><p><strong>描述</strong>：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。如果当前字符流没有存在出现一次的字符，返回#字符。</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">map</span> = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> Init()&#123;</div><div class="line">    <span class="keyword">map</span> = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> Insert(ch)&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">map</span>[ch]) &#123;</div><div class="line">        <span class="keyword">map</span>[ch] = <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">map</span>[ch] ++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> FirstAppearingOnce()&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> ch <span class="keyword">in</span> <span class="keyword">map</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">map</span>.hasOwnProperty(ch))&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">map</span>[ch] === <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">return</span> ch;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> '<span class="comment">#';</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>思路</strong>：？？？</p><hr><blockquote><p>五、用两个栈实现队列 p68</p></blockquote><p><strong>描述</strong>：用两个栈来实现一个队列，完成队列的Push和Pop操作。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> strack = [];</div><div class="line"><span class="comment">//push()向数组的末尾添加一个或多个元素，并返回新的长度。</span></div><div class="line"><span class="comment">// 第一步：末尾添加node</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(node)</span></span>&#123;strack.push(node);&#125;</div><div class="line"><span class="comment">// 第二步：取得第一个元素，删除并返回最后一个元素。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(stack.length == <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="keyword">return</span> stack.shift();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：操作两个“先进后出”的栈实现一个“<strong>先进先出</strong>”的队列，所以要用到 <code>shift()</code>来模拟队列</p><blockquote><p>二十、包含min函数的栈 p165</p></blockquote><p><strong>描述</strong>：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stack = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">node</span>)</span>&#123;</div><div class="line">    stack.push(node);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 删除最后一个元素，并返回它</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> stack.length==<span class="number">0</span>?<span class="literal">null</span>:stack.pop();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 取第一个元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">top</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> stack.length==<span class="number">0</span>?<span class="literal">null</span>:stack[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min.apply(<span class="keyword">this</span>,stack);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>二十一、栈的压入、弹出序列 p168</p></blockquote><p><strong>描述</strong>：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function IsPopOrder(pushV, popV)&#123; // 进栈 出栈</div><div class="line">     <span class="keyword">if</span>(pushV.<span class="built_in">length</span> === <span class="number">0</span> || popV.<span class="built_in">length</span> === <span class="number">0</span>)&#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    // 借用一个辅助的栈</div><div class="line">    <span class="built_in">var</span> temp = [];</div><div class="line">    <span class="built_in">var</span> popIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">var</span> i=<span class="number">0</span>;i&lt;pushV.<span class="built_in">length</span>;i++)&#123;</div><div class="line">      // 将原数列依次压入辅助栈，</div><div class="line">        temp.<span class="built_in">push</span>(pushV[i]);</div><div class="line">      // 【栈顶元素】与 所给的【出栈队列】相比，如果 相同 则出栈</div><div class="line">        <span class="keyword">while</span>(temp.<span class="built_in">length</span> &amp;&amp; temp[temp.<span class="built_in">length</span>-<span class="number">1</span>] === popV[popIndex])&#123;</div><div class="line">          temp.<span class="built_in">pop</span>();</div><div class="line">          popIndex++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> (temp.<span class="built_in">length</span> === <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：【栈顶元素】与 所给的【出栈队列】相比，如果 相同 则出栈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【&lt;a href=&quot;https://github.com/wangsiyuan233/NowCoder&quot;&gt;源码地址&lt;/a&gt;】 || 【&lt;a href=&quot;https://www.nowcoder.com/ta/coding-interviews?page=1&quot;&gt;代码调试&lt;/a&gt;】&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;二、 替换空格 p51&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;br&gt;&lt;figure class=&quot;highlight ada&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;changeSpace&lt;/span&gt;(str)&amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;str.replace(/\s/g,&#39;%20/)&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：BUG题/&lt;code&gt;replace()&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="wangsiyuan233.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer(4)--运算篇(JavaScript版)/共 题</title>
    <link href="wangsiyuan233.github.io/2018/10/06/79%E5%89%91%E6%8C%87-%E8%BF%90%E7%AE%97%E7%AF%87/"/>
    <id>wangsiyuan233.github.io/2018/10/06/79剑指-运算篇/</id>
    <published>2018-10-06T12:48:04.000Z</published>
    <updated>2018-10-07T03:13:03.403Z</updated>
    
    <content type="html"><![CDATA[<p>【<a href="https://github.com/wangsiyuan233/NowCoder" target="_blank" rel="external">源码地址</a>】 || 【<a href="https://www.nowcoder.com/ta/coding-interviews?page=1" target="_blank" rel="external">代码调试</a>】</p><hr><blockquote><p>十一、二进制中1的个数 p100</p></blockquote><p><strong>描述</strong>：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p><strong>方法一：常规解法</strong><br>1、怎样判断一个整数的最右边是不是1<br>2、把整数和1做【位与运算】，看结果是不是0就知道了。<br>3、如果结果是1，那最右边的一位就是1<br>4、bug就是不能分析出来负数，会陷入死循环<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function NumberOf1(n)&#123;</div><div class="line">  var <span class="built_in">count</span> = <span class="number">0</span>, <span class="built_in">flag</span> = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(<span class="built_in">flag</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(n&amp;<span class="built_in">flag</span>)<span class="built_in">count</span>++;</div><div class="line">    <span class="built_in">flag</span> = <span class="built_in">flag</span> &lt;&lt; <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  return <span class="built_in">count</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>方法二：高级解法</strong><br>1、如果一个整数不为0，那么这个整数至少有一位是1。<br>如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。<br>其余所有位将不会受到影响。</p><p>2、举个例子：一个二进制数 <code>1100</code>，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是 <code>1011</code>.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如<code>1100&amp;1011=1000</code>.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function NumberOf1(<span class="built_in">n</span>)&#123;</div><div class="line">  <span class="built_in">var</span> <span class="built_in">count</span> = <span class="number">0</span>;</div><div class="line">  while (<span class="built_in">n</span>)&#123;</div><div class="line">   <span class="built_in">count</span>++;</div><div class="line">   <span class="built_in">n</span> = (<span class="built_in">n</span>-<span class="number">1</span>)&amp;<span class="built_in">n</span>;//把最右边的一个<span class="number">1</span>变成<span class="number">0</span></div><div class="line">&#125;</div><div class="line">  return <span class="built_in">count</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><a id="more"></a><blockquote><p>十二、数值的整数次方 p110</p></blockquote><p><strong>描述</strong>：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Power</span>(<span class="params">x,n</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123; <span class="comment">//指数 n 小于 0</span></div><div class="line">        <span class="keyword">if</span>(x &lt;= <span class="number">0</span>) &#123; <span class="comment">//底数 x 小于等于 0</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"分母不能小于等于0"</span>);</div><div class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//底数 x 大于 0</span></div><div class="line">            <span class="keyword">if</span>(-n % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">//指数 n 的绝对值是奇数</span></div><div class="line">              <span class="keyword">return</span> <span class="number">1</span>/(Power(x,-n<span class="number">-1</span>) * x);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//指数 n 的绝对值是偶数</span></div><div class="line">              <span class="keyword">var</span> r = <span class="number">1</span>/Power(x,-n/<span class="number">2</span>);</div><div class="line">            <span class="keyword">return</span> r * r;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;<span class="comment">//指数 n 等于 0</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;<span class="comment">//指数 n 大于 0</span></div><div class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">//指数 n 是奇数</span></div><div class="line">            <span class="keyword">return</span> Power(x,n<span class="number">-1</span>) * x;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//指数 n 是偶数</span></div><div class="line">            <span class="keyword">var</span> r = Power(x,n/<span class="number">2</span>);</div><div class="line">            <span class="keyword">return</span> r * r;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：分类讨论</p><blockquote><p>三十一、整数中1出现的次数（从1到n整数中1出现的次数） p221</p></blockquote><p><strong>描述</strong>：输入一个整数 n ，求 1 - n 这 n 个整数的十进制表示中 1 出现的次数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 解法一、不考虑时间效率，对每个数字都进行除法和求余</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberOf1Between1AndN_Solution</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="comment">// write code here</span></div><div class="line">    <span class="keyword">var</span> counts,num;</div><div class="line">    counts = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</div><div class="line">        num = i;</div><div class="line">       <span class="comment">//num = num%10;</span></div><div class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(num%<span class="number">10</span> == <span class="number">1</span>)&#123;</div><div class="line">                counts++;</div><div class="line">            &#125;</div><div class="line">            num = <span class="built_in">Math</span>.floor(num/<span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> counts;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 解法二、递归法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberOf1Between1AndN_Solution</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> high=n,low,temp,cur,num=<span class="number">0</span>,i=<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(high!=<span class="number">0</span>)&#123;</div><div class="line">      <span class="comment">// pow() 是 10 的 i 次方</span></div><div class="line">      <span class="comment">// parseInt() 是返回一个整数</span></div><div class="line">      <span class="comment">//  % 是求余数  / 是求余数</span></div><div class="line">        high = <span class="built_in">parseInt</span>(n/<span class="built_in">Math</span>.pow(<span class="number">10</span>,i));</div><div class="line">        temp = n%<span class="built_in">Math</span>.pow(<span class="number">10</span>,i);</div><div class="line">        cur = <span class="built_in">parseInt</span>(temp/<span class="built_in">Math</span>.pow(<span class="number">10</span>,i<span class="number">-1</span>));</div><div class="line">        low = temp%<span class="built_in">Math</span>.pow(<span class="number">10</span>,i<span class="number">-1</span>);</div><div class="line">        <span class="keyword">if</span>(cur ===<span class="number">1</span>)&#123;</div><div class="line">            num += high*<span class="built_in">Math</span>.pow(<span class="number">10</span>,i<span class="number">-1</span>) + low + <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; <span class="number">1</span>)&#123;</div><div class="line">            num += high*<span class="built_in">Math</span>.pow(<span class="number">10</span>,i<span class="number">-1</span>);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            num += (high+<span class="number">1</span>)*<span class="built_in">Math</span>.pow(<span class="number">10</span>,i<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？</p><blockquote><p>三十三、 丑数 p240</p></blockquote><p><strong>描述</strong>：把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function GetUglyNumber_Solution(index)&#123;</div><div class="line">    if(index == <span class="number">0</span>)&#123;</div><div class="line">        return <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">   <span class="comment">//two，three，five分别为三个队列的指针，uglyArr为从队列头选出来的最小数</span></div><div class="line">    var uglyArr = [<span class="number">1</span>],</div><div class="line">        two = <span class="number">0</span>,</div><div class="line">        three = <span class="number">0</span>,</div><div class="line">        five = <span class="number">0</span>;</div><div class="line">    for(var i=<span class="number">1</span>;i&lt;index;i++)&#123;</div><div class="line">       <span class="comment">//选出三个队列头最小的数【？？？？？？？？？？？？？？？？？？？？？？？</span></div><div class="line">        uglyArr[i] = Math.min(uglyArr[two]*<span class="number">2</span>,uglyArr[three]*<span class="number">3</span>,uglyArr[five]*<span class="number">5</span>);</div><div class="line">      <span class="comment">//这三个if有可能进入一个或者多个，进入多个是三个队列头最小的数有多个的情况</span></div><div class="line">        if(uglyArr[i]==uglyArr[two]*<span class="number">2</span>)two++;</div><div class="line">        if(uglyArr[i]==uglyArr[three]*<span class="number">3</span>)three++;</div><div class="line">        if(uglyArr[i]==uglyArr[five]*<span class="number">5</span>)five++;</div><div class="line">    &#125;</div><div class="line">    return uglyArr[index<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？</p><blockquote><p>三十四、第一个只出现一次的字符 p243</p></blockquote><p><strong>描述</strong>：在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(str)</span>&#123;</span></div><div class="line">    <span class="keyword">for</span>(<span class="built_in">let</span> i=<span class="number">0</span>; i &lt; <span class="built_in">str</span>.length; i++)&#123;</div><div class="line">    <span class="comment">// indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。</span></div><div class="line">    <span class="comment">// lastIndexOf() 方法可返回一个字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</span></div><div class="line">    <span class="keyword">if</span>(<span class="built_in">str</span>.indexOf(<span class="built_in">str</span>[i]) == <span class="built_in">str</span>.lastIndexOf(<span class="built_in">str</span>[i]))&#123;</div><div class="line">      return i;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：</p><blockquote><p>四十一、和为S的连续正数序列 p282</p></blockquote><p><strong>描述</strong>：输入一个整数 s，打印出所有和为 s 的连续正整数序列（至少含有两个数）。比如输入15，由于 1+2+3+4+5 = 4+5+6 =7+8 = 15,所以连续序列为 1-5,4-6,7-8.<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindContinuousSequence</span><span class="params">(sum)</span>&#123;</span></div><div class="line">    var start = <span class="number">1</span>, <span class="comment">// 相当于两个指针吧，小的为 1, 大的为2</span></div><div class="line">        <span class="keyword">end</span> = <span class="number">2</span>;</div><div class="line">    var sumTemp = <span class="number">0</span>;</div><div class="line">    var array = [<span class="number">1</span>,<span class="number">2</span>];</div><div class="line">    var ans = [];</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">sum</span> &lt; <span class="number">3</span>) <span class="keyword">return</span> [];</div><div class="line">    <span class="comment">// Math.ceil() 返回大于或等于一个给定数字的最小整数。</span></div><div class="line">    <span class="keyword">while</span> (start &lt;= Math.<span class="built_in">ceil</span>(<span class="built_in">sum</span> / <span class="number">2</span>)) &#123;</div><div class="line">        sumTemp = (start + <span class="keyword">end</span>) * (<span class="keyword">end</span> - start + <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">        <span class="comment">// 实际值 等于 目标值 时</span></div><div class="line">        <span class="keyword">if</span>(sumTemp == <span class="built_in">sum</span>) &#123;</div><div class="line">            ans.push(array.concat());</div><div class="line">            array.shift();</div><div class="line">            start++;</div><div class="line">            <span class="keyword">end</span>++;</div><div class="line">            array.push(<span class="keyword">end</span>);</div><div class="line">            <span class="comment">// 实际值 大于 目标值 时，小指针增加</span></div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sumTemp &gt; <span class="built_in">sum</span>) &#123;</div><div class="line">            array.shift();</div><div class="line">            start++;</div><div class="line">            <span class="comment">// 实际值 小于 目标值时，大指针增加</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">end</span>++;</div><div class="line">            array.push(<span class="keyword">end</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？？</p><blockquote><p>四十二、和为S的两个数字 p280</p></blockquote><p><strong>描述</strong>：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 和上面一样，用两个指针</div><div class="line">function <span class="type">FindNumbersWithSum</span>(<span class="built_in">array</span>, sum)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>.length&lt;<span class="number">2</span>) <span class="keyword">return</span> [];</div><div class="line">    <span class="keyword">var</span> <span class="literal">result</span>=[];</div><div class="line">    <span class="keyword">var</span> start=<span class="number">0</span>,<span class="keyword">end</span>=<span class="built_in">array</span>.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(start&lt;<span class="keyword">end</span>)&#123;</div><div class="line">        <span class="keyword">var</span> s=<span class="built_in">array</span>[start]+<span class="built_in">array</span>[<span class="keyword">end</span>];</div><div class="line">        <span class="keyword">if</span>(s&lt;sum)&#123;</div><div class="line">            start++</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s&gt;sum)&#123;</div><div class="line">            <span class="keyword">end</span>--;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> [<span class="built_in">array</span>[start],<span class="built_in">array</span>[<span class="keyword">end</span>]]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？</p><blockquote><p>四十三、翻转单词顺序列 p284</p></blockquote><p><strong>描述</strong>：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字幕一样处理。例如输入字符串“ I am a student”,输出为 “student a am I”<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function ReverseSentence(<span class="built_in">str</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">" "</span>).<span class="built_in">reverse</span>().<span class="built_in">join</span>(<span class="string">" "</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：第一步是按照空格分开，第二步是<code>reverse()</code>是将倒数第一个变成第一个，第三步是将数组转换为字符串</p><blockquote><p>四十七、求1+2+3+…+n p307</p></blockquote><p><strong>描述</strong>：求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法一：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum_Solution</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="number">1</span>+n)*n/<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方法二：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum_Solution</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> res = n;</div><div class="line">    (n&gt;<span class="number">0</span>)&amp;&amp;(res += Sum_Solution(n<span class="number">-1</span>));</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方法三：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum_Solution</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.ceil((<span class="built_in">Math</span>.pow(n,<span class="number">2</span>) + n)/<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？</p><blockquote><p>四十八、不用加减乘除做加法 p310</p></blockquote><p><strong>描述</strong>：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span><span class="params">(num1, num2)</span></span>&#123;</div><div class="line">  <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">var</span> temp = num1 ^ num2; <span class="comment">// 不考虑进位对每一位都相加 (^ 出现 1 时返回 1)</span></div><div class="line">    <span class="keyword">var</span> num2=(num1 &amp; num2)&lt;&lt;<span class="number">1</span>;<span class="comment">// 先做位与运算，再向左移一位（&amp; 都为 1 时返回 1）</span></div><div class="line">    num1 = temp; <span class="comment">// 重复前两步</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> num1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？</p><blockquote><p>五十二、正则表达式匹配 p124</p></blockquote><p><strong>描述</strong>：请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//s, pattern都是字符串</span></div><div class="line"><span class="comment">// 方法一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params">s, pattern</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^'</span>+pattern +<span class="string">'$'</span>,<span class="string">'g'</span>);</div><div class="line">  <span class="keyword">return</span> reg.test(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 方法二</div><div class="line"><span class="keyword">function</span> match(s, pattern)&#123;</div><div class="line">    <span class="keyword">if</span>(s != '' &amp;&amp; pattern == '')&#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</div><div class="line">    <span class="keyword">if</span>(s == '' &amp;&amp; pattern == '')&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</div><div class="line">    var sIndex =<span class="number">0</span>;</div><div class="line">    var pIndex =<span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> match_di(s,pattern,<span class="number">0</span>,<span class="number">0</span>)</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> match_di(s,p,si,<span class="literal">pi</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(si == s.length &amp;&amp; p.length == <span class="literal">pi</span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</div><div class="line">    <span class="keyword">if</span>(si != s.length &amp;&amp; p.length == <span class="literal">pi</span> )&#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;;</div><div class="line">    //第一个字符匹配，第二个字符时“*”</div><div class="line">    <span class="keyword">if</span>(<span class="literal">pi</span>+<span class="number">1</span> &lt; p.length &amp;&amp; p[<span class="literal">pi</span> +<span class="number">1</span> ] == <span class="string">"*"</span>)&#123;</div><div class="line">        <span class="keyword">if</span>( si != s.length &amp;&amp; ( s[si] == p[<span class="literal">pi</span>] || p[<span class="literal">pi</span>] == <span class="string">'.'</span>))&#123;</div><div class="line">       <span class="keyword">return</span> match_di(s,p,si,<span class="literal">pi</span>+<span class="number">2</span>) || match_di(s,p,si+<span class="number">1</span>,<span class="literal">pi</span>+<span class="number">2</span>) || match_di(s,p,si+<span class="number">1</span>,<span class="literal">pi</span>)</div><div class="line">       &#125;<span class="keyword">else</span>&#123;</div><div class="line">           <span class="keyword">return</span> match_di(s,p,si,<span class="literal">pi</span>+<span class="number">2</span>)</div><div class="line">       &#125;</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s!=s.length &amp;&amp; <span class="literal">pi</span> != p.length &amp;&amp; ( s[si] == p[<span class="literal">pi</span>] || p[<span class="literal">pi</span>] == <span class="string">'.'</span>))&#123;</div><div class="line">        <span class="keyword">return</span> match_di(s,p,si+<span class="number">1</span>,<span class="literal">pi</span>+<span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>思路</strong>：<br>解这题需要把题意仔细研究清楚，反正我试了好多次才明白的。<br>首先，考虑特殊情况：<br>1&gt;两个字符串都为空，返回true<br>2&gt;当第一个字符串不空，而第二个字符串空了，返回false（因为这样，就无法<br>匹配成功了,而如果第一个字符串空了，第二个字符串非空，还是可能匹配成<br>功的，比如第二个字符串是“a<em>a</em>a<em>a</em>”,由于‘<em>’之前的元素可以出现0次，<br>所以有可能匹配成功）<br>之后就开始匹配第一个字符，这里有两种可能：匹配成功或匹配失败。但考虑到pattern<br>下一个字符可能是‘</em>’， 这里我们分两种情况讨论：pattern下一个字符为‘<em>’或<br>不为‘</em>’：<br>1&gt;pattern下一个字符不为‘<em>’：这种情况比较简单，直接匹配当前字符。如果<br>匹配成功，继续匹配下一个；如果匹配失败，直接返回false。注意这里的<br>“匹配成功”，除了两个字符相同的情况外，还有一种情况，就是pattern的<br>当前字符为‘.’,同时str的当前字符不为‘\0’。<br>2&gt;pattern下一个字符为‘</em>’时，稍微复杂一些，因为‘<em>’可以代表0个或多个。<br>这里把这些情况都考虑到：<br>a&gt;当‘</em>’匹配0个字符时，str当前字符不变，pattern当前字符后移两位，<br>跳过这个‘<em>’符号；<br>b&gt;当‘</em>’匹配1个或多个时，str当前字符移向下一个，pattern当前字符<br>不变。（这里匹配1个或多个可以看成一种情况，因为：当匹配一个时，<br>由于str移到了下一个字符，而pattern字符不变，就回到了上边的情况a；<br>当匹配多于一个字符时，相当于从str的下一个字符继续开始匹配）<br>之后再写代码就很简单了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【&lt;a href=&quot;https://github.com/wangsiyuan233/NowCoder&quot;&gt;源码地址&lt;/a&gt;】 || 【&lt;a href=&quot;https://www.nowcoder.com/ta/coding-interviews?page=1&quot;&gt;代码调试&lt;/a&gt;】&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;十一、二进制中1的个数 p100&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：常规解法&lt;/strong&gt;&lt;br&gt;1、怎样判断一个整数的最右边是不是1&lt;br&gt;2、把整数和1做【位与运算】，看结果是不是0就知道了。&lt;br&gt;3、如果结果是1，那最右边的一位就是1&lt;br&gt;4、bug就是不能分析出来负数，会陷入死循环&lt;br&gt;&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function NumberOf1(n)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  var &lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;flag&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;flag&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n&amp;amp;&lt;span class=&quot;built_in&quot;&gt;flag&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;flag&lt;/span&gt; = &lt;span class=&quot;built_in&quot;&gt;flag&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  return &lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二：高级解法&lt;/strong&gt;&lt;br&gt;1、如果一个整数不为0，那么这个整数至少有一位是1。&lt;br&gt;如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。&lt;br&gt;其余所有位将不会受到影响。&lt;/p&gt;
&lt;p&gt;2、举个例子：一个二进制数 &lt;code&gt;1100&lt;/code&gt;，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是 &lt;code&gt;1011&lt;/code&gt;.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如&lt;code&gt;1100&amp;amp;1011=1000&lt;/code&gt;.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。&lt;br&gt;&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function NumberOf1(&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  while (&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt; = (&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;amp;&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt;;//把最右边的一个&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;变成&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  return &lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="wangsiyuan233.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer(3)--数组篇(JavaScript版)/共 题</title>
    <link href="wangsiyuan233.github.io/2018/10/06/78%E5%89%91%E6%8C%87-%E6%95%B0%E7%BB%84%E7%AF%87/"/>
    <id>wangsiyuan233.github.io/2018/10/06/78剑指-数组篇/</id>
    <published>2018-10-06T11:52:54.000Z</published>
    <updated>2018-10-07T03:12:57.007Z</updated>
    
    <content type="html"><![CDATA[<p>【<a href="https://github.com/wangsiyuan233/NowCoder" target="_blank" rel="external">源码地址</a>】 || 【<a href="https://www.nowcoder.com/ta/coding-interviews?page=1" target="_blank" rel="external">代码调试</a>】</p><hr><blockquote><p>一、 二维数组中的查找 p44</p></blockquote><p><strong>描述</strong>：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span><span class="params">(target, array)</span> </span>&#123;</div><div class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;<span class="comment">// column 竖列</span></div><div class="line">  <span class="keyword">let</span> j = <span class="keyword">array</span>[i].length - <span class="number">1</span>; <span class="comment">// row 横行</span></div><div class="line">  <span class="keyword">while</span> (i &lt; <span class="keyword">array</span>.length &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">array</span>[i][j] &lt; target) &#123;</div><div class="line">      i++;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">array</span>[i][j] &gt; target)&#123;</div><div class="line">      j--;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？<br><a id="more"></a></p><blockquote><p>六、旋转数组的最小数字 p82</p></blockquote><p><strong>描述</strong>：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用二分查找</span></div><div class="line">function minNumberInRotateArray(arr)&#123;</div><div class="line">  <span class="keyword">let</span> len = arr.length;</div><div class="line">  <span class="keyword">if</span>(len == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="comment">// 两个指针，最左边和最右边，此时第一个元素应该是大于最后一个元素的（没有重复的元素）。</span></div><div class="line">  <span class="keyword">let</span> <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = len - <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;</div><div class="line"><span class="comment">//Math.floor() 返回小于或等于一个给定数字的最大整数。</span></div><div class="line">  <span class="keyword">let</span> mid = <span class="keyword">left</span> + <span class="type">Math</span>.floor((<span class="keyword">right</span>-<span class="keyword">left</span>)/<span class="number">2</span>);</div><div class="line"><span class="comment">//中间元素大于最后一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素的后一个元素。</span></div><div class="line">  <span class="keyword">if</span>(arr[mid] &gt; arr[<span class="keyword">right</span>])&#123;</div><div class="line">    <span class="keyword">left</span> = mid + <span class="number">1</span>;</div><div class="line"><span class="comment">// 中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面</span></div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] == arr[<span class="keyword">right</span>])&#123;</div><div class="line">      <span class="keyword">right</span> = <span class="keyword">right</span> - <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">right</span> = mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr[<span class="keyword">left</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、这题直接用<code>math.min.apply(null,arr)</code>特没劲儿，时间也是最长的，要用二分查找法<br>2、总结 <code>math.min</code> 是取最小值，但是它是一个一个数字的取，并不能支持数组<br>3、所以 <code>apply</code> 的第一个参数是什么根本不重要，重要的是为了把第二个参数（设置为数组）传进去，找到了最小数，就把他们搬到数组的头部</p><blockquote><p>十三、调整数组顺序使奇数位于偶数前面 p129</p></blockquote><p><strong>描述</strong>：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function reOrderArray(<span class="built_in">array</span>)&#123;</div><div class="line">    <span class="built_in">var</span> arr1=[],arr2=[];</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.<span class="built_in">length</span>;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i]<span class="symbol">%</span><span class="number">2</span>!=<span class="number">0</span>)&#123;</div><div class="line">          arr1.<span class="built_in">push</span>(<span class="built_in">array</span>[i]);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">          arr2.<span class="built_in">push</span>(<span class="built_in">array</span>[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> arr1.<span class="built_in">concat</span>(arr2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：BUG题/设置两个空数组，<code>push() + concat()</code></p><blockquote><p>二十八、数组中出现次数超过一半的数字 p205</p></blockquote><p><strong>描述</strong>：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(numbers)</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [],</div><div class="line">        len = numbers.length,</div><div class="line">        a;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">        a = numbers[i];</div><div class="line">        <span class="keyword">if</span>(arr[a])&#123;</div><div class="line">          <span class="comment">// 如果下一个数字和之前保存的数字相同，就 + 1</span></div><div class="line">            arr[a]++;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">          <span class="comment">// 如果下一个数字和之前保存的数字相同，就 为 1</span></div><div class="line">            arr[a] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">      <span class="comment">// 如果这个数超过了一半 ，就返回这个数</span></div><div class="line">        <span class="keyword">if</span>(arr[i] &gt; len/<span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p><blockquote><p>三十、连续子数组的最大和 p281</p></blockquote><p><strong>描述</strong>：输入一个整型数组，数组里有整数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function FindGreatestSumOfSubArray(<span class="built_in">array</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>.<span class="built_in">length</span> &lt; <span class="number">0</span>) <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="built_in">var</span> len = <span class="built_in">array</span>.<span class="built_in">length</span>,</div><div class="line">        <span class="built_in">sum</span> = <span class="built_in">array</span>[<span class="number">0</span>],//记录当前所有子数组的和的最大值</div><div class="line">        temp = <span class="built_in">array</span>[<span class="number">0</span>]; //包含<span class="built_in">array</span>[i]的连续数组最大值</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">var</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</div><div class="line">      // 当连续数组小于 <span class="number">0</span> 时，之前的累加被抛弃，从现在开始算起</div><div class="line">      // 当连续数组大于 <span class="number">0</span> 时，继续累加</div><div class="line">      // 牛逼牛逼！</div><div class="line">        temp = (temp &lt; <span class="number">0</span>) ? <span class="built_in">array</span>[i] : temp + <span class="built_in">array</span>[i];</div><div class="line">      // 如果 连续数组 的值大一些，就取连续数组的值 作为 最后的值</div><div class="line">        <span class="built_in">sum</span> = (temp &gt; <span class="built_in">sum</span>) ? temp : <span class="built_in">sum</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="built_in">sum</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p><blockquote><p>三十二、把数组排成最小的数 p227</p></blockquote><p><strong>描述</strong>：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintMinNumber</span>(<span class="params">numbers</span>)</span>&#123;</div><div class="line">    numbers.sort(<span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">     num1 = num1.toString();</div><div class="line">     num2 = num2.toString();</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(num1+num2)&gt;<span class="built_in">parseInt</span>(num2+num1))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">    <span class="comment">// 通过空格分割字符串</span></div><div class="line">    <span class="keyword">return</span> numbers.join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：????</p><blockquote><p>三十五、数组中的逆序对 P249</p></blockquote><p><strong>描述</strong>：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span></span> InversePairs(<span class="keyword">data</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="comment">!data||data.length&lt;2) return 0;</span></div><div class="line"></div><div class="line">    var copy = <span class="keyword">data</span>.slice(),</div><div class="line">        <span class="built_in">count</span> = <span class="number">0</span>;</div><div class="line">    <span class="built_in">count</span> = mergeSort(<span class="keyword">data</span>,copy,<span class="number">0</span>,<span class="keyword">data</span>.length-<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">count</span>%<span class="number">1000000007</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span></span> mergeSort(<span class="keyword">data</span>,copy,start,<span class="keyword">end</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">end</span>===start) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    // <span class="number">14</span>（即二进制的 <span class="number">00001110</span>）左移两位等于 <span class="number">56</span>（即二进制的 <span class="number">00111000</span>）</div><div class="line">    // 所以我为什么需要右移一位呢？</div><div class="line">    var mid = (<span class="keyword">end</span>-start)&gt;&gt;<span class="number">1</span>,</div><div class="line">        left = mergeSort(copy,<span class="keyword">data</span>,start,start+mid),</div><div class="line">        right = mergeSort(copy,<span class="keyword">data</span>,start+mid+<span class="number">1</span>,<span class="keyword">end</span>),</div><div class="line">        <span class="built_in">count</span> = <span class="number">0</span>,</div><div class="line">        p = start+mid,//前一个数组的最后一个下标</div><div class="line">        q = <span class="keyword">end</span>,//后一个数组的最后一个下标</div><div class="line">        copyIndex = <span class="keyword">end</span>;//辅助数组下标，从最后一个算起</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p&gt;=start&amp;&amp;q&gt;=start+mid+<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">data</span>[p]&gt;<span class="keyword">data</span>[q])&#123;</div><div class="line">            <span class="built_in">count</span>+=q-start-mid;</div><div class="line">            copy[copyIndex--] = <span class="keyword">data</span>[p--];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            copy[copyIndex--] = <span class="keyword">data</span>[q--];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p&gt;=start)&#123;</div><div class="line">        copy[copyIndex--] = <span class="keyword">data</span>[p--];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(q&gt;=start+mid+<span class="number">1</span>)&#123;</div><div class="line">        copy[copyIndex--] = <span class="keyword">data</span>[q--];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> left+right+<span class="built_in">count</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：这题我实在做不到，已经看着发呆了好几个小时了，完全不行，放弃</p><blockquote><p>三十七、数字在排序数组中出现的次数 p263</p></blockquote><p><strong>描述</strong>：统计一个数字在排序数组中出现的次数。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span></span> GetNumberOfK(<span class="keyword">data</span>,k) &#123;</div><div class="line">   var <span class="built_in">count</span> =<span class="number">0</span>;</div><div class="line">    for(var i =<span class="number">0</span> ;i&lt;<span class="keyword">data</span>.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">data</span>[i]==k)&#123;</div><div class="line">            <span class="built_in">count</span>++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">count</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：看见有序就想到了二分查找法</p><blockquote><p>四十、数组中只出现一次的数字 p275</p></blockquote><p><strong>描述</strong>：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindNumsAppearOnce</span><span class="params">(array)</span></span>&#123;</div><div class="line">    <span class="comment">// return list, 比如[a,b]，其中ab是出现一次的两个数字</span></div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">array</span>.indexOf(<span class="keyword">array</span>[i]) === <span class="keyword">array</span>.lastIndexOf(<span class="keyword">array</span>[i])) &#123;</div><div class="line">            arr.push(<span class="keyword">array</span>[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方法二</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindNumsAppearOnce</span><span class="params">(array)</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> obj=&#123;&#125;; <span class="comment">// 为啥？</span></div><div class="line">    <span class="keyword">var</span> arr=[]; <span class="comment">// 为啥？</span></div><div class="line">    <span class="keyword">var</span> length=<span class="keyword">array</span>.length;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">array</span>[i] in obj)&#123;</div><div class="line">            obj[<span class="keyword">array</span>[i]]++;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            obj[<span class="keyword">array</span>[i]]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(attr in obj)&#123;</div><div class="line">        <span class="keyword">if</span>(obj[attr] == <span class="number">1</span>)&#123;</div><div class="line">            arr.push(attr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方法三、位运算</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindNumsAppearOnce</span><span class="params">(array)</span></span>&#123;</div><div class="line">    <span class="comment">// return list, 比如[a,b]，其中ab是出现一次的两个数字</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findFirst1</span><span class="params">(num)</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (((num &amp; <span class="number">1</span>) === <span class="number">0</span>) &amp;&amp; (index &lt; <span class="number">64</span>)) &#123;</div><div class="line">            num = num &gt;&gt; <span class="number">1</span>;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> index;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">is1</span><span class="params">(num, index)</span> </span>&#123;</div><div class="line">        num = num &gt;&gt; index;</div><div class="line">        <span class="keyword">return</span> num &amp; <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">Array</span>.isArray(<span class="keyword">array</span>)) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">array</span>.length &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> [];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> exclusive = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</div><div class="line">            exclusive ^= <span class="keyword">array</span>[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> indexOf1 = findFirst1(exclusive);</div><div class="line">        <span class="keyword">var</span> num1 = <span class="number">0</span>,</div><div class="line">            num2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (is1(<span class="keyword">array</span>[i], indexOf1)) &#123;</div><div class="line">                num1 ^= <span class="keyword">array</span>[i];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                num2 ^= <span class="keyword">array</span>[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> [num1, num2];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：放了三个我完全看不懂的方法，留给第三轮的自己。。呵呵</p><blockquote><p>四十五、扑克牌顺子 p298</p></blockquote><p><strong>描述</strong>：从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的，2-10为数字本身，大小王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsContinuous</span><span class="params">(numbers)</span></span>&#123;</div><div class="line">    <span class="comment">//思路：首先先排序，然后统计大小王个数，然后遍历，看缺多少个数才能连续，如果超过大小王个数则失败。</span></div><div class="line">    <span class="keyword">var</span> num_zero = <span class="number">0</span>;  <span class="comment">//王的数量</span></div><div class="line">    <span class="keyword">var</span> lack_number = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> sort_number = numbers.sort(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> a-b;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">if</span>(!numbers || numbers.length &lt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length<span class="number">-1</span>; i++) &#123;</div><div class="line">            <span class="comment">// 计算癞子数量</span></div><div class="line">            <span class="keyword">if</span> (numbers[i] == <span class="number">0</span>) &#123;</div><div class="line">                num_zero++;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 对子，直接返回</span></div><div class="line">            <span class="keyword">if</span> (numbers[i] == numbers[i + <span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            lack_number += numbers[i + <span class="number">1</span>] - numbers[i] - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> lack_number&lt;=num_zero;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？？</p><blockquote><p>五十、数组中重复的数字 p39</p></blockquote><p><strong>描述</strong>：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicate</span><span class="params">(numbers, duplication)</span></span>&#123;</div><div class="line">  <span class="comment">//这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></div><div class="line">  <span class="comment">//函数返回True/False</span></div><div class="line">  <span class="keyword">var</span> length = numbers.length;</div><div class="line">  <span class="keyword">var</span> obj=&#123;&#125;; <span class="comment">// 哈希表</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(numbers[i] <span class="keyword">in</span> obj)&#123;</div><div class="line">        duplication[<span class="number">0</span>]=numbers[i];</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        obj[numbers[i]]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：????</p><blockquote><p>五十一、构建乘积数组 p312</p></blockquote><p><strong>描述</strong>：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span><span class="params">(array)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(!<span class="keyword">array</span>||<span class="keyword">array</span>.length&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">var</span> len=<span class="keyword">array</span>.length;</div><div class="line">    <span class="keyword">var</span> b=[],c=[],d=[];</div><div class="line">    b[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="comment">//计算下三角连乘</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;i++)&#123;</div><div class="line">        b[i]=b[i<span class="number">-1</span>]*<span class="keyword">array</span>[i<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> temp=<span class="number">1</span>;</div><div class="line">    <span class="comment">//计算上三角</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">        temp*=<span class="keyword">array</span>[i+<span class="number">1</span>];</div><div class="line">        b[i]*=temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p><blockquote><p>六十四、滑动窗口的最大值 ？？？</p></blockquote><p><strong>描述</strong>：给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function maxInWindows(<span class="built_in">num</span>, size)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">num</span>.<span class="built_in">length</span>===<span class="number">0</span> || size===<span class="number">0</span>)&#123;<span class="built_in">return</span> [];&#125;</div><div class="line">    <span class="built_in">var</span> result=[];</div><div class="line">    <span class="built_in">var</span> count=<span class="built_in">num</span>.<span class="built_in">length</span>-size;</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">var</span> i=<span class="number">0</span>;i&lt;=count;i++)&#123;</div><div class="line">        <span class="built_in">var</span> temp=<span class="built_in">num</span>.slice(i,i+size);</div><div class="line">        result.<span class="built_in">push</span>(Math.<span class="built_in">max</span>.<span class="built_in">apply</span>(this,temp));</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【&lt;a href=&quot;https://github.com/wangsiyuan233/NowCoder&quot;&gt;源码地址&lt;/a&gt;】 || 【&lt;a href=&quot;https://www.nowcoder.com/ta/coding-interviews?page=1&quot;&gt;代码调试&lt;/a&gt;】&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;一、 二维数组中的查找 p44&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;br&gt;&lt;figure class=&quot;highlight zephir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Find&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(target, array)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// column 竖列&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; j = &lt;span class=&quot;keyword&quot;&gt;array&lt;/span&gt;[i].length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// row 横行&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; &lt;span class=&quot;keyword&quot;&gt;array&lt;/span&gt;.length &amp;amp;&amp;amp; j &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;array&lt;/span&gt;[i][j] &amp;lt; target) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      i++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;array&lt;/span&gt;[i][j] &amp;gt; target)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      j--;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：？？？&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="wangsiyuan233.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer(2)--二叉树篇(JavaScript版)/共 题</title>
    <link href="wangsiyuan233.github.io/2018/10/06/77%E5%89%91%E6%8C%87-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/"/>
    <id>wangsiyuan233.github.io/2018/10/06/77剑指-二叉树篇/</id>
    <published>2018-10-06T10:59:44.000Z</published>
    <updated>2018-10-09T09:51:09.890Z</updated>
    
    <content type="html"><![CDATA[<p>【<a href="https://github.com/wangsiyuan233/NowCoder" target="_blank" rel="external">源码地址</a>】 || 【<a href="https://www.nowcoder.com/ta/coding-interviews?page=1" target="_blank" rel="external">代码调试</a>】</p><hr><blockquote><p>四、 重建二叉树 p62/t4</p></blockquote><p><strong>描述</strong>：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reConstructBinaryTree</span><span class="params">(pre, vin)</span></span>&#123; <span class="comment">//pre 是前序遍历，vin 是中序遍历</span></div><div class="line">  <span class="comment">// null 是真正的空，[] 里面还有东西</span></div><div class="line">    <span class="keyword">var</span> result =<span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span>(pre.length&gt;<span class="number">1</span>)&#123;</div><div class="line">      <span class="keyword">var</span> root = pre[<span class="number">0</span>];</div><div class="line">      <span class="comment">// indexOf() 方法可返回某个指定的字符串值首次出现的位置。</span></div><div class="line">      <span class="comment">// 下面开始中序遍历</span></div><div class="line">      <span class="comment">// 找到根节点的位置</span></div><div class="line">      <span class="keyword">var</span> vinRootIndex = vin.indexOf(root);</div><div class="line">      <span class="comment">// 根节点的左边是左子树</span></div><div class="line">      <span class="keyword">var</span> vinLeft = vin.slice(<span class="number">0</span>,vinRootIndex);</div><div class="line">      <span class="comment">// 右边就是右子树</span></div><div class="line">      <span class="keyword">var</span> vinRight = vin.slice(vinRootIndex+<span class="number">1</span>,vin.length);</div><div class="line">      <span class="comment">// 下面开始前序遍历：</span></div><div class="line">      <span class="comment">// shift() 把数组的第一个元素从其中删除，并返回第一个元素的值</span></div><div class="line">      <span class="comment">// 取走第一个数</span></div><div class="line">      pre.shift();</div><div class="line">      <span class="comment">// 此时的第一个数是左子树的第一个数</span></div><div class="line">      <span class="keyword">var</span> preLeft = pre.slice(<span class="number">0</span>,vinLeft.length);</div><div class="line">      <span class="keyword">var</span> preRight = pre.slice(vinLeft.length,pre.length);</div><div class="line">      result=&#123;</div><div class="line">        val:root,</div><div class="line">        left:reConstructBinaryTree(preLeft,vinLeft),</div><div class="line">        right:reConstructBinaryTree(preRight,vinRight)</div><div class="line">      &#125;</div><div class="line">    <span class="comment">// 二叉树只有一个元素</span></div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre.length ===<span class="number">1</span>)&#123;</div><div class="line">        result= &#123;</div><div class="line">            val :pre[<span class="number">0</span>],</div><div class="line">            left:<span class="literal">null</span>,</div><div class="line">            right:<span class="literal">null</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、函数里面的参数 <code>pre</code> 是前序遍历，<code>vin</code> 是中序遍历；<br>2、第一步我们进行的是中序遍历：<br>3、前序的第一个点就是根节点，用 <code>indexOf</code> 找到根节点的位置；<br>4、中序遍历中，根节点前面就是左子树，根节点后面就是右子树<br>5、第二步我们开始前序遍历：<br>6、取出根节点！很重要<br>7、用中序遍历中左子树<strong>的长度</strong>，可以知道前序遍历的左子树<br>8、同理可以得到前序遍历的右子树<br>9、第三步就是 <strong>递归</strong><br>10、你不是让我重构这个二叉树吗？OK，我的整体左子树也有小左子树和小右子树啊<br>11、这个时候，“根节点”变了，逻辑却没变，还是用开始的大函数。<br>12、重建的二叉树也是数组<br><a id="more"></a></p><blockquote><p>十七、树的子结构 p148/t17</p></blockquote><p><strong>描述</strong>：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function HasSubtree(pRoot1, pRoot2)&#123; <span class="comment">// 大树和小树</span></div><div class="line">   <span class="comment">//当 大树 和 小树 都为零的时，直接返回false</span></div><div class="line">   <span class="keyword">if</span> (pRoot1 == <span class="literal">null</span> || pRoot2 == <span class="literal">null</span>)&#123;</div><div class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">   &#125;<span class="comment">// 第一步：查找大小树是否有一样的根节点值（三个情况是 或 关系，满足其一便可）</span></div><div class="line">   <span class="comment">// 第一种情况是：根节点相同，调用isSubtree()</span></div><div class="line">    <span class="keyword">return</span> isSubtree(pRoot1, pRoot2)</div><div class="line">    <span class="comment">//第二种情况是：大树的左边和小树结构一样</span></div><div class="line">        || HasSubtree(pRoot1.left, pRoot2)</div><div class="line">    <span class="comment">//第三种情况是：大树的右边和小树的结构一样</span></div><div class="line">        || HasSubtree(pRoot1.right, pRoot2);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 下面要详细分析一下第一种情况</span></div><div class="line">function isSubtree(root1, root2)&#123;<span class="comment">// 大树和小树</span></div><div class="line">    <span class="comment">// 第一个 if 和第二个 if 的顺序还不能颠倒</span></div><div class="line"></div><div class="line">    <span class="comment">//如果小树已经遍历完了，无论大树有没有遍历完，小的都在大的里面 （？？？</span></div><div class="line">    <span class="keyword">if</span> (root2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="comment">//如果小树还没有遍历完，大树却遍历完了。返回false</span></div><div class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">      <span class="comment">//如果找到了对应小树的根节点的点</span></div><div class="line">    <span class="keyword">if</span> (root1.<span class="keyword">val</span> == root2.<span class="keyword">val</span>) &#123;</div><div class="line">      <span class="comment">//以这个根节点为起点判断大树是否包含小树</span></div><div class="line">      <span class="comment">// 如果有相同的根节点，就递归判断下面的 子树 是不是也相等</span></div><div class="line">        <span class="keyword">return</span> isSubtree(root1.left, root2.left)</div><div class="line">          &amp;&amp; isSubtree(root1.right, root2.right);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// ???</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、在大树里找到小树的根节点；<br>2、再判断他们下面的结构是不是一样的<br>3、<code>function isSubtree(root1, root2)</code> 里面的头两个 if 语句，不明白？？</p><blockquote><p>十八、二叉树的镜像 p157/t18</p></blockquote><p><strong>描述</strong>：操作给定的二叉树，将其变换为源二叉树的镜像。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function <span class="type">Mirror</span>(root)&#123;</div><div class="line">    <span class="keyword">if</span>(root == null)&#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 下面这个是左右手交换的意思吧</span></div><div class="line">    <span class="keyword">var</span> temp=root.<span class="keyword">left</span>;</div><div class="line">    root.<span class="keyword">left</span>=root.<span class="keyword">right</span>;</div><div class="line">    root.<span class="keyword">right</span>=temp;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(root.<span class="keyword">left</span>) <span class="type">Mirror</span>(root.<span class="keyword">left</span>);</div><div class="line">    <span class="keyword">if</span>(root.<span class="keyword">right</span>) <span class="type">Mirror</span>(root.<span class="keyword">right</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、前序遍历首先访问 根结点 然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树；<br>2、交换左右手<br>3、还是递归</p><blockquote><p>五十九、按之字形顺序打印二叉树 p176/t59</p></blockquote><p><strong>描述</strong>：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Print</span><span class="params">(pRoot)</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> lists=<span class="keyword">new</span> <span class="keyword">Array</span>();<span class="comment">//存放结果</span></div><div class="line">    <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> lists;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> stack1=[];<span class="comment">//存放奇数行</span></div><div class="line">    <span class="keyword">var</span> stack2=[];<span class="comment">//存放偶数行</span></div><div class="line">    stack1.push(pRoot);</div><div class="line">    <span class="keyword">var</span> i=<span class="number">1</span>;<span class="comment">//层数</span></div><div class="line">    <span class="keyword">while</span>(stack1.length!=<span class="number">0</span> || stack2.length!=<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">var</span> <span class="keyword">list</span>=<span class="keyword">new</span> <span class="keyword">Array</span>();</div><div class="line">        <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;<span class="comment">//当是奇数行的时候</span></div><div class="line">            <span class="keyword">while</span>(stack1.length!=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">var</span> temp=stack1[stack1.length<span class="number">-1</span>];<span class="comment">//用一数组记录下，一直是从后往前push的</span></div><div class="line">            <span class="keyword">list</span>.push(temp.val);</div><div class="line">            stack1.pop();</div><div class="line">            <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</div><div class="line">               <span class="comment">//把下一行（偶数行）的数保存在stack2中，因为是从右往左，所以在栈中先添加左子节点</span></div><div class="line">                stack2.push(temp.left);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</div><div class="line">                stack2.push(temp.right);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//当是偶数行的时候</span></div><div class="line">            <span class="keyword">while</span>(stack2.length!=<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">var</span> temp=stack2[stack2.length<span class="number">-1</span>];</div><div class="line">                <span class="keyword">list</span>.push(temp.val);</div><div class="line">                stack2.pop();</div><div class="line">                <span class="comment">//因为奇数行是从左往右打印，所以在栈中先添加右子节点再添加左子节点</span></div><div class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</div><div class="line">                    stack1.push(temp.right);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</div><div class="line">                    stack1.push(temp.left);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        i++;</div><div class="line">        lists.push(<span class="keyword">list</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> lists;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、<code>reverse()</code>效率太低了，会被鄙视；<br>2、之字形打印需要两个栈<br>3、我们在打印某一层节点时，把下一层节点保存到相应的栈里面；<br>4、栈的特点是知道的吧，先从栈顶开始打印，也就是说，先打印的在栈顶</p><blockquote><p>六十、把二叉树打印成多行 p174/t60</p></blockquote><p><strong>描述</strong>：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function Print(pRoot)&#123;</div><div class="line">   var queue = [],</div><div class="line">       resultArr = [],</div><div class="line">       itemArr = []<span class="comment">;</span></div><div class="line"></div><div class="line">   if (pRoot == null) &#123;</div><div class="line">       return resultArr<span class="comment">;</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   queue.push(pRoot)<span class="comment">;</span></div><div class="line">   var nextLevelLen = <span class="number">0</span>,</div><div class="line">       <span class="keyword">waitPrint </span>= <span class="number">1</span><span class="comment">;</span></div><div class="line"></div><div class="line">   while (queue.length != <span class="number">0</span>) &#123;</div><div class="line">       var inode = queue[<span class="number">0</span>]<span class="comment">;</span></div><div class="line">       itemArr.push(inode.val)<span class="comment">;</span></div><div class="line"></div><div class="line">       if (inode.left != null) &#123;</div><div class="line">           queue.push(inode.left)<span class="comment">;</span></div><div class="line">           nextLevelLen ++<span class="comment">;</span></div><div class="line">       &#125;</div><div class="line">       if (inode.right != null) &#123;</div><div class="line">           queue.push(inode.right)<span class="comment">;</span></div><div class="line">           nextLevelLen ++<span class="comment">;</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       queue.<span class="keyword">shift();</span></div><div class="line">       <span class="keyword">waitPrint </span>--<span class="comment">;</span></div><div class="line">       if (<span class="keyword">waitPrint </span>== <span class="number">0</span>) &#123;</div><div class="line">           resultArr.push(itemArr)<span class="comment">;</span></div><div class="line">           itemArr = []<span class="comment">;</span></div><div class="line">           <span class="keyword">waitPrint </span>= nextLevelLen<span class="comment">; // 下一行待打印的个数初始化为所有的结点个数</span></div><div class="line">           nextLevelLen = <span class="number">0</span><span class="comment">; // 重新统计在再一行应该有的结点个数</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   return resultArr<span class="comment">;</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p><blockquote><p>二十二、从上往下打印二叉树 p171/t22</p></blockquote><p><strong>描述</strong>：从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function PrintFromTopToBottom(root)&#123;</div><div class="line">    var <span class="attr">arr=</span>[];</div><div class="line">    var <span class="attr">data=</span>[];</div><div class="line">    if(root!=null)&#123;</div><div class="line">      // 空数组后面首先跟着的是 根节点</div><div class="line">        arr.push(root);</div><div class="line">    &#125;</div><div class="line">    while(arr.length!=<span class="number">0</span>)&#123;</div><div class="line">      // <span class="keyword">node</span> <span class="title">是节点，root</span> 是根节点</div><div class="line">        var <span class="keyword">node</span><span class="title">=arr</span>.shift();</div><div class="line">        // 第一元素的左子树不为空时，把左子树加在 arr 后面</div><div class="line">        if(<span class="keyword">node</span>.<span class="title">left</span>!=null)&#123;</div><div class="line">            arr.push(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">        &#125;</div><div class="line">        if(<span class="keyword">node</span>.<span class="title">right</span>!=null)&#123;</div><div class="line">            arr.push(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">        &#125;</div><div class="line">        // 首先取得了 arr 的第一个节点 <span class="keyword">node</span><span class="title">，接着是 左子节点 ，最后是右子节点</span></div><div class="line">        // 这个过程是循环的，不断的是 首 -- 左 -- 右</div><div class="line">        data.push(<span class="keyword">node</span>.<span class="title">val</span>);</div><div class="line">    &#125;</div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、首先判断左子树是存在的吗？如果存在，就添加到 <code>arr</code> 里面<br>2、此时 <code>arr</code> 里面有 <code>root、node</code> 和左子树<br>3、但是下一步就要判断右子树了，如果右子树存在，就添加到 arr 里面；<br>4、此时 <code>arr</code> 里面有 <code>root</code>、<code>node</code>、左子树 和 右子树了（同一层）<br>5、开始下一层<br>6、引申一下：打印前序遍历会吗？中序会吗？</p><blockquote><p>二十三、二叉搜索树的后序遍历序列 p179/t23</p></blockquote><p><strong>描述</strong>：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> VerifySquenceOfBST(<span class="keyword">sequence</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">sequence</span>==<span class="literal">null</span>||<span class="keyword">sequence</span><span class="variable">.length</span>&lt;=<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> false;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Verify(<span class="keyword">sequence</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> Verify(<span class="keyword">sequence</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">sequence</span><span class="variable">.length</span>&lt;=<span class="number">3</span>)&#123;</div><div class="line">        <span class="keyword">return</span> true;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> root=<span class="keyword">sequence</span>[<span class="keyword">sequence</span><span class="variable">.length</span>-<span class="number">1</span>];<span class="comment">//根节点</span></div><div class="line">    <span class="keyword">var</span> left=[];</div><div class="line">    <span class="keyword">var</span> right=[];</div><div class="line"></div><div class="line">    <span class="comment">// 左子树小于根节点</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sequence</span><span class="variable">.length</span>; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">sequence</span>[i]&gt;=root)&#123;<span class="comment">//[0,i-1]就是左子树，[i,length-1]右子树</span></div><div class="line">            left=<span class="keyword">sequence</span><span class="variable">.slice</span>(<span class="number">0</span>,i);<span class="comment">// 这里没有 i</span></div><div class="line">            right=<span class="keyword">sequence</span><span class="variable">.slice</span>(i,<span class="keyword">sequence</span><span class="variable">.length</span>-<span class="number">1</span>);<span class="comment">//注意slice是左闭右开</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">if</span>(right<span class="variable">.length</span>===<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 右子树大于根节点</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=i;j&lt;<span class="keyword">sequence</span><span class="variable">.length</span>-<span class="number">1</span>;j++)&#123; <span class="comment">//刚开始写的right.length</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">sequence</span>[j]&lt;root)&#123; <span class="comment">//不是right[j]而是sequence[j];</span></div><div class="line">            <span class="keyword">return</span> false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">var</span> leftResult = Verify(left);</div><div class="line">    <span class="keyword">var</span> rightResult = Verify(right);</div><div class="line">    <span class="keyword">return</span> leftResult &amp;&amp; rightResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、二叉查找(搜索)树（BST：Binary Search Tree）是一种特殊的二叉树；<br>2、对于任意一个节点 n，其左子树下的每个后代节点的值都小于节点 n 的值；<br>3、其右子树下的每个后代节点的值都大于节点 n 的值；<br>4、为什么需要引入 j？</p><blockquote><p>二十四、二叉树中和为某一值的路径 p182/t24</p></blockquote><p><strong>描述</strong>：输入一颗二叉树的根节点和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindPath</span><span class="params">(root, expectNumber)</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> [];</div><div class="line">    &#125;</div><div class="line">    dfsFind(root, expectNumber, [], <span class="number">0</span>, result);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsFind</span><span class="params">(root, expectNumber, path, currentSum, result)</span> </span>&#123;</div><div class="line">    <span class="comment">//前序遍历二叉树，每次更新当前路径的和 currentSum；</span></div><div class="line">    currentSum += root.val;</div><div class="line">    path.push(root.val);</div><div class="line"></div><div class="line">    <span class="comment">//判断 currentSum 是否等于 expectNumber,以及 当前结点是否是叶子结点。如果是，把当前路径保存在 result 结果中；</span></div><div class="line">    <span class="keyword">if</span> (currentSum == expectNumber &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</div><div class="line">        result.push(path.slice(<span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</div><div class="line">        dfsFind(root.left, expectNumber, path, currentSum, result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</div><div class="line">        dfsFind(root.right, expectNumber, path, currentSum, result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这一步很关键，把所有push进去的每一个元素在递归执行完成之时都弹出来，使得stack每次都是重头来过</span></div><div class="line">    path.pop();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？？</p><blockquote><p>二十六、二叉搜索树与双向链表 p191/t26</p></blockquote><p><strong>描述</strong>：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function <span class="type">Convert</span>(pRootOfTree)&#123;</div><div class="line">    <span class="keyword">if</span>(pRootOfTree == null)&#123;<span class="keyword">return</span> null;&#125;</div><div class="line">    <span class="keyword">if</span>(pRootOfTree.<span class="keyword">right</span> == null &amp;&amp; pRootOfTree.<span class="keyword">left</span> == null) &#123;</div><div class="line">      <span class="keyword">return</span> pRootOfTree;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 1.将左子树构造成双链表，并返回链表头节点</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">left</span> = <span class="type">Convert</span>(pRootOfTree.<span class="keyword">left</span>);</div><div class="line">    <span class="keyword">var</span> p =<span class="keyword">left</span>;</div><div class="line">    <span class="comment">// 2.定位至左子树双链表最后一个节点</span></div><div class="line">    <span class="keyword">while</span>(p!=null&amp;&amp;p.<span class="keyword">right</span>!=null)&#123;p = p.<span class="keyword">right</span>;&#125;</div><div class="line">    <span class="comment">// 3.如果左子树链表不为空的话，将当前root追加到左子树链表</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">left</span>!=null)&#123;</div><div class="line">        p.<span class="keyword">right</span> = pRootOfTree;</div><div class="line">        pRootOfTree.<span class="keyword">left</span> = p;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">// 4.将右子树构造成双链表，并返回链表头节点</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">right</span> = <span class="type">Convert</span>(pRootOfTree.<span class="keyword">right</span>);</div><div class="line">     <span class="comment">// 5.如果右子树链表不为空的话，将该链表追加到 root 节点之后</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">right</span>)&#123;</div><div class="line">        <span class="keyword">right</span>.<span class="keyword">left</span> = pRootOfTree;</div><div class="line">        pRootOfTree.<span class="keyword">right</span> = <span class="keyword">right</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 6.根据左子树链表是否为空确定返回的节点。</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">left</span>!==null?<span class="keyword">left</span>:pRootOfTree;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？？</p><blockquote><p>三十八、二叉树的深度 p271/t38</p></blockquote><p><strong>描述</strong>：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function <span class="type">TreeDepth</span>(pRoot)&#123;</div><div class="line">    <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">1</span> + <span class="type">TreeDepth</span>(pRoot.<span class="keyword">left</span>);</div><div class="line">    <span class="keyword">var</span> <span class="keyword">right</span> = <span class="number">1</span>+ <span class="type">TreeDepth</span>(pRoot.<span class="keyword">right</span>);</div><div class="line">    <span class="keyword">return</span> <span class="type">Math</span>.<span class="built_in">max</span>(<span class="keyword">left</span>,<span class="keyword">right</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：????</p><blockquote><p>三十九、平衡二叉树 p273/t39</p></blockquote><p><strong>描述</strong>：输入一棵二叉树，判断该二叉树是否是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsBalanced_Solution</span>(<span class="params">pRoot</span>)</span>&#123; <span class="comment">// 根节点</span></div><div class="line">    <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(height(pRoot.left)-height(pRoot.right))&lt;=<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">height</span>(<span class="params">node</span>)</span>&#123; <span class="comment">// 普通节点</span></div><div class="line">      <span class="comment">// 压根不存在普通节点，那就只有根节点，单数就不算平衡吧哈哈</span></div><div class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      <span class="comment">// 根节点的左边不存在 且 根节点的右边不存在，算平衡</span></div><div class="line">        <span class="keyword">if</span>(!(node.left) &amp;&amp; !(node.right)) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      <span class="comment">// 正常的左右子树的节点都存在，那就比较一下，取最大值</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(height(node.left),height(node.right))+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：用后序遍历的方法，就可以一边遍历一边判断每个节点是不是平衡的了。</p><blockquote><p>五十七、二叉树的下一个结点 p65/t57</p></blockquote><p><strong>描述</strong>：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function GetNext(pNode)&#123;</div><div class="line">    <span class="keyword">if</span>(!pNode)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;    <span class="comment">// 空指针</span></div><div class="line">    var p = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span>(pNode.right)&#123;            <span class="comment">// 存在右子树</span></div><div class="line">        p = pNode.right;</div><div class="line">        <span class="keyword">while</span>(p.left)&#123;</div><div class="line">            p = p.left;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;                      <span class="comment">// 不存在右子树</span></div><div class="line">        p = pNode.<span class="keyword">next</span>;</div><div class="line">        <span class="keyword">if</span>(pNode.<span class="keyword">next</span> &amp;&amp; pNode.<span class="keyword">next</span>.right == pNode)&#123;</div><div class="line">            <span class="keyword">while</span>(p.<span class="keyword">next</span> &amp;&amp; p.<span class="keyword">next</span>.right == p)&#123;</div><div class="line">                p = p.<span class="keyword">next</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(p.<span class="keyword">next</span> == <span class="keyword">null</span>)&#123;</div><div class="line">                p =  <span class="keyword">null</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                p = p.<span class="keyword">next</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p><blockquote><p>五十八、对称的二叉树 p159/t58</p></blockquote><p><strong>描述</strong>：请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function isSymmetrical(pRoot)&#123;</div><div class="line">  <span class="keyword">if</span>(pRoot==null)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> judge(pRoot.<span class="keyword">left</span>,pRoot.<span class="keyword">right</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 竟然还有 .left 和 .right 这种方法</span></div><div class="line">function judge(<span class="keyword">left</span>,<span class="keyword">right</span>)&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">left</span>==null)&#123;<span class="keyword">return</span> <span class="keyword">right</span>==null&#125;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">right</span>==null)&#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">left</span>.val!=<span class="keyword">right</span>.val)&#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</div><div class="line">  <span class="keyword">return</span> judge(<span class="keyword">left</span>.<span class="keyword">left</span>,<span class="keyword">right</span>.<span class="keyword">right</span>)&amp;&amp;judge(<span class="keyword">left</span>.<span class="keyword">right</span>,<span class="keyword">right</span>.<span class="keyword">left</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同<br>2、左子树的右子树和右子树的左子树相同即可，采用递归<br>3、非递归也可，采用栈或队列存取各级子树根节点</p><blockquote><p>六十一、序列化二叉树 p194/t61</p></blockquote><p><strong>描述</strong>：请实现两个函数，分别用来序列化和反序列化二叉树<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span><span class="params">(x)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.val = x;</div><div class="line">  <span class="keyword">this</span>.left = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">this</span>.right = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Serialize</span><span class="params">(pRoot)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(pRoot==<span class="literal">null</span>)&#123;</div><div class="line">        arr.push(<span class="string">'a'</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        arr.push(pRoot.val);</div><div class="line">        Serialize(pRoot.left);</div><div class="line">        Serialize(pRoot.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deserialize</span><span class="params">(s)</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> node = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span>(arr.length&lt;<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> number = arr.shift();</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> number == <span class="string">'number'</span>)&#123;</div><div class="line">        node = <span class="keyword">new</span> TreeNode(number);</div><div class="line">        node.left = Deserialize(arr);</div><div class="line">        node.right = Deserialize(arr);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p><blockquote><p>六十二、二叉搜索树的第k个结点  p269/t62</p></blockquote><p><strong>描述</strong>：给定一棵二叉搜索树，请找出其中的第k小的结点。例如，（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">KthNode</span><span class="params">(pRoot, k)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</div><div class="line">  <span class="keyword">var</span> count=<span class="number">0</span>; <span class="comment">//计数器</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Knodes</span><span class="params">(pRoot, k)</span></span>&#123;</div><div class="line">      <span class="keyword">if</span>(pRoot!==<span class="literal">null</span>)&#123;<span class="comment">//中序遍历寻找第k个</span></div><div class="line">        <span class="keyword">var</span> node = Knodes(pRoot.left, k);</div><div class="line">        <span class="keyword">if</span>(node!==<span class="literal">null</span>)&#123;<span class="keyword">return</span> node;&#125;</div><div class="line">        count++;</div><div class="line">        <span class="keyword">if</span>(count==k)&#123;<span class="keyword">return</span> pRoot;&#125;</div><div class="line"></div><div class="line">        node = Knodes(pRoot.right, k);</div><div class="line">        <span class="keyword">if</span>(node!==<span class="literal">null</span>)&#123;<span class="keyword">return</span> node;&#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> Knodes(pRoot,k);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：由于题目中的二叉树是给定的，所以本题考查的就是 中序遍历</p><blockquote><p>六十三、数据流中的中位数 p214/t63</p></blockquote><p><strong>描述</strong>：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Insert</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    arr.push(num);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetMedian</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    arr.sort();</div><div class="line">    <span class="keyword">let</span> len = arr.length;</div><div class="line">    <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(len/<span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">let</span> node1 = arr[mid];</div><div class="line">            <span class="keyword">let</span> node2 = arr[mid<span class="number">-1</span>];</div><div class="line">            <span class="keyword">return</span> (node1+node2)/<span class="number">2</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> arr[mid];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：考察最大堆和最小堆</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【&lt;a href=&quot;https://github.com/wangsiyuan233/NowCoder&quot;&gt;源码地址&lt;/a&gt;】 || 【&lt;a href=&quot;https://www.nowcoder.com/ta/coding-interviews?page=1&quot;&gt;代码调试&lt;/a&gt;】&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;四、 重建二叉树 p62/t4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;br&gt;&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reConstructBinaryTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(pre, vin)&lt;/span&gt;&lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;//pre 是前序遍历，vin 是中序遍历&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// null 是真正的空，[] 里面还有东西&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result =&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pre.length&amp;gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; root = pre[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// indexOf() 方法可返回某个指定的字符串值首次出现的位置。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 下面开始中序遍历&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 找到根节点的位置&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; vinRootIndex = vin.indexOf(root);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 根节点的左边是左子树&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; vinLeft = vin.slice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,vinRootIndex);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 右边就是右子树&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; vinRight = vin.slice(vinRootIndex+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,vin.length);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 下面开始前序遍历：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// shift() 把数组的第一个元素从其中删除，并返回第一个元素的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 取走第一个数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      pre.shift();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 此时的第一个数是左子树的第一个数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; preLeft = pre.slice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,vinLeft.length);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; preRight = pre.slice(vinLeft.length,pre.length);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      result=&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        val:root,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        left:reConstructBinaryTree(preLeft,vinLeft),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        right:reConstructBinaryTree(preRight,vinRight)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 二叉树只有一个元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pre.length ===&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        result= &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            val :pre[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            left:&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            right:&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：&lt;br&gt;1、函数里面的参数 &lt;code&gt;pre&lt;/code&gt; 是前序遍历，&lt;code&gt;vin&lt;/code&gt; 是中序遍历；&lt;br&gt;2、第一步我们进行的是中序遍历：&lt;br&gt;3、前序的第一个点就是根节点，用 &lt;code&gt;indexOf&lt;/code&gt; 找到根节点的位置；&lt;br&gt;4、中序遍历中，根节点前面就是左子树，根节点后面就是右子树&lt;br&gt;5、第二步我们开始前序遍历：&lt;br&gt;6、取出根节点！很重要&lt;br&gt;7、用中序遍历中左子树&lt;strong&gt;的长度&lt;/strong&gt;，可以知道前序遍历的左子树&lt;br&gt;8、同理可以得到前序遍历的右子树&lt;br&gt;9、第三步就是 &lt;strong&gt;递归&lt;/strong&gt;&lt;br&gt;10、你不是让我重构这个二叉树吗？OK，我的整体左子树也有小左子树和小右子树啊&lt;br&gt;11、这个时候，“根节点”变了，逻辑却没变，还是用开始的大函数。&lt;br&gt;12、重建的二叉树也是数组&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="wangsiyuan233.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer(1)--链表篇(JavaScript版)/共 9 题</title>
    <link href="wangsiyuan233.github.io/2018/10/05/76%E5%89%91%E6%8C%87-%E9%93%BE%E8%A1%A8%E7%AF%87/"/>
    <id>wangsiyuan233.github.io/2018/10/05/76剑指-链表篇/</id>
    <published>2018-10-05T10:59:16.000Z</published>
    <updated>2018-10-07T12:19:25.624Z</updated>
    
    <content type="html"><![CDATA[<p>【<a href="https://github.com/wangsiyuan233/NowCoder" target="_blank" rel="external">源码地址</a>】 || 【<a href="https://www.nowcoder.com/ta/coding-interviews?page=1" target="_blank" rel="external">代码调试</a>】</p><hr><ul><li>【第一部分：】 逆序链表 2 题<blockquote><p>一、从尾到头打印链表 p58/t3</p></blockquote></li></ul><p><strong>描述</strong>：输入一个链表，按链表值从尾到头的顺序返回一个 <code>ArrayList</code>。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printListFromTailToHead</span><span class="params">(head)</span></span>&#123;</div><div class="line">  <span class="keyword">var</span> result = [];</div><div class="line">  <span class="keyword">while</span>(head)&#123;</div><div class="line">    result.unshift(head.val);</div><div class="line">    head = head.next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、BUG题/<code>unshift()</code>在数组的头部添加任意个项并返回新数组的长度<br>2、翻转后的 <code>head</code> 和 <code>head.next</code>，被一个一个加进了空数组的头部<br><a id="more"></a></p><blockquote><p>二、反转链表 p142/t15</p></blockquote><p><strong>描述</strong>：输入一个链表，反转链表后，输出新链表的表头。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseList</span><span class="params">(pHead)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> p1 = pHead;<span class="comment">//旧表的表头</span></div><div class="line">    <span class="keyword">var</span> p2 = <span class="literal">null</span>;<span class="comment">//新表的表头就是旧表的表尾，现在为空</span></div><div class="line">        temp = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">while</span> (p1) &#123;</div><div class="line">      <span class="comment">// 链表的反转 和 左右子树的交换，都需要左右手</span></div><div class="line">        temp = p1.next; <span class="comment">// 当下变成头部的下一个</span></div><div class="line">        p1.next = p2; <span class="comment">// 再变成链尾</span></div><div class="line">        p2 = p1;  <span class="comment">// 再变成链头</span></div><div class="line">        p1 = temp; <span class="comment">// 最后变成当下</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、解决链表相关的工作时，我们总需要大量的指针；<br>2、需要三个指针：分别指向当前遍历到的节点、它的前一个节点及后一个节点；<br>3、尾节点就是 <code>p.next</code> 为空的节点<br>4、左右手互换</p><hr><ul><li>【第二部分：】 合并链表 2 题<blockquote><p>三、合并两个排序的链表 p145/t16</p></blockquote></li></ul><p><strong>描述</strong>：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Merge(pHead1, pHead2)&#123;</div><div class="line">    <span class="keyword">if</span> (pHead1 == <span class="literal">null</span> || pHead2 == <span class="literal">null</span>) &#123; <span class="comment">//判断是不是空链表</span></div><div class="line">        <span class="keyword">return</span> pHead1 || pHead2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> head = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (pHead1.<span class="keyword">val</span> &lt; pHead2.<span class="keyword">val</span>) &#123;</div><div class="line">        head = pHead1;</div><div class="line">        head.next = Merge(pHead2,pHead1.next)</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        head = pHead2;</div><div class="line">        head.next = Merge(pHead1, pHead2.next);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：是递归</p><blockquote><p>四、复杂链表的复制 p187/t25</p></blockquote><p><strong>描述</strong>：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clone</span></span>(pHead) &#123;</div><div class="line">    <span class="keyword">if</span> (!pHead) &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</div><div class="line">  <span class="comment">// 复制头结点</span></div><div class="line">    <span class="comment">// 气死了这是什么东西啊！</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">new</span><span class="type">Head</span> = <span class="keyword">new</span> <span class="type">RandomListNode</span>(pHead.label);</div><div class="line">    <span class="comment">// 复制老结点的随机指针给新结点</span></div><div class="line">    <span class="keyword">new</span><span class="type">Head</span>.random = pHead.random;</div><div class="line">    <span class="comment">// 递归其他节点</span></div><div class="line">    <span class="keyword">new</span><span class="type">Head</span>.next = Clone(pHead.next);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Head</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br><img src="https://i.imgur.com/3ae3VAT.png" alt=""><br>(这个图对应得不是上面的代码)<br>1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；<br>2、重新遍历链表，复制老结点的随机指针给新结点，如<code>A1.random = A.random.next</code>;<br>3、拆分链表，将链表拆分为原链表和复制后的链表</p><hr><ul><li>【第三部分：】 找节点 4 题<blockquote><p>五、链表中倒数第k个结点  p134/t14</p></blockquote></li></ul><p><strong>描述</strong>：输入一个链表，输出该链表中倒数第k个结点。本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindKthToTail</span><span class="params">(head, k)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//表头为空指针 和 k为 0  都会原地爆炸</span></div><div class="line">    <span class="keyword">var</span> p1 = head;</div><div class="line">    <span class="keyword">var</span> p2 = head;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;<span class="comment">// p1 走到了 k</span></div><div class="line">        <span class="keyword">if</span> (p1.next != <span class="literal">null</span>) &#123;<span class="comment">// 如果没有空元素，就等于下一个</span></div><div class="line">            p1 = p1.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (p1.next != <span class="literal">null</span>)&#123;</div><div class="line">        p1 = p1.next;</div><div class="line">        p2 = p2.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、可以从定义看出，本题中的链表是单向链表，单向链表的节点只有从前往后的指针而没有从后往前的指针，所以不能从末尾开始扫描；<br>2、我们只需要遍历两次，第一次统计链表中节点的个数，第二次找到倒数K节点，这个时候面试官摁住了你的手，只允许你遍历一次；<br>3、于是我们就设计了两个指针，同时也要考虑到指针为空等情况<br>4、第一个指针从表头开始走到 k-1，第二个不动；<br>5、第一个到了 k，第二个开始动；<br>6、速度相同，两个指针始终保持 k-1的距离<br>7、第一个到了链尾，第二个就到了k。</p><blockquote><p>六、两个链表的第一个公共结点 p253/t36</p></blockquote><p><strong>描述</strong>：输入两个链表，找出它们的第一个公共结点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindFirstCommonNode</span>(<span class="params">pHead1, pHead2</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> p1=pHead1; <span class="comment">// p1 和 p2 此时是栈顶了</span></div><div class="line">    <span class="keyword">var</span> p2=pHead2; <span class="comment">// pHead1 和 pHead2 是链表头</span></div><div class="line"><span class="comment">// 隐藏的是：如果两个栈顶相同，就把他们弹出；</span></div><div class="line"><span class="comment">// 下面开始栈顶不同的部分：（此时不同就意味着 从尾部起 的节点已经找完了）</span></div><div class="line">    <span class="keyword">while</span>(p1!=p2)&#123;</div><div class="line">      <span class="comment">// 先判断后面一个等号</span></div><div class="line">      <span class="comment">// 栈顶不存在时，令它等于对方原链表头；存在()时，继续遍历下一个</span></div><div class="line">        p1= p1==<span class="literal">null</span>?pHead2:p1.next; <span class="comment">// 这里的 pHead2 不能换成 p2</span></div><div class="line">        p2= p2==<span class="literal">null</span>?pHead1:p2.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p1; <span class="comment">// 这里也可以写成 p2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、只有谈到链表，就会有head<br>2、JS没有用到书上说的比较长度的方法<br>3、本题是用 栈 的特点来解决；<br>4、分别把两个链表的节点放到两个栈中，这样两个链表的尾节点就位于两个栈的栈顶，接下来比较两个栈顶的节点是否相同；<br>5、如果相同，则把栈顶弹出，接着比较下一个栈顶，直到找到最后一个相同的节点。<br>6、公共的节点在链表的尾部可能性更大一些，所以需要用到 栈 的特点，可以先判断尾部（也就是栈顶）；<br>7、正着看两个链表的第一个公共结点，倒着看就是最后一个公共结点（因为链表只要开始相交，后面的都相交/重合）<br>8、<code>while</code> 循环和有意思，它是现行判断，如果小括号里的条件没有满足，花括号里它甚至不会去跑，社会社会！</p><blockquote><p>七、链表中环的入口结点 p139/t55</p></blockquote><p><strong>描述</strong>：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function EntryNodeOfLoop(pHead)&#123;</div><div class="line">    <span class="keyword">if</span>(pHead == <span class="literal">null</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</div><div class="line">    <span class="keyword">if</span>(pHead.next == <span class="literal">null</span>)&#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</div><div class="line">    <span class="keyword">var</span> fast = pHead;</div><div class="line">    <span class="keyword">var</span> slow = pHead;</div><div class="line">    <span class="comment">//找到一快一满指针相遇处的节点，相遇的节点一定是在环中</span></div><div class="line">    <span class="keyword">while</span>(slow != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</div><div class="line">        slow = slow.next;</div><div class="line">        fast = fast.next.next;</div><div class="line">        <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> p1 = slow;</div><div class="line">    <span class="keyword">var</span> p2 = pHead;</div><div class="line">    <span class="comment">// 移动p1，p2</span></div><div class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</div><div class="line">        p1 = p1.next;</div><div class="line">        p2 = p2.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p1;<span class="comment">// 这里也可以写成 p2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、第一步确定有没有环：定义两个指针同时出发，一个快一个慢，走的快的追上了走得慢的，就代表里面有环，如果快的到来链尾都没追上，就没环；<br>2、第二步找入口：如果链表中的环有 n 个节点，那么第一个指针就比第二个指针先出发 n,相同的速度移动，指针2在入口时，指针1已结绕着入口一圈，也停在了入口（在入口相遇了）</p><blockquote><p>八、删除链表中重复的结点  p122/t56       p39/T50 重复的数字</p></blockquote><p><strong>描述</strong>：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function deleteDuplication(pHead)&#123;</div><div class="line">    <span class="comment">//如果只有0个或1个结点，则返回</span></div><div class="line">    <span class="keyword">if</span>(pHead == <span class="literal">null</span> || pHead.next == <span class="literal">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> pHead;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">// 如果当前结点是重复结点</span></div><div class="line">    <span class="keyword">if</span>(pHead.<span class="keyword">val</span> == pHead.next.<span class="keyword">val</span>)&#123;</div><div class="line">        <span class="keyword">var</span> pNode = pHead.next;</div><div class="line">        <span class="keyword">while</span>(pNode!=<span class="literal">null</span> &amp;&amp; pNode.<span class="keyword">val</span>==pHead.<span class="keyword">val</span>)&#123;</div><div class="line">          <span class="comment">// 跳过值【与当前结点相同的全部结点】,找到第一个与当前结点不同的结点</span></div><div class="line">            pNode = pNode.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 从第一个【与当前结点不同的结点】开始递归</span></div><div class="line">        <span class="keyword">return</span> deleteDuplication(pNode);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 当前结点不是重复结</span></div><div class="line">        <span class="comment">// 保留当前结点，从下一个结点开始递归</span></div><div class="line">        pHead.next = deleteDuplication(pHead.next);</div><div class="line">        <span class="keyword">return</span> pHead;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、还是递归<br>2、如果判断【当前】和【下一个】相同，就跳过这些相同的，从第一个不同的节点开始递归；<br>3、如果判断【当前】和【下一个】不同，那就从下下个开始递归<br>4、反正就是递归你。</p><hr><ul><li>【第四部分：】 环形链表<blockquote><p>九、圆圈中最后剩下的数 p300/t46</p></blockquote></li></ul><p><strong>描述</strong>：0,1,2,3,4,5…n-1这n个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字。求出这个圆圈里剩下的最后一个数字。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LastRemaining_Solution</span><span class="params">(n, m)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  <span class="keyword">var</span> <span class="keyword">array</span> = [];</div><div class="line">  <span class="keyword">var</span> i = <span class="number">-1</span>,step = <span class="number">0</span>, count = n;</div><div class="line">  <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;   <span class="comment">//跳出循环时将最后一个元素也设置为了-1</span></div><div class="line">      i++;          <span class="comment">//指向上一个被删除对象的下一个元素。</span></div><div class="line">      <span class="keyword">if</span>(i&gt;=n) i=<span class="number">0</span>;  <span class="comment">//模拟环。</span></div><div class="line">      <span class="keyword">if</span>(<span class="keyword">array</span>[i] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//跳过被删除的对象。</span></div><div class="line">      step++;                     <span class="comment">//记录已走过的。</span></div><div class="line">      <span class="keyword">if</span>(step==m)&#123;               <span class="comment">//找到待删除的对象。</span></div><div class="line">          <span class="keyword">array</span>[i]=<span class="number">-1</span>;</div><div class="line">          step = <span class="number">0</span>;</div><div class="line">          count--;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> i;<span class="comment">//返回跳出循环时的i,即最后一个被设置为-1的元素</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、用环形链表模拟圆圈，缺点是需要一个辅助链表<br>2、而且需要遍历很多遍，占用内存<br>3、翻了几十条，都是用公式解的，暂时放下</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【&lt;a href=&quot;https://github.com/wangsiyuan233/NowCoder&quot;&gt;源码地址&lt;/a&gt;】 || 【&lt;a href=&quot;https://www.nowcoder.com/ta/coding-interviews?page=1&quot;&gt;代码调试&lt;/a&gt;】&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;【第一部分：】 逆序链表 2 题&lt;blockquote&gt;
&lt;p&gt;一、从尾到头打印链表 p58/t3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：输入一个链表，按链表值从尾到头的顺序返回一个 &lt;code&gt;ArrayList&lt;/code&gt;。&lt;br&gt;&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printListFromTailToHead&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(head)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result = [];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(head)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    result.unshift(head.val);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    head = head.next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：&lt;br&gt;1、BUG题/&lt;code&gt;unshift()&lt;/code&gt;在数组的头部添加任意个项并返回新数组的长度&lt;br&gt;2、翻转后的 &lt;code&gt;head&lt;/code&gt; 和 &lt;code&gt;head.next&lt;/code&gt;，被一个一个加进了空数组的头部&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="wangsiyuan233.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>Event Loop</title>
    <link href="wangsiyuan233.github.io/2018/09/15/73Event-Loop/"/>
    <id>wangsiyuan233.github.io/2018/09/15/73Event-Loop/</id>
    <published>2018-09-15T10:56:59.000Z</published>
    <updated>2018-09-15T12:13:40.324Z</updated>
    
    <content type="html"><![CDATA[<p>JS 是单线程语言</p><p>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <strong>JS 中的异步还是同步行为</strong>。<br><a id="more"></a><br>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</div><div class="line">    resolve()</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</div><div class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></div></pre></td></tr></table></figure></p><p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务，所以会有以上的打印。</p><p>微任务包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>Object.observe</code> ，<code>MutationObserver</code></p><p>宏任务包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code></p><p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 <code>script</code> ，<strong>浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</strong></p><p>所以正确的一次 Event loop 顺序是这样的：</p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 Event loop，执行宏任务中的异步代码<br>通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。</li></ul><hr><p><a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/Browser/browser-ch.md#node-%E4%B8%AD%E7%9A%84-event-loop" target="_blank" rel="external">Node 中的 Event loop</a></p><p>学完 node 之后补充</p><h2 id="★30s总结"><a href="#★30s总结" class="headerlink" title="★30s总结"></a>★30s总结</h2><ul><li>任务分为 微观任务 和 宏观任务</li><li>先宏观的同步代码</li><li>发现有微观！</li><li>做微观吧（<code>promise</code> ）</li><li>继续宏观的异步代码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 是单线程语言&lt;/p&gt;
&lt;p&gt;JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 &lt;strong&gt;JS 中的异步还是同步行为&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="wangsiyuan233.github.io/2018/09/13/72%E8%B7%A8%E5%9F%9F/"/>
    <id>wangsiyuan233.github.io/2018/09/13/72跨域/</id>
    <published>2018-09-13T01:36:18.000Z</published>
    <updated>2018-10-20T08:01:27.416Z</updated>
    
    <content type="html"><![CDATA[<p><strong>浏览器出于安全的考虑，采用的是同源策略。</strong></p><p>协议、域名和端口号三者统一，就是同域，只要有其中一个不一样，就是跨域，这时Ajax就会请求失败。</p><p>下面有三种方法可以解决跨域的问题<br><a id="more"></a></p><blockquote><p>一、JSONP</p></blockquote><p><code>JSONP</code> 的原理非常简单：</p><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><p><code>JSONP</code>的兼容性很好，但只限于 <strong>GET</strong> 请求</p><p>在开发中可能会遇到多个 <code>JSONP</code> 请求的回调函数名是相同的，这时候就需要自己封装一个 <code>JSONP</code>，以下是简单实现：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function <span class="keyword">jsonp(url, </span><span class="keyword">jsonpCallback, </span>success) &#123;</div><div class="line">  let <span class="keyword">script </span>= document.createElement(<span class="string">"script"</span>)<span class="comment">;</span></div><div class="line">  <span class="keyword">script.src </span>= url<span class="comment">;</span></div><div class="line">  <span class="keyword">script.async </span>= true<span class="comment">;</span></div><div class="line">  <span class="keyword">script.type </span>= <span class="string">"text/javascript"</span><span class="comment">;</span></div><div class="line">  window[<span class="keyword">jsonpCallback] </span>= function(data) &#123;</div><div class="line">    success &amp;&amp; success(data)<span class="comment">;</span></div><div class="line">  &#125;<span class="comment">;</span></div><div class="line">  document.<span class="keyword">body.appendChild(script);</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">jsonp(</span></div><div class="line">  <span class="string">"http://xxx"</span>,</div><div class="line">  <span class="string">"callback"</span>,</div><div class="line">  function(value) &#123;</div><div class="line">    console.log(value)<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">)<span class="comment">;</span></div></pre></td></tr></table></figure></p><blockquote><p>二、CORS</p></blockquote><p><code>CORS</code> 需要<strong>浏览器</strong>和<strong>后端</strong>同时支持。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><p>实现 <code>CORS</code> 通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</p><blockquote><p>三、document.domain</p></blockquote><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</p><p>只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p><blockquote><p>四、postMessage</p></blockquote><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发送消息端</span></div><div class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">'message'</span>, <span class="string">'http://test.com'</span>);</div><div class="line"><span class="comment">// 接收消息端</span></div><div class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel();</div><div class="line">mc.addEventListener(<span class="string">'message'</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin; </div><div class="line">    <span class="keyword">if</span> (origin === <span class="string">'http://test.com'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'验证通过'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="★30s总结"><a href="#★30s总结" class="headerlink" title="★30s总结"></a>★30s总结</h2><ul><li><code>JSONP</code> : 利用 <code>&lt;script&gt;</code> 标签的漏洞来跨域；</li><li><code>CORS</code>：服务端和后端，后端是关键</li><li><code>document.domian</code> ： 二级域名相同</li><li><code>postMessage</code> ： 一个页面发送，另一个页面接收并验证</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;浏览器出于安全的考虑，采用的是同源策略。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;协议、域名和端口号三者统一，就是同域，只要有其中一个不一样，就是跨域，这时Ajax就会请求失败。&lt;/p&gt;
&lt;p&gt;下面有三种方法可以解决跨域的问题&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DOM2</title>
    <link href="wangsiyuan233.github.io/2018/09/11/71DOM2/"/>
    <id>wangsiyuan233.github.io/2018/09/11/71DOM2/</id>
    <published>2018-09-11T14:48:17.000Z</published>
    <updated>2018-10-22T00:58:39.872Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一、事件触发</p></blockquote><ol><li><code>window</code> 到 触发处 的途中，碰到了 捕获 就会触发</li><li>到了 触发处，肯定也会激活啊</li><li>从 触发处 往 <code>window</code> 传播，碰到了 冒泡 就会触发</li></ol><a id="more"></a><p>一般情况下都是按照上面三个步骤发展，如果一个事件同时有 冒泡和捕获，那就按照发生的顺序来<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="params">(event)</span> =&gt;</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</div><div class="line">&#125;,<span class="literal">false</span>);</div><div class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="params">(event)</span> =&gt;</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</div><div class="line">&#125;,<span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="regexp">//</span> 冒泡 捕获</div></pre></td></tr></table></figure></p><blockquote><p>二、注册事件</p></blockquote><p>我们用 <code>addEventListener</code> 注册事件，这个函数的第三个参数可以是 布尔值 <code>useCapture</code>，也可以是对象</p><ul><li>参数为 布尔值 <code>useCapture</code> 时，默认的是 <code>false</code>，即 冒泡事件。</li><li>参数为对象时，省略。</li></ul><p>我们希望事件到了触发处就停止了，这时可以使用 stopPropagation 来阻止进一步传播：</p><ul><li><code>stopPropagation</code> 不仅可以阻止冒泡，也可以阻止捕获</li><li><code>stopImmediatePropagation</code> 更强，在上面基础上，还可以阻止除了当前事件的其他事件注册<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="params">(event)</span> =&gt;</span>&#123;</div><div class="line">event.stopImmediatePropagation()</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</div><div class="line">&#125;,<span class="literal">false</span>);</div><div class="line"><span class="regexp">//</span> 点击 node 只会执行上面的函数，该函数不会执行</div><div class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</div><div class="line">&#125;,<span class="literal">true</span>)</div></pre></td></tr></table></figure></li></ul><blockquote><p>三、事件代理</p></blockquote><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>)</div><div class="line">ul.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(event.target);</div><div class="line">&#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><p>事件代理的优点：</p><ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul><h2 id="30s总结"><a href="#30s总结" class="headerlink" title="30s总结"></a>30s总结</h2><ul><li>事件机制 <code>addEventListener</code> 分三步走: 捕获、触发和冒泡</li><li><code>stopPropagation</code> 和 <code>stopImmediatePropagation</code> 都可以阻止触发</li><li>动态的子节点，需要去父节点上触发</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一、事件触发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;window&lt;/code&gt; 到 触发处 的途中，碰到了 捕获 就会触发&lt;/li&gt;
&lt;li&gt;到了 触发处，肯定也会激活啊&lt;/li&gt;
&lt;li&gt;从 触发处 往 &lt;code&gt;window&lt;/code&gt; 传播，碰到了 冒泡 就会触发&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript--异步系列(4)</title>
    <link href="wangsiyuan233.github.io/2018/08/23/70%E5%BC%82%E6%AD%A5%E7%B3%BB%E5%88%97-4/"/>
    <id>wangsiyuan233.github.io/2018/08/23/70异步系列-4/</id>
    <published>2018-08-23T11:41:21.000Z</published>
    <updated>2018-09-13T12:18:12.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>async 和 await<br>1、一个函数如果加上 <code>async</code> ，那么该函数就会返回一个 <code>Promise</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"1"</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: "1"&#125;</span></div></pre></td></tr></table></figure></p><p>可以把 <code>async</code> 看成将函数返回值使用 <code>Promise.resolve()</code> 包裹了下<br><a id="more"></a><br>2、<code>await</code> 只能在 <code>async</code> 函数中使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'finish'</span>)</div><div class="line">      resolve(<span class="string">"sleep"</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> value = <span class="keyword">await</span> sleep();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"object"</span>);</div><div class="line">&#125;</div><div class="line">test()</div></pre></td></tr></table></figure></p><p>上面代码会先打印 <code>finish</code> 然后再打印 <code>object</code> 。因为 <code>await</code> 会等待 <code>sleep</code> 函数 <code>resolve</code> ，<strong>所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码。</strong></p><p><code>async</code> 和 <code>await</code> 相比直接使用 <code>Promise</code> 来说，优势在于处理 <code>then</code> 的调用链，能够更清晰准确的写出代码。缺点在于滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p><p>下面来看一个使用 <code>await</code> 的代码:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">0</span></div><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = async () =&gt; &#123;</div><div class="line">  <span class="selector-tag">a</span> = <span class="selector-tag">a</span> + await <span class="number">10</span></div><div class="line">  console.log(<span class="string">'2'</span>, a) <span class="comment">// -&gt; '2' 10</span></div><div class="line">  <span class="selector-tag">a</span> = (await <span class="number">10</span>) + <span class="selector-tag">a</span></div><div class="line">  console.log(<span class="string">'3'</span>, a) <span class="comment">// -&gt; '3' 20</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">b</span><span class="params">()</span></span></div><div class="line">a++</div><div class="line">console.log(<span class="string">'1'</span>, a) <span class="comment">// -&gt; '1' 1</span></div></pre></td></tr></table></figure></p><p>对于以上代码你可能会有疑惑，这里说明下原理</p><ul><li>首先函数 b 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为在 <code>await</code> 内部实现了 <code>generators</code> ，<code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li><li>因为 <code>await</code> 是异步操作，所以会先执行 <code>console.log(&#39;1&#39;, a)</code></li><li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 10</code></li><li>然后后面就是常规执行代码了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;async-和-await&quot;&gt;&lt;a href=&quot;#async-和-await&quot; class=&quot;headerlink&quot; title=&quot;async 和 await&quot;&gt;&lt;/a&gt;async 和 await&lt;/h2&gt;&lt;p&gt;async 和 await&lt;br&gt;1、一个函数如果加上 &lt;code&gt;async&lt;/code&gt; ，那么该函数就会返回一个 &lt;code&gt;Promise&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(test()); &lt;span class=&quot;comment&quot;&gt;// -&amp;gt; Promise &amp;#123;&amp;lt;resolved&amp;gt;: &quot;1&quot;&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以把 &lt;code&gt;async&lt;/code&gt; 看成将函数返回值使用 &lt;code&gt;Promise.resolve()&lt;/code&gt; 包裹了下&lt;br&gt;
    
    </summary>
    
    
      <category term="异步" scheme="wangsiyuan233.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript--异步系列(3)</title>
    <link href="wangsiyuan233.github.io/2018/08/23/69%E5%BC%82%E6%AD%A5%E7%B3%BB%E5%88%97-3/"/>
    <id>wangsiyuan233.github.io/2018/08/23/69异步系列-3/</id>
    <published>2018-08-23T03:03:01.000Z</published>
    <updated>2018-10-19T03:41:35.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a>Generator 实现</h2><p>Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用来异步编程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 * 表示这是一个 Generator 函数</span></div><div class="line"><span class="comment">// 内部可以通过 yield 暂停代码</span></div><div class="line"><span class="comment">// 通过调用 next 恢复执行</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> b = test();</div><div class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &#123; value: 2, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &#123; value: 3, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure></p><a id="more"></a><p>从以上代码可以发现，加上 <code>*</code> 的函数执行后拥有了 <code>next</code> 函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code> 函数可以继续执行被暂停的代码。</p><p>以下是 <code>Generator</code> 函数的简单实现:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// cb 也就是编译过的 test 函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span><span class="params">(cb)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> object = &#123;</div><div class="line">      next: <span class="number">0</span>,</div><div class="line">      stop: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      next: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> ret = cb(object);</div><div class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; value: <span class="literal">undefined</span>, done: <span class="literal">true</span> &#125;;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">          value: ret,</div><div class="line">          done: <span class="literal">false</span></div><div class="line">        &#125;;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;)();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> a;</div><div class="line">  <span class="keyword">return</span> generator(<span class="function"><span class="keyword">function</span><span class="params">(_context)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</div><div class="line">        <span class="comment">// 可以发现通过 yield 将代码分割成几块</span></div><div class="line">        <span class="comment">// 每次执行 next 函数就执行一块代码</span></div><div class="line">        <span class="comment">// 并且表明下次需要执行哪块代码</span></div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</div><div class="line">          _context.next = <span class="number">4</span>;</div><div class="line">          <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">          _context.next = <span class="number">6</span>;</div><div class="line">          <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line"><span class="comment">// 执行完毕</span></div><div class="line">        <span class="keyword">case</span> <span class="number">6</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">"end"</span>:</div><div class="line">          <span class="keyword">return</span> _context.stop();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Generator-实现&quot;&gt;&lt;a href=&quot;#Generator-实现&quot; class=&quot;headerlink&quot; title=&quot;Generator 实现&quot;&gt;&lt;/a&gt;Generator 实现&lt;/h2&gt;&lt;p&gt;Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用来异步编程&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用 * 表示这是一个 Generator 函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 内部可以通过 yield 暂停代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过调用 next 恢复执行&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = test();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b.next()); &lt;span class=&quot;comment&quot;&gt;// &amp;#123; value: 2, done: false &amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b.next()); &lt;span class=&quot;comment&quot;&gt;// &amp;#123; value: 3, done: false &amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b.next()); &lt;span class=&quot;comment&quot;&gt;// &amp;#123; value: undefined, done: true &amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="异步" scheme="wangsiyuan233.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>聊聊系列(6)-- call, apply, bind 区别</title>
    <link href="wangsiyuan233.github.io/2018/08/23/68%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-6-abc%E7%BB%91%E5%AE%9A/"/>
    <id>wangsiyuan233.github.io/2018/08/23/68聊聊系列-6-abc绑定/</id>
    <published>2018-08-23T02:23:07.000Z</published>
    <updated>2018-08-23T17:58:31.454Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://wangsiyuan233.cn/2018/03/04/27%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-2/" target="_blank" rel="external">【【【this 实例-第9条】】】</a></p><blockquote><p>一、 call 和 apply 的异同</p></blockquote><p><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p><p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(name)</div><div class="line">    <span class="built_in">console</span>.log(age)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</div><div class="line">&#125;</div><div class="line">getValue.call(a, <span class="string">'yck'</span>, <span class="string">'24'</span>)</div><div class="line">getValue.apply(a, [<span class="string">'yck'</span>, <span class="string">'24'</span>])</div></pre></td></tr></table></figure></p><a id="more"></a><blockquote><p>二、自己动手实现</p></blockquote><p>可以从以下几点来考虑如何实现</p><ul><li>不传入第一个参数，那么默认为 <code>window</code></li><li>改变了 <code>this</code> 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？</li></ul><p>1、call 的思路<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Function<span class="variable">.prototype</span><span class="variable">.myCall</span> = <span class="keyword">function</span> (<span class="keyword">context</span>) &#123;</div><div class="line">  <span class="keyword">var</span> <span class="keyword">context</span> = <span class="keyword">context</span> || window</div><div class="line">  <span class="comment">// 给 context 添加一个属性</span></div><div class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn = getValue</span></div><div class="line">  <span class="keyword">context</span><span class="variable">.fn</span> = <span class="keyword">this</span></div><div class="line">  <span class="comment">// 将 context 后面的参数取出来</span></div><div class="line">  <span class="keyword">var</span> args = [..<span class="variable">.arguments</span>]<span class="variable">.slice</span>(<span class="number">1</span>)</div><div class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn('yck', '24')</span></div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">context</span><span class="variable">.fn</span>(..<span class="variable">.args</span>)</div><div class="line">  <span class="comment">// 删除 fn</span></div><div class="line">  delete <span class="keyword">context</span><span class="variable">.fn</span></div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2、apply 的思路<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Function<span class="variable">.prototype</span><span class="variable">.myApply</span> = <span class="keyword">function</span> (<span class="keyword">context</span>) &#123;</div><div class="line">  <span class="keyword">var</span> <span class="keyword">context</span> = <span class="keyword">context</span> || window</div><div class="line">  <span class="keyword">context</span><span class="variable">.fn</span> = <span class="keyword">this</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> result</div><div class="line">  <span class="comment">// 需要判断是否存储第二个参数</span></div><div class="line">  <span class="comment">// 如果存在，就将第二个参数展开</span></div><div class="line">  <span class="keyword">if</span> (arguments[<span class="number">1</span>]) &#123;</div><div class="line">    result = <span class="keyword">context</span><span class="variable">.fn</span>(..<span class="variable">.arguments</span>[<span class="number">1</span>])</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    result = <span class="keyword">context</span><span class="variable">.fn</span>()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  delete <span class="keyword">context</span><span class="variable">.fn</span></div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3、bind 的思路</p><p>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></div><div class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</div><div class="line">  <span class="comment">// 返回一个函数</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://wangsiyuan233.cn/2018/03/04/27%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-2/&quot;&gt;【【【this 实例-第9条】】】&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一、 call 和 apply 的异同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 都是为了解决改变 &lt;code&gt;this&lt;/code&gt; 的指向。作用都是相同的，只是传参的方式不同。&lt;/p&gt;
&lt;p&gt;除了第一个参数外，&lt;code&gt;call&lt;/code&gt; 可以接收一个参数列表，&lt;code&gt;apply&lt;/code&gt; 只接受一个参数数组。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getValue&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(name)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(age)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;getValue.call(a, &lt;span class=&quot;string&quot;&gt;&#39;yck&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;24&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;getValue.apply(a, [&lt;span class=&quot;string&quot;&gt;&#39;yck&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;24&#39;&lt;/span&gt;])&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="聊聊系列" scheme="wangsiyuan233.github.io/tags/%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>聊聊系列(5)-- 继承</title>
    <link href="wangsiyuan233.github.io/2018/08/22/67%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-5-%E7%BB%A7%E6%89%BF/"/>
    <id>wangsiyuan233.github.io/2018/08/22/67聊聊系列-5-继承/</id>
    <published>2018-08-22T13:11:28.000Z</published>
    <updated>2018-10-19T09:09:54.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一、ES5</p></blockquote><p>在 ES5 中，我们可以使用如下方式解决继承的问题,实现思路就是将子类的原型设置为父类的原型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Super.prototype.getNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sub()</div><div class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype, &#123;</div><div class="line">  <span class="attr">constructor</span>: &#123;</div><div class="line">    <span class="attr">value</span>: Sub,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><a id="more"></a><blockquote><p>二、ES6</p></blockquote><p>通过 class 语法轻松解决ES5的问题<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> <span class="keyword">extends</span> <span class="title">Date</span> </span>&#123;</div><div class="line">  test() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getTime()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let myDate = <span class="keyword">new</span> <span class="type">MyDate</span>()</div><div class="line">myDate.test()</div></pre></td></tr></table></figure></p><p>但是 ES6 不是所有浏览器都兼容，所以我们需要使用 Babel 来编译这段代码。</p><p>如果你使用编译过得代码调用 <code>myDate.test()</code> 你会惊奇地发现出现了报错<br><img src="https://i.imgur.com/5EPAs20.png" alt=""><br>因为在 JS 底层有限制，如果不是由 Date 构造出来的实例的话，是不能调用 Date 里的函数的。所以这也侧面的说明了：ES6 中的 <code>class</code> 继承与 ES5 中的一般继承写法是不同的。</p><p>既然底层限制了实例必须由 Date 构造出来，那么我们可以改变下思路实现继承<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyData</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">MyData.prototype.test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.getTime()</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(d, MyData.prototype)</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(MyData.prototype, <span class="built_in">Date</span>.prototype)</div></pre></td></tr></table></figure></p><p>以上继承实现思路：先创建父类实例 =&gt; 改变实例原先的 <code>_proto__</code> 转而连接到子类的 <code>prototype</code> =&gt; 子类的 <code>prototype</code> 的 <code>__proto__</code> 改为父类的 <code>prototype</code>。</p><p>通过以上方法实现的继承就可以完美解决 JS 底层的这个限制。</p><hr><p>通过原型和原型链的储备知识，我们首先要厘定一下【构造函数、对象、实例之间的关系】这三者之间的关系</p><p>借用 一段代码 和 一张图 吧！</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span><span class="params">()</span></span>&#123; </div><div class="line"><span class="keyword">this</span>.type=<span class="string">'人'</span> </div><div class="line">&#125; </div><div class="line">People.prototype.showType=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line"> alert(<span class="keyword">this</span>.type); </div><div class="line">&#125; </div><div class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> People(); <span class="comment">//调用原型对象上面的方法</span></div><div class="line">person.showType();<span class="comment">//最后结果弹框弹出人</span></div><div class="line">People.prototype.constructor==People；<span class="comment">//返回true</span></div></pre></td></tr></table></figure><p>以上代码定义了一个<strong>构造函数<code>People()</code></strong>,<strong><code>People.prototype</code>指向原型对象</strong>，其自带属性 <code>construtor</code> 又指回了 <code>People</code>，即<code>People.prototype.constructor==People</code>.<strong>实例对象 <code>person</code></strong>由于其内部指针指向了原型对象，所以可以访问原型对象上的 <code>showType</code> 方法。</p><p><img src="https://i.imgur.com/UFtvJWC.png" alt=""></p><p>总结：三者的关系是，每个构造函数都有一个原型对象，原型对象上包含着一个指向构造函数的指针，而实例都包含着一个指向原型对象的内部指针。通俗的说，实例可以通过<strong>内部指针(<code>_proto_</code>)</strong>访问到原型对象，原型对象可以通过 <strong>constructor</strong> 找到构造函数。</p><p><img src="https://i.imgur.com/rzCp6Ux.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一、ES5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 ES5 中，我们可以使用如下方式解决继承的问题,实现思路就是将子类的原型设置为父类的原型&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Super&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Super.prototype.getNumber = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sub&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; s = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Sub()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Sub.prototype = &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.create(Super.prototype, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;constructor&lt;/span&gt;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;: Sub,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;enumerable&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;writable&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;configurable&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="聊聊系列" scheme="wangsiyuan233.github.io/tags/%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>聊聊系列(4)-- 深浅拷贝</title>
    <link href="wangsiyuan233.github.io/2018/08/20/66%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-4-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>wangsiyuan233.github.io/2018/08/20/66聊聊系列-4-深浅拷贝/</id>
    <published>2018-08-20T12:27:23.000Z</published>
    <updated>2018-08-23T04:11:18.183Z</updated>
    
    <content type="html"><![CDATA[<p>如果<strong>给一个变量赋值一个对象</strong>，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let <span class="selector-tag">a</span> = &#123;</div><div class="line">    age: <span class="number">1</span></div><div class="line">&#125;</div><div class="line">let <span class="selector-tag">b</span> = <span class="selector-tag">a</span></div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.age</span> = <span class="number">2</span></div><div class="line">console.log(<span class="selector-tag">b</span>.age) <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><p>我们不想要这样的情况出现在开发中，需要浅拷贝<br><a id="more"></a></p><blockquote><p>一、浅拷贝</p></blockquote><p>1、通过 <code>Object.assign</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let <span class="selector-tag">a</span> = &#123;</div><div class="line">    age: <span class="number">1</span></div><div class="line">&#125;</div><div class="line">let <span class="selector-tag">b</span> = Object.assign(&#123;&#125;, a)</div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.age</span> = <span class="number">2</span></div><div class="line">console.log(<span class="selector-tag">b</span>.age) <span class="comment">// 1</span></div></pre></td></tr></table></figure></p><p>2、通过展开运算符（…）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let <span class="selector-tag">a</span> = &#123;</div><div class="line">    age: <span class="number">1</span></div><div class="line">&#125;</div><div class="line">let <span class="selector-tag">b</span> = &#123;...a&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.age</span> = <span class="number">2</span></div><div class="line">console.log(<span class="selector-tag">b</span>.age) <span class="comment">// 1</span></div></pre></td></tr></table></figure></p><p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let <span class="selector-tag">a</span> = &#123;</div><div class="line">    age: <span class="number">1</span>,</div><div class="line">    jobs: &#123;</div><div class="line">        first: <span class="string">'FE'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let <span class="selector-tag">b</span> = &#123;...a&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.jobs</span><span class="selector-class">.first</span> = <span class="string">'native'</span></div><div class="line">console.log(<span class="selector-tag">b</span><span class="selector-class">.jobs</span><span class="selector-class">.first</span>) <span class="comment">// native</span></div></pre></td></tr></table></figure></p><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。</p><blockquote><p>二、深拷贝</p></blockquote><p>1、这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let <span class="selector-tag">a</span> = &#123;</div><div class="line">    age: <span class="number">1</span>,</div><div class="line">    jobs: &#123;</div><div class="line">        first: <span class="string">'FE'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let <span class="selector-tag">b</span> = JSON.parse(JSON.stringify(a))</div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.jobs</span><span class="selector-class">.first</span> = <span class="string">'native'</span></div><div class="line">console.log(<span class="selector-tag">b</span><span class="selector-class">.jobs</span><span class="selector-class">.first</span>) <span class="comment">// FE</span></div></pre></td></tr></table></figure></p><p>但是该方法也是有<strong>局限性</strong>的：</p><ul><li>会忽略 undefined</li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><p>例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">  <span class="selector-tag">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="selector-tag">b</span>: &#123;</div><div class="line">    c: <span class="number">2</span>,</div><div class="line">    d: <span class="number">3</span>,</div><div class="line">  &#125;,</div><div class="line">&#125;</div><div class="line">obj<span class="selector-class">.c</span> = obj<span class="selector-class">.b</span></div><div class="line">obj<span class="selector-class">.e</span> = obj<span class="selector-class">.a</span></div><div class="line">obj<span class="selector-class">.b</span><span class="selector-class">.c</span> = obj<span class="selector-class">.c</span></div><div class="line">obj<span class="selector-class">.b</span><span class="selector-class">.d</span> = obj<span class="selector-class">.b</span></div><div class="line">obj<span class="selector-class">.b</span><span class="selector-class">.e</span> = obj<span class="selector-class">.b</span><span class="selector-class">.c</span></div><div class="line">let newObj = JSON.parse(JSON.stringify(obj))</div><div class="line">console.log(newObj)</div></pre></td></tr></table></figure></p><p>如果你用上面的方法深拷贝，你会发现如下报错：<br><img src="https://i.imgur.com/mIZISaM.png" alt=""></p><p>在遇到函数或者 undefined 的时候，该对象也不能正常的序列化<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">    <span class="attr">age</span>: <span class="literal">undefined</span>,</div><div class="line">    <span class="attr">jobs</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">    <span class="attr">name</span>: <span class="string">'yck'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</div><div class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123;name: "yck"&#125;</span></div></pre></td></tr></table></figure></p><p>你会发现在上述情况中，该方法会忽略掉函数和 <code>undefined</code></p><p>2、在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 <a href="https://lodash.com/docs/4.17.10#cloneDeep" target="_blank" rel="external">lodash 的深拷贝函数</a>。</p><p>3、如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 <code>MessageChannel</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> &#123;port1, port2&#125; = <span class="keyword">new</span> MessageChannel();</div><div class="line">    port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</div><div class="line">    port1.postMessage(obj);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123;</div><div class="line">    <span class="attr">c</span>: b</div><div class="line">&#125;&#125;</div><div class="line"><span class="comment">// 注意该方法是异步的</span></div><div class="line"><span class="comment">// 可以处理 undefined 和循环引用对象</span></div><div class="line"><span class="keyword">const</span> clone = <span class="keyword">await</span> structuralClone(obj);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果&lt;strong&gt;给一个变量赋值一个对象&lt;/strong&gt;，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;let &lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt; = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    age: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;let &lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt; = &lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.age&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(&lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt;.age) &lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们不想要这样的情况出现在开发中，需要浅拷贝&lt;br&gt;
    
    </summary>
    
    
      <category term="聊聊系列" scheme="wangsiyuan233.github.io/tags/%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>基本的数据结构</title>
    <link href="wangsiyuan233.github.io/2018/07/25/64%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>wangsiyuan233.github.io/2018/07/25/64基本的数据结构/</id>
    <published>2018-07-25T08:30:40.000Z</published>
    <updated>2018-10-06T10:54:25.208Z</updated>
    
    <content type="html"><![CDATA[<p>来源于 <a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="external">LeetCode - 226</a></p><blockquote><p>一、翻转二叉树</p></blockquote><p><img src="https://i.imgur.com/gIjXNsQ.png" alt=""><br>其实思路还是比较简单的：将当前的root节点的左右分支进行对调反转，若左分支存在，则将左分支的节点作为root节点进行对调反转；若右分支存在，则将右分支的节点作为root节点进行对调反转；一直 <strong>递归</strong> 到所有节点的左右分支都不存在。<br><a id="more"></a><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * function TreeNode(val) &#123;</div><div class="line"> *     this.val = val;</div><div class="line"> *     this.left = this.right = null;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="comment">/**</span></div><div class="line"> * @param &#123;TreeNode&#125; root</div><div class="line"> * @return &#123;TreeNode&#125;</div><div class="line"> */</div><div class="line"><span class="keyword">var</span> invertTree = function(root) &#123;</div><div class="line">    <span class="comment">// 传入的根节点可能就是null或者异常节点，则对root进行判断</span></div><div class="line">    <span class="keyword">if</span>(root)&#123;</div><div class="line">        <span class="keyword">var</span> temp = null;</div><div class="line"></div><div class="line">        <span class="comment">// 将当前节点的左右分支进行对调反转</span></div><div class="line">        temp = root.<span class="keyword">left</span>;</div><div class="line">        root.<span class="keyword">left</span> = root.<span class="keyword">right</span>;</div><div class="line">        root.<span class="keyword">right</span> = temp;</div><div class="line"></div><div class="line">        <span class="comment">// 若左分支存在，则递归左分支的节点</span></div><div class="line">        <span class="keyword">if</span>(root.<span class="keyword">left</span>)&#123;</div><div class="line">            invertTree(root.<span class="keyword">left</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 若右分支存在，则递归右分支的节点</span></div><div class="line">        <span class="keyword">if</span>(root.<span class="keyword">right</span>)&#123;</div><div class="line">            invertTree(root.<span class="keyword">right</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 所有的节点遍历完成后，返回根节点</span></div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><blockquote><p>二、求二叉树的深度</p></blockquote><ul><li>只有一个根结点时，二叉树深度为1</li><li>只有左子树时，二叉树深度为左子树深度加1</li><li>只有右子树时，二叉树深度为右子树深度加1</li><li>同时存在左右子树时，二叉树深度为左右子树中深度最大者加1<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deep</span><span class="params">(root)</span>&#123;</span></div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">left</span> = deep(root.<span class="keyword">left</span>)</div><div class="line">    <span class="keyword">let</span> <span class="keyword">right</span> = deep(root.<span class="keyword">right</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">left</span> &gt; <span class="keyword">right</span> ? <span class="keyword">left</span> + <span class="number">1</span> : <span class="keyword">right</span> + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><blockquote><p>三、求二叉树的宽度</p></blockquote><ul><li>算出第一层的结点数，保存</li><li>算出第二层的结点数，保存一二层中较大的结点数</li><li>重复以上过程<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">width</span><span class="params">(root)</span>&#123;</span></div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> queue = [root], <span class="built_in">max</span> = <span class="number">1</span>, deep = <span class="number">1</span></div><div class="line">    <span class="keyword">while</span>(queue.length)&#123;</div><div class="line">        <span class="keyword">while</span>(deep--)&#123;</div><div class="line">            <span class="keyword">let</span> temp = queue.shift()</div><div class="line">            <span class="keyword">if</span>(temp.<span class="keyword">left</span>)&#123;</div><div class="line">                queue.push(temp.<span class="keyword">left</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(temp.<span class="keyword">right</span>)&#123;</div><div class="line">                queue.push(temp.<span class="keyword">right</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        deep = queue.length</div><div class="line">        <span class="built_in">max</span> = <span class="built_in">max</span> &gt; deep ? <span class="built_in">max</span> : deep</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">max</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><p>栈是一个线性结构</p><p>栈的特点是只能在<strong>某一端</strong>添加或删除数据，遵循<strong>先进后出</strong>的原则<br><!--more--><br><img src="https://i.imgur.com/UcwdXxz.png" alt=""><br>把栈看成是数组的一个子集:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.stack = []</div><div class="line">  &#125;</div><div class="line">  push(item) &#123;</div><div class="line">    <span class="keyword">this</span>.stack.push(item)</div><div class="line">  &#125;</div><div class="line">  pop() &#123;</div><div class="line">    <span class="keyword">this</span>.stack.pop()</div><div class="line">  &#125;</div><div class="line">  peek() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.getCount() - <span class="number">1</span>]</div><div class="line">  &#125;</div><div class="line">  getCount() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.length</div><div class="line">  &#125;</div><div class="line">  isEmpty() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getCount() === <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>应用题<br>题目：<a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="external">Valid Parentheses</a><br>匹配括号，可以用栈来做<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> isValid = function (s) &#123;</div><div class="line">  <span class="built_in">let</span> <span class="built_in">map</span> = &#123;</div><div class="line">    '(': -<span class="number">1</span>,</div><div class="line">    ')': <span class="number">1</span>,</div><div class="line">    '[': -<span class="number">2</span>,</div><div class="line">    ']': <span class="number">2</span>,</div><div class="line">    '&#123;': -<span class="number">3</span>,</div><div class="line">    '&#125;': <span class="number">3</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">let</span> stack = []</div><div class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[s[i]] &lt; <span class="number">0</span>) &#123;</div><div class="line">      stack.<span class="built_in">push</span>(s[i])</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">let</span> <span class="built_in">last</span> = stack.<span class="built_in">pop</span>()</div><div class="line">      <span class="keyword">if</span> (<span class="built_in">map</span>[<span class="built_in">last</span>] + <span class="built_in">map</span>[s[i]] != <span class="number">0</span>) <span class="built_in">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (stack.<span class="built_in">length</span> &gt; <span class="number">0</span>) <span class="built_in">return</span> <span class="literal">false</span></div><div class="line">  <span class="built_in">return</span> <span class="literal">true</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="★30s总结"><a href="#★30s总结" class="headerlink" title="★30s总结"></a>★30s总结</h2><ul><li>记住图，先进后出</li></ul><hr><p>队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循<strong>先进先出</strong>的原则。<br><!--more--><br><img src="https://i.imgur.com/t7QNGSm.png" alt=""></p><blockquote><p>一、 单链队列 </p></blockquote><p>因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.queue = []</div><div class="line">  &#125;</div><div class="line">  enQueue(item) &#123;</div><div class="line">    <span class="keyword">this</span>.queue.push(item)</div><div class="line">  &#125;</div><div class="line">  deQueue() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.shift()</div><div class="line">  &#125;</div><div class="line">  getHeader() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="number">0</span>]</div><div class="line">  &#125;</div><div class="line">  getLength() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length</div><div class="line">  &#125;</div><div class="line">  isEmpty() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getLength() === <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>二、循环队列</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqQueue</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(length) &#123;</div><div class="line">    <span class="keyword">this</span>.queue = new Array(length + <span class="number">1</span>)</div><div class="line">    <span class="comment">// 队头</span></div><div class="line">    <span class="keyword">this</span>.first = <span class="number">0</span></div><div class="line">    <span class="comment">// 队尾</span></div><div class="line">    <span class="keyword">this</span>.last = <span class="number">0</span></div><div class="line">    <span class="comment">// 当前队列大小</span></div><div class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">  enQueue(item) &#123;</div><div class="line">    <span class="comment">// 判断队尾 + 1 是否为队头</span></div><div class="line">    <span class="comment">// 如果是就代表需要扩容数组</span></div><div class="line">    <span class="comment">// % this.queue.length 是为了防止数组越界</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.first === (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length) &#123;</div><div class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.getLength() * <span class="number">2</span> + <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.last] = item</div><div class="line">    <span class="keyword">this</span>.size++</div><div class="line">    <span class="keyword">this</span>.last = (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length</div><div class="line">  &#125;</div><div class="line">  deQueue() &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</div><div class="line">      <span class="keyword">throw</span> Error(<span class="string">'Queue is empty'</span>)</div><div class="line">    &#125;</div><div class="line">    let r = <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first]</div><div class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first] = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.first = (<span class="keyword">this</span>.first + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length</div><div class="line">    <span class="keyword">this</span>.size--</div><div class="line">    <span class="comment">// 判断当前队列大小是否过小</span></div><div class="line">    <span class="comment">// 为了保证不浪费空间，在队列空间等于总长度四分之一时</span></div><div class="line">    <span class="comment">// 且不为 2 时缩小总长度为当前的一半</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size === <span class="keyword">this</span>.getLength() / <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.getLength() / <span class="number">2</span> !== <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.getLength() / <span class="number">2</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> r</div><div class="line">  &#125;</div><div class="line">  getHeader() &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</div><div class="line">      <span class="keyword">throw</span> Error(<span class="string">'Queue is empty'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first]</div><div class="line">  &#125;</div><div class="line">  getLength() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length - <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">  isEmpty() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.first === <span class="keyword">this</span>.last</div><div class="line">  &#125;</div><div class="line">  resize(length) &#123;</div><div class="line">    let q = new Array(length)</div><div class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">      q[i] = <span class="keyword">this</span>.queue[(i + <span class="keyword">this</span>.first) % <span class="keyword">this</span>.queue.length]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.queue = q</div><div class="line">    <span class="keyword">this</span>.first = <span class="number">0</span></div><div class="line">    <span class="keyword">this</span>.last = <span class="keyword">this</span>.size</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="★30s总结-1"><a href="#★30s总结-1" class="headerlink" title="★30s总结"></a>★30s总结</h2><ul><li>记住图，先进先出</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源于 &lt;a href=&quot;https://leetcode.com/problems/invert-binary-tree/description/&quot;&gt;LeetCode - 226&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一、翻转二叉树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/gIjXNsQ.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;其实思路还是比较简单的：将当前的root节点的左右分支进行对调反转，若左分支存在，则将左分支的节点作为root节点进行对调反转；若右分支存在，则将右分支的节点作为root节点进行对调反转；一直 &lt;strong&gt;递归&lt;/strong&gt; 到所有节点的左右分支都不存在。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二分查找（binary search）</title>
    <link href="wangsiyuan233.github.io/2018/07/24/63%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>wangsiyuan233.github.io/2018/07/24/63二分查找/</id>
    <published>2018-07-24T02:02:34.000Z</published>
    <updated>2018-07-26T17:20:13.487Z</updated>
    
    <content type="html"><![CDATA[<p>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。</p><p>二分查找树也是二叉树，拥有二叉树的特性。但是区别在于二分查找树每个节点的值都<strong>比他的左子树的值大</strong>，<strong>比右子树的值小</strong>。</p><blockquote><p>一、创建一颗最简单的树</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(value) &#123;</div><div class="line">    <span class="keyword">this</span>.value = value</div><div class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">  getSize() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size</div><div class="line">  &#125;</div><div class="line">  isEmpty() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">  addNode(v) &#123;</div><div class="line">    <span class="keyword">this</span>.root = <span class="keyword">this</span>._addChild(<span class="keyword">this</span>.root, v)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 添加节点时，需要比较添加的节点值和当前</span></div><div class="line">  <span class="comment">// 节点值的大小</span></div><div class="line">  _addChild(node, v) &#123;</div><div class="line">    <span class="keyword">if</span> (!node) &#123;</div><div class="line">      <span class="keyword">this</span>.size++</div><div class="line">      <span class="keyword">return</span> new Node(v)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (node.value &gt; v) &#123;</div><div class="line">      node.left = <span class="keyword">this</span>._addChild(node.left, v)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</div><div class="line">      node.right = <span class="keyword">this</span>._addChild(node.right, v)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> node</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><blockquote><p>二、树的遍历</p></blockquote><p>1、深度遍历</p><p>对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。</p><p>以下都是递归实现：</p><p>1.1、先序遍历<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 先序遍历可用于打印树的结构</div><div class="line">// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</div><div class="line">preTraversal() &#123;</div><div class="line">  this._pre(this.root)</div><div class="line">&#125;</div><div class="line">_pre(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  if (<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">    console.log(<span class="keyword">node</span>.<span class="title">value</span>)</div><div class="line">    this._pre(<span class="keyword">node</span>.<span class="title">left</span>)</div><div class="line">    this._pre(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>1.2、中序遍历<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 中序遍历可用于排序</div><div class="line">// 对于 BST 来说，中序遍历可以实现一次遍历就</div><div class="line">// 得到有序的值</div><div class="line">// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</div><div class="line">midTraversal() &#123;</div><div class="line">  this._mid(this.root)</div><div class="line">&#125;</div><div class="line">_mid(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  if (<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">    this._mid(<span class="keyword">node</span>.<span class="title">left</span>)</div><div class="line">    console.log(<span class="keyword">node</span>.<span class="title">value</span>)</div><div class="line">    this._mid(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>1.3、后序遍历<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 后序遍历可用于先操作子节点</div><div class="line">// 再操作父节点的场景</div><div class="line">// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</div><div class="line">backTraversal() &#123;</div><div class="line">  this._back(this.root)</div><div class="line">&#125;</div><div class="line">_back(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  if (<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">    this._back(<span class="keyword">node</span>.<span class="title">left</span>)</div><div class="line">    this._back(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">    console.log(<span class="keyword">node</span>.<span class="title">value</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2、广度遍历<br>也就是一层层地遍历树。对于广度遍历来说，我们需要利用 队列结构 来完成。<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">breadthTraversal() &#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="literal">this</span>.root) <span class="keyword">return</span> null</div><div class="line">  <span class="keyword">let</span> q = <span class="function"><span class="keyword">new</span> <span class="title">Queue</span>()</span></div><div class="line">  <span class="comment">// 将根节点入队</span></div><div class="line">  <span class="title">q</span>.<span class="title">enQueue</span>(this.root)</div><div class="line">  <span class="comment">// 循环判断队列是否为空，为空</span></div><div class="line">  <span class="comment">// 代表树遍历完毕</span></div><div class="line">  <span class="title">while</span> (!q.isEmpty()) &#123;</div><div class="line">    <span class="comment">// 将队首出队，判断是否有左右子树</span></div><div class="line">    <span class="comment">// 有的话，就先左后右入队</span></div><div class="line">    <span class="title">let</span> <span class="title">n</span> = <span class="title">q</span>.<span class="title">deQueue</span>()</div><div class="line">    <span class="title">console</span>.<span class="title">log</span>(n.value)</div><div class="line">    <span class="title">if</span> (n.left) <span class="title">q</span>.<span class="title">enQueue</span>(n.left)</div><div class="line">    <span class="title">if</span> (n.right) <span class="title">q</span>.<span class="title">enQueue</span>(n.right)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>三、寻找最值</p></blockquote><p>第一步：因为二分查找树的特性，所以最小值一定在根节点的最左边，最大值相反<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">getMin() &#123;</div><div class="line">  return this._getMin(this.root).value</div><div class="line">&#125;</div><div class="line">_getMin(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  if (!<span class="keyword">node</span>.<span class="title">left</span>) return <span class="keyword">node</span></div><div class="line">  <span class="title">return</span> this._getMin(<span class="keyword">node</span>.<span class="title">left</span>)</div><div class="line">&#125;</div><div class="line">getMax() &#123;</div><div class="line">  return this._getMax(this.root).value</div><div class="line">&#125;</div><div class="line">_getMax(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  if (!<span class="keyword">node</span>.<span class="title">right</span>) return <span class="keyword">node</span></div><div class="line">  <span class="title">return</span> this._getMin(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第二步：向上取整和向下取整，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。</p><p>既然是向下取整，那么根据二分查找树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">floor(v) &#123;</div><div class="line">  let <span class="keyword">node</span> <span class="title">= this</span>._floor(this.root, v)</div><div class="line">  return <span class="keyword">node</span> <span class="title">? node</span>.value : null</div><div class="line">&#125;</div><div class="line">_floor(<span class="keyword">node</span><span class="title">, v</span>) &#123;</div><div class="line">  if (!<span class="keyword">node</span><span class="title">) return</span> null</div><div class="line">  if (<span class="keyword">node</span>.<span class="title">value</span> === v) return v</div><div class="line">  // 如果当前节点值还比需要的值大，就继续递归</div><div class="line">  if (<span class="keyword">node</span>.<span class="title">value</span> &gt; v) &#123;</div><div class="line">    return this._floor(<span class="keyword">node</span>.<span class="title">left</span>, v)</div><div class="line">  &#125;</div><div class="line">  // 判断当前节点是否拥有右子树</div><div class="line">  let right = this._floor(<span class="keyword">node</span>.<span class="title">right</span>, v)</div><div class="line">  if (right) return right</div><div class="line">  return <span class="keyword">node</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p><p>第三步：<strong>排 名</strong><br>这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 <code>size</code> 属性。该属性表示该节点下有多少子节点（包含自身）<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(value) &#123;</div><div class="line">    <span class="keyword">this</span>.value = value</div><div class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></div><div class="line">    <span class="comment">// 修改代码</span></div><div class="line">    <span class="keyword">this</span>.size = <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 新增代码</span></div><div class="line">_getSize(node) &#123;</div><div class="line">  <span class="keyword">return</span> node ? node.size : <span class="number">0</span></div><div class="line">&#125;</div><div class="line">_addChild(node, v) &#123;</div><div class="line">  <span class="keyword">if</span> (!node) &#123;</div><div class="line">    <span class="keyword">return</span> new Node(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</div><div class="line">    <span class="comment">// 修改代码</span></div><div class="line">    node.size++</div><div class="line">    node.left = <span class="keyword">this</span>._addChild(node.left, v)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</div><div class="line">    <span class="comment">// 修改代码</span></div><div class="line">    node.size++</div><div class="line">    node.right = <span class="keyword">this</span>._addChild(node.right, v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> node</div><div class="line">&#125;</div><div class="line">select(k) &#123;</div><div class="line">  let node = <span class="keyword">this</span>._select(<span class="keyword">this</span>.root, k)</div><div class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></div><div class="line">&#125;</div><div class="line">_select(node, k) &#123;</div><div class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">  <span class="comment">// 先获取左子树下有几个节点</span></div><div class="line">  let size = node.left ? node.left.size : <span class="number">0</span></div><div class="line">  <span class="comment">// 判断 size 是否大于 k</span></div><div class="line">  <span class="comment">// 如果大于 k，代表所需要的节点在左节点</span></div><div class="line">  <span class="keyword">if</span> (size &gt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.left, k)</div><div class="line">  <span class="comment">// 如果小于 k，代表所需要的节点在右节点</span></div><div class="line">  <span class="comment">// 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span></div><div class="line">  <span class="keyword">if</span> (size &lt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.right, k - size - <span class="number">1</span>)</div><div class="line">  <span class="keyword">return</span> node</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>四、删除(最小)节点</p></blockquote><p>对于删除节点来说，会存在以下几种情况</p><ul><li>需要删除的节点没有子树</li><li>需要删除的节点只有一条子树</li><li>需要删除的节点有左右两条树</li></ul><p>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：<strong>删除最小节点</strong>，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">delectMin() &#123;</div><div class="line">  this.root = this._delectMin(this.root)</div><div class="line">  console.log(this.root)</div><div class="line">&#125;</div><div class="line">_delectMin(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  // 一直递归左子树</div><div class="line">  // 如果左子树为空，就判断节点是否拥有右子树</div><div class="line">  // 有右子树的话就把需要删除的节点替换为右子树</div><div class="line">  if ((<span class="keyword">node</span> <span class="title">!= null</span>) &amp; !<span class="keyword">node</span>.<span class="title">left</span>) return <span class="keyword">node</span>.<span class="title">right</span></div><div class="line">  <span class="keyword">node</span>.<span class="title">left</span> = this._delectMin(<span class="keyword">node</span>.<span class="title">left</span>)</div><div class="line">  // 最后需要重新维护下节点的 `size`</div><div class="line">  <span class="keyword">node</span>.<span class="title">size</span> = this._getSize(<span class="keyword">node</span>.<span class="title">left</span>) + this._getSize(<span class="keyword">node</span>.<span class="title">right</span>) + <span class="number">1</span></div><div class="line">  return <span class="keyword">node</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p><blockquote><p>五、删除(任意)节点</p></blockquote><p>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。</p><p>你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分查找树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">delect(v) &#123;</div><div class="line">  this.root = this._delect(this.root, v)</div><div class="line">&#125;</div><div class="line">_delect(<span class="keyword">node</span><span class="title">, v</span>) &#123;</div><div class="line">  if (!<span class="keyword">node</span><span class="title">) return</span> null</div><div class="line">  // 寻找的节点比当前节点小，去左子树找</div><div class="line">  if (<span class="keyword">node</span>.<span class="title">value</span> <span class="tag">&lt; v) &#123;</span></div><div class="line">    node.right = this._delect(node.right, v)</div><div class="line">  &#125; else if (node.value &gt; v) &#123;</div><div class="line">    // 寻找的节点比当前节点大，去右子树找</div><div class="line">    <span class="keyword">node</span>.<span class="title">left</span> = this._delect(<span class="keyword">node</span>.<span class="title">left</span>, v)</div><div class="line">  &#125; else &#123;</div><div class="line">    // 进入这个条件说明已经找到节点</div><div class="line">    // 先判断节点是否拥有拥有左右子树中的一个</div><div class="line">    // 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样</div><div class="line">    if (!<span class="keyword">node</span>.<span class="title">left</span>) return <span class="keyword">node</span>.<span class="title">right</span></div><div class="line">    if (!<span class="keyword">node</span>.<span class="title">right</span>) return <span class="keyword">node</span>.<span class="title">left</span></div><div class="line">    // 进入这里，代表节点拥有左右子树</div><div class="line">    // 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</div><div class="line">    let min = this._getMin(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">    // 取出最小值后，删除最小值</div><div class="line">    // 然后把删除节点后的子树赋值给最小值节点</div><div class="line">    min.right = this._delectMin(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">    // 左子树不动</div><div class="line">    min.left = <span class="keyword">node</span>.<span class="title">left</span></div><div class="line">    <span class="keyword">node</span> <span class="title">= min</span></div><div class="line">  &#125;</div><div class="line">  // 维护 size</div><div class="line">  <span class="keyword">node</span>.<span class="title">size</span> = this._getSize(<span class="keyword">node</span>.<span class="title">left</span>) + this._getSize(<span class="keyword">node</span>.<span class="title">right</span>) + <span class="number">1</span></div><div class="line">  return <span class="keyword">node</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。&lt;/p&gt;
&lt;p&gt;二分查找树也是二叉树，拥有二叉树的特性。但是区别在于二分查找树每个节点的值都&lt;strong&gt;比他的左子树的值大&lt;/strong&gt;，&lt;strong&gt;比右子树的值小&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一、创建一颗最简单的树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(value) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value = value&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.left = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.right = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BST&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.root = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  getSize() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  isEmpty() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  addNode(v) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.root = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._addChild(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.root, v)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 添加节点时，需要比较添加的节点值和当前&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 节点值的大小&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _addChild(node, v) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!node) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size++&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; new Node(v)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (node.value &amp;gt; v) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      node.left = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._addChild(node.left, v)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (node.value &amp;lt; v) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      node.right = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._addChild(node.right, v)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; node&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="wangsiyuan233.github.io/2018/07/19/62%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>wangsiyuan233.github.io/2018/07/19/62排序算法/</id>
    <published>2018-07-19T03:27:06.000Z</published>
    <updated>2018-07-25T23:25:48.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 准备</p></blockquote><p>1、时间复杂度：</p><p>通常使用最差的时间复杂度来衡量一个算法的好坏。</p><p>常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。</p><p>对于一个算法来说，可能会计算出如下操作次数 <code>aN + 1</code>，<code>N</code> 代表数据量。那么该算法的时间复杂度就是 <code>O(N)</code>。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。</p><p>当然可能会出现两个算法都是 <code>O(N)</code> 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。</p><p>2、以下两个函数是本章节经常会用到的：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> checkArray(<span class="built_in">array</span>)&#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="built_in">array</span> || <span class="built_in">array</span>.length &lt;= <span class="number">2</span>) return</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> swap(<span class="built_in">array</span>, <span class="built_in">left</span>, <span class="built_in">right</span>) &#123;</div><div class="line">  <span class="keyword">let</span> rightValue = <span class="built_in">array</span>[<span class="built_in">right</span>]</div><div class="line">  <span class="built_in">array</span>[<span class="built_in">right</span>] = <span class="built_in">array</span>[<span class="built_in">left</span>]</div><div class="line">  <span class="built_in">array</span>[<span class="built_in">left</span>] = rightValue</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><a id="more"></a><blockquote><p>一、冒泡排序</p></blockquote><p>冒泡排序是最简单的排序了，效率低下，从第一个开始，通过不断的和下一个数相比较，最后使得最小的数字在前面，最大的数字在后面。只用比较到 <code>length - 1</code></p><p>代码实现：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span><span class="params">(array)</span></span>&#123;</div><div class="line">  checkArray(<span class="keyword">array</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i =  <span class="keyword">array</span>.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="comment">// 从 倒数第二个数 遍历到 0</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</div><div class="line">      <span class="comment">// 从 0 开始遍历到 i 的左边</span></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">array</span>[j] &gt; <span class="keyword">array</span>[j+<span class="number">1</span>])&#123;</div><div class="line">        swap(<span class="keyword">array</span>, j, j+<span class="number">1</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">array</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/TplSwHr.gif" alt=""><br>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是<code>O(n * n)</code></p><blockquote><p>二、插入排序</p></blockquote><p>原理：默认第一个数是已经排好了的，取出第二个数和第一个数比较，大的往后，小的在前；第三个数和此时第二个数+第一个数（之前所有的数）比较，以此类推。<br>代码实现：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span><span class="params">(arry)</span></span>&#123;</div><div class="line">  checkArray(<span class="keyword">array</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">array</span>[j] &gt; <span class="keyword">array</span>[j+<span class="number">1</span>]; j--) &#123;</div><div class="line">      swap(<span class="keyword">array</span>, j, j+<span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/CxZXZea.gif" alt=""><br>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(n * n)</code></p><blockquote><p>三、选择排序</p></blockquote><p>原理：假定第一个数是最小值，遍历剩余数组，找出比它小的(最小的)数值；找得到就是新数字是最小值，找不到还是假定值是最小值；确定了真正的最小值了，就可以从第二个数字开始遍历<br>代码实现：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span><span class="params">(array)</span></span>&#123;</div><div class="line">  checkArray(<span class="keyword">array</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length - <span class="number">1</span>; i++)&#123;</div><div class="line">    <span class="comment">// 从 0 到 倒数第二个</span></div><div class="line">    <span class="keyword">let</span> minIndex = i;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; <span class="keyword">array</span>.length; j++)&#123;</div><div class="line">      <span class="comment">// 从 第一个 到 最后一个</span></div><div class="line">      minIndex = <span class="keyword">array</span>[j] &lt; <span class="keyword">array</span>[minIndex] ? j : minIndex;</div><div class="line">      <span class="comment">// 最小的值 = 和 j 比较后 最小的那个值</span></div><div class="line">    &#125;</div><div class="line">    swap(<span class="keyword">array</span>, i, minIndex);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/R739A83.gif" alt=""><br>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(n * n)</code></p><blockquote><p>四、归并排序</p></blockquote><p>原理：递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 [3, 1, 2, 8, 9, 7, 6]，中间数索引是 3，先排序数组 [3, 1, 2, 8] 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 [3, 1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序。<br>代码实现：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span><span class="params">(array)</span> </span>&#123;</div><div class="line">  checkArray(<span class="keyword">array</span>);</div><div class="line">  mergeSort(<span class="keyword">array</span>, <span class="number">0</span>, <span class="keyword">array</span>.length - <span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span><span class="params">(array, left, right)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (left === right) <span class="keyword">return</span>;</div><div class="line">  <span class="comment">// 左右索引相同说明已经只有一个数</span></div><div class="line">  <span class="keyword">let</span> mid = parseInt(left + ((right - left) &gt;&gt; <span class="number">1</span>));</div><div class="line">  <span class="comment">// 等同于 `left + (right - left) / 2`</span></div><div class="line">  <span class="comment">// 相比 `(left + right) / 2` 来说更加安全，不会溢出</span></div><div class="line">  <span class="comment">// 使用位运算是因为位运算比四则运算快</span></div><div class="line">  mergeSort(<span class="keyword">array</span>, left, mid);</div><div class="line">  mergeSort(<span class="keyword">array</span>, mid + <span class="number">1</span>, right);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> help = [];</div><div class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">let</span> p1 = left;</div><div class="line">  <span class="keyword">let</span> p2 = mid + <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</div><div class="line">    help[i++] = <span class="keyword">array</span>[p1] &lt; <span class="keyword">array</span>[p2] ? <span class="keyword">array</span>[p1++] : <span class="keyword">array</span>[p2++];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (p1 &lt;= mid) &#123;</div><div class="line">    help[i++] = <span class="keyword">array</span>[p1++];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (p2 &lt;= right) &#123;</div><div class="line">    help[i++] = <span class="keyword">array</span>[p2++];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</div><div class="line">    <span class="keyword">array</span>[left + i] = help[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以上算法使用了递归的思想。递归的本质就是压栈，每递归执行一次函数，就将该函数的信息（比如参数，内部的变量，执行到的行数）压栈，直到遇到终止条件，然后出栈并继续执行函数。对于以上递归函数的调用轨迹如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mergeSort(data, <span class="number">0</span>, <span class="number">6</span>) <span class="comment">// mid = 3</span></div><div class="line">  mergeSort(data, <span class="number">0</span>, <span class="number">3</span>) <span class="comment">// mid = 1</span></div><div class="line">    mergeSort(data, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// mid = 0</span></div><div class="line">      mergeSort(data, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 遇到终止，回退到上一步</span></div><div class="line">    mergeSort(data, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 遇到终止，回退到上一步</span></div><div class="line">    <span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 1</span></div><div class="line">    <span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行下一个递归</span></div><div class="line">  mergeSort(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// mid = 2</span></div><div class="line">    mergeSort(<span class="number">3</span>, <span class="number">3</span>) <span class="comment">// 遇到终止，回退到上一步</span></div><div class="line">  <span class="comment">// 排序 p1 = 2, p2 = mid + 1 = 3</span></div><div class="line">  <span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行合并逻辑</span></div><div class="line">  <span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 2</span></div><div class="line">  <span class="comment">// 执行完毕回退</span></div><div class="line">  <span class="comment">// 左边数组排序完毕，右边也是如上轨迹</span></div></pre></td></tr></table></figure></p><p>该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 2T(N / 2) + T(N) （T 代表时间，N 代表数据量）。根据该表达式可以套用 该公式 得出时间复杂度为 O(N * logN)<br><img src="https://i.imgur.com/beqzC1d.gif" alt=""></p><blockquote><p>五、快排</p></blockquote><p>原理：随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。<br>代码实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function <span class="built_in">sort</span>(array) &#123;</div><div class="line">  checkArray(array);</div><div class="line">  <span class="built_in">quickSort</span>(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function <span class="built_in">quickSort</span>(array, <span class="keyword">left</span>, <span class="keyword">right</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;</div><div class="line">    <span class="built_in">swap</span>(array, , <span class="keyword">right</span>)</div><div class="line">    <span class="comment">// 随机取值，然后和末尾交换，这样做比固定取一个位置的复杂度略低</span></div><div class="line">    <span class="keyword">let</span> indexs = part(array, parseInt(<span class="type">Math</span>.random() * (<span class="keyword">right</span> - <span class="keyword">left</span> + <span class="number">1</span>)) + <span class="keyword">left</span>, <span class="keyword">right</span>);</div><div class="line">    <span class="built_in">quickSort</span>(array, <span class="keyword">left</span>, indexs[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">quickSort</span>(array, indexs[<span class="number">1</span>] + <span class="number">1</span>, <span class="keyword">right</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">function part(array, <span class="keyword">left</span>, <span class="keyword">right</span>) &#123;</div><div class="line">  <span class="keyword">let</span> less = <span class="keyword">left</span> - <span class="number">1</span>;</div><div class="line">  <span class="keyword">let</span> more = <span class="keyword">right</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">left</span> &lt; more) &#123;</div><div class="line">    <span class="keyword">if</span> (array[<span class="keyword">left</span>] &lt; array[<span class="keyword">right</span>]) &#123;</div><div class="line">      <span class="comment">// 当前值比基准值小，`less` 和 `left` 都加一</span></div><div class="line">   ++less;</div><div class="line">       ++<span class="keyword">left</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[<span class="keyword">left</span>] &gt; array[<span class="keyword">right</span>]) &#123;</div><div class="line">      <span class="comment">// 当前值比基准值大，将当前值和右边的值交换</span></div><div class="line">      <span class="comment">// 并且不改变 `left`，因为当前换过来的值还没有判断过大小</span></div><div class="line">      <span class="built_in">swap</span>(array, --more, <span class="keyword">left</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 和基准值相同，只移动下标</span></div><div class="line">      <span class="keyword">left</span>++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 将基准值和比基准值大的第一个值交换位置</span></div><div class="line">  <span class="comment">// 这样数组就变成 `[比基准值小, 基准值, 比基准值大]`</span></div><div class="line">  <span class="built_in">swap</span>(array, <span class="keyword">right</span>, more);</div><div class="line">  <span class="keyword">return</span> [less, more];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 O(logN)，并且相比归并排序来说，所需的常数时间也更少。<br><img src="https://i.imgur.com/CJkbSuw.gif" alt=""></p><blockquote><p>六、计数排序</p></blockquote><p><img src="https://i.imgur.com/hX1CFZV.gif" alt=""></p><blockquote><p>七、堆排序</p></blockquote><p>原理：堆排序<br>堆排序利用了二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆。</p><ul><li>大根堆是某个节点的所有子节点的值都比他小</li><li>小根堆是某个节点的所有子节点的值都比他大<br>堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 i <em> 2 + 1，右边是 i </em> 2 + 2，父节点是 (i - 1) /2。</li></ul><p>1、首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大<br>2、重新以上操作 1，直到数组首位是最大值<br>3、然后将首位和末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小<br>4、对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置<br>5、重复以上操作 3 - 4 直到整个数组都是大根堆。<br>代码实现：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">function heap(<span class="keyword">array</span>) &#123;</div><div class="line">  checkArray(<span class="keyword">array</span>);</div><div class="line">  <span class="comment">// 将最大值交换到首位</span></div><div class="line">  <span class="built_in">for</span> (let i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</div><div class="line">    heapInsert(<span class="keyword">array</span>, i);</div><div class="line">  &#125;</div><div class="line">  let <span class="built_in">size</span> = <span class="keyword">array</span>.length;</div><div class="line">  <span class="comment">// 交换首位和末尾</span></div><div class="line">  swap(<span class="keyword">array</span>, <span class="number">0</span>, --<span class="built_in">size</span>);</div><div class="line">  <span class="built_in">while</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">    heapify(<span class="keyword">array</span>, <span class="number">0</span>, <span class="built_in">size</span>);</div><div class="line">    swap(<span class="keyword">array</span>, <span class="number">0</span>, --<span class="built_in">size</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> <span class="keyword">array</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function heapInsert(<span class="keyword">array</span>, index) &#123;</div><div class="line">  <span class="comment">// 如果当前节点比父节点大，就交换</span></div><div class="line">  <span class="built_in">while</span> (<span class="keyword">array</span>[index] &gt; <span class="keyword">array</span>[<span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>)]) &#123;</div><div class="line">    swap(<span class="keyword">array</span>, index, <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>));</div><div class="line">    <span class="comment">// 将索引变成父节点</span></div><div class="line">    index = <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">function heapify(<span class="keyword">array</span>, index, <span class="built_in">size</span>) &#123;</div><div class="line">  let left = index * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">  <span class="built_in">while</span> (left &lt; <span class="built_in">size</span>) &#123;</div><div class="line">    <span class="comment">// 判断左右节点大小</span></div><div class="line">    let largest =</div><div class="line">      left + <span class="number">1</span> &lt; <span class="built_in">size</span> &amp;&amp; <span class="keyword">array</span>[left] &lt; <span class="keyword">array</span>[left + <span class="number">1</span>] ? left + <span class="number">1</span> : left;</div><div class="line">    <span class="comment">// 判断子节点和父节点大小</span></div><div class="line">    largest = <span class="keyword">array</span>[index] &lt; <span class="keyword">array</span>[largest] ? largest : index;</div><div class="line">    <span class="built_in">if</span> (largest === index) <span class="built_in">break</span>;</div><div class="line">    swap(<span class="keyword">array</span>, index, largest);</div><div class="line">    index = largest;</div><div class="line">    left = index * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以上代码实现了小根堆，如果需要实现大根堆，只需要把节点对比反一下就好。该算法的复杂度是 O(logN)<br><img src="https://i.imgur.com/LbPIhff.gif" alt=""></p><p>每个语言的排序内部实现都是不同的。</p><p>对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序 。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和 O(N * logN)相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p><p>对于 Java 来说，还会考虑内部的元素的类型。对于存储对象的数组来说，会采用稳定性好的算法。稳定性的意思就是对于相同值来说，相对顺序不能改变。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 准备&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、时间复杂度：&lt;/p&gt;
&lt;p&gt;通常使用最差的时间复杂度来衡量一个算法的好坏。&lt;/p&gt;
&lt;p&gt;常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。&lt;/p&gt;
&lt;p&gt;对于一个算法来说，可能会计算出如下操作次数 &lt;code&gt;aN + 1&lt;/code&gt;，&lt;code&gt;N&lt;/code&gt; 代表数据量。那么该算法的时间复杂度就是 &lt;code&gt;O(N)&lt;/code&gt;。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。&lt;/p&gt;
&lt;p&gt;当然可能会出现两个算法都是 &lt;code&gt;O(N)&lt;/code&gt; 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。&lt;/p&gt;
&lt;p&gt;2、以下两个函数是本章节经常会用到的：&lt;br&gt;&lt;figure class=&quot;highlight vbscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; checkArray(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; || &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;.length &amp;lt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) return&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; swap(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;left&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;right&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; rightValue = &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;built_in&quot;&gt;right&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;built_in&quot;&gt;right&lt;/span&gt;] = &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;built_in&quot;&gt;left&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;built_in&quot;&gt;left&lt;/span&gt;] = rightValue&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
